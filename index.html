<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>RoseReader</title>
	  <style>
	    :root {
	      --primary: #d4436a;
	      --primary-dark: #b8345a;
	      --primary-light: #fdf2f4;
	      --bg: #f7f8fb;
	      --bg-card: #ffffff;
	      --bg-hover: #f3f4f7;
	      --text: #211c1f;
	      --text-secondary: rgba(33, 28, 31, 0.62);
	      --border: rgba(33, 28, 31, 0.10);
	      --shadow: 0 4px 20px rgba(0,0,0,0.06);
	      --shadow-lg: 0 18px 60px rgba(0,0,0,0.14);
	      --radius: 16px;
	      --radius-sm: 10px;
	      --transition: 0.22s cubic-bezier(0.4, 0, 0.2, 1);
	      --library-max-width: 1440px;
	      --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
	      --ease-inout: cubic-bezier(0.45, 0, 0.55, 1);
	      --ring: 0 0 0 3px color-mix(in srgb, var(--primary) 22%, transparent);
	      --glass: color-mix(in srgb, var(--bg-card) 78%, transparent);
	      --glass-strong: color-mix(in srgb, var(--bg-card) 88%, transparent);
	      --surface: color-mix(in srgb, var(--bg-card) 92%, transparent);
	      --hairline: color-mix(in srgb, var(--border) 78%, transparent);
	      --paper: color-mix(in srgb, #fff 78%, var(--bg) 22%);
	      --glow-1: rgba(212, 67, 106, 0.14);
	      --glow-2: rgba(255, 220, 232, 0.22);
	      --glow-3: rgba(198, 208, 255, 0.18);
	      --glow-4: rgba(255, 246, 220, 0.18);
	      --main-hall-tile-size: 228px;
	    }
	    * { margin: 0; padding: 0; box-sizing: border-box; }
	    body {
	      font-family: "Avenir Next", "Avenir", "Helvetica Neue", "Noto Sans", "Segoe UI", system-ui, sans-serif;
	      height: 100vh;
	      overflow: hidden;
	      background: var(--bg);
	      color: var(--text);
	      -webkit-font-smoothing: antialiased;
	      text-rendering: optimizeLegibility;
	      letter-spacing: -0.01em;
	    }
	    :focus-visible { outline: none; box-shadow: var(--ring); border-radius: 10px; }
	    ::selection { background: color-mix(in srgb, var(--primary-light) 70%, #fff 30%); }
	    ::-webkit-scrollbar { width: 10px; height: 10px; }
	    ::-webkit-scrollbar-thumb { background: color-mix(in srgb, var(--border) 80%, transparent); border-radius: 999px; border: 3px solid transparent; background-clip: padding-box; }
	    ::-webkit-scrollbar-thumb:hover { background: color-mix(in srgb, var(--border) 100%, transparent); }
	    ::-webkit-scrollbar-track { background: transparent; }
	    body::before {
	      content: "";
	      position: fixed;
	      inset: 0;
	      background-image: var(--app-bg-image, none);
	      background-size: cover;
	      background-position: center;
	      opacity: var(--app-bg-opacity, 0);
	      filter: blur(var(--app-bg-blur, 0px));
	      transform: scale(1.06);
	      pointer-events: none;
	      z-index: -1;
	    }
	    body::after {
	      content: "";
	      position: fixed;
	      inset: -12%;
	      pointer-events: none;
	      z-index: -1;
	      background:
	        radial-gradient(1000px 640px at 12% 8%, var(--glow-1), transparent 56%),
	        radial-gradient(720px 520px at 88% 14%, var(--glow-2), transparent 55%),
	        radial-gradient(860px 700px at 76% 92%, var(--glow-3), transparent 55%),
	        radial-gradient(1000px 780px at 12% 92%, var(--glow-4), transparent 60%),
	        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
	      mix-blend-mode: multiply;
	      opacity: 0.75;
	      filter: saturate(1.06) contrast(1.02);
	    }
    .app { height: 100vh; display: flex; flex-direction: column; }
    #library-view { display: flex; flex-direction: column; height: 100vh; min-height: 0; }
    #library-content { flex: 1; overflow: hidden; padding: 0; min-height: 0; }

	    /* Header */
	    header { display: flex; align-items: center; gap: 12px; padding: 14px 18px; background: var(--glass-strong); border-bottom: 1px solid var(--hairline); flex-shrink: 0; backdrop-filter: blur(18px) saturate(160%); }
	    .logo-group { display: flex; align-items: center; gap: 10px; }
	    .logo-rose { filter: drop-shadow(0 2px 4px rgba(212, 67, 106, 0.25)); transition: transform 0.3s var(--ease-out); }
	    .logo-group:hover .logo-rose { transform: rotate(15deg) scale(1.08); }
		    header h1 { font-size: 1.22rem; font-weight: 760; color: color-mix(in srgb, var(--primary) 92%, var(--text) 8%); letter-spacing: -0.5px; font-family: "Iowan Old Style", "Palatino Linotype", "Book Antiqua", Georgia, serif; }
		    .header-spacer { flex: 1; }
		    /* Library search - Modern Command Palette */
		    .library-search {
		      position: relative;
		      display: flex;
		      align-items: center;
		      gap: 10px;
		      width: min(400px, 38vw);
		      padding: 8px 14px;
		      border-radius: 10px;
		      border: 1px solid var(--hairline);
		      background: color-mix(in srgb, var(--bg) 70%, var(--bg-card) 30%);
		      cursor: text;
		      transition: all 0.15s ease;
		    }
		    .library-search:hover {
		      border-color: color-mix(in srgb, var(--text) 15%, transparent);
		      background: color-mix(in srgb, var(--bg-card) 60%, transparent);
		    }
		    .library-search svg { width: 16px; height: 16px; color: var(--text-secondary); flex-shrink: 0; }
		    .library-search input {
		      flex: 1;
		      border: none;
		      background: transparent;
		      outline: none;
		      font-size: 0.9rem;
		      color: var(--text);
		      min-width: 40px;
		    }
		    .library-search input::placeholder { color: var(--text-secondary); opacity: 0.6; }
		    .library-search .search-clear { display: none; }
		    .library-search kbd {
		      font-size: 0.7rem;
		      font-weight: 500;
		      padding: 2px 6px;
		      border-radius: 5px;
		      background: color-mix(in srgb, var(--text) 6%, transparent);
		      border: 1px solid color-mix(in srgb, var(--text) 8%, transparent);
		      color: var(--text-secondary);
		      font-family: inherit;
		    }
		    .library-search.active { pointer-events: none; z-index: 10000; }
		    .library-search.active kbd { display: none; }

		    /* Search Overlay - Full screen modal */
		    #search-overlay {
		      position: fixed;
		      inset: 0;
		      background: rgba(0, 0, 0, 0.4);
		      backdrop-filter: blur(8px);
		      z-index: 9998;
		      opacity: 0;
		      pointer-events: none;
		      transition: opacity 0.2s ease;
		    }
		    #search-overlay.active { opacity: 1; pointer-events: auto; }
		    :root[data-app-theme="dark"] #search-overlay { background: rgba(0, 0, 0, 0.6); }

		    /* Command Palette Modal */
		    .library-search-popover {
		      position: fixed;
		      top: max(80px, 12vh);
		      left: 50%;
		      transform: translateX(-50%) translateY(-20px);
		      width: min(580px, 90vw);
		      max-height: min(480px, 70vh);
		      overflow: hidden;
		      border-radius: 16px;
		      border: 1px solid color-mix(in srgb, var(--border) 60%, transparent);
		      background: var(--bg-card);
		      box-shadow: 0 24px 80px rgba(0,0,0,0.25), 0 0 1px rgba(0,0,0,0.1);
		      display: none;
		      flex-direction: column;
		      z-index: 9999;
		      opacity: 0;
		      transition: opacity 0.15s ease, transform 0.15s ease;
		    }
		    .library-search.active .library-search-popover,
		    .library-search-popover.active {
		      display: flex;
		      opacity: 1;
		      transform: translateX(-50%) translateY(0);
		    }

		    /* Search input inside modal */
		    .library-search-popover .pop-search-row {
		      display: flex;
		      align-items: center;
		      gap: 12px;
		      padding: 16px 18px;
		      border-bottom: 1px solid var(--hairline);
		    }
		    .library-search-popover .pop-search-row svg { width: 20px; height: 20px; color: var(--text-secondary); flex-shrink: 0; }
		    .library-search-popover .pop-search-row input {
		      flex: 1;
		      border: none;
		      background: transparent;
		      outline: none;
		      font-size: 1.05rem;
		      color: var(--text);
		      font-weight: 500;
		    }
		    .library-search-popover .pop-search-row input::placeholder { color: var(--text-secondary); opacity: 0.5; }
		    .library-search-popover .pop-search-clear {
		      width: 22px;
		      height: 22px;
		      border-radius: 6px;
		      border: none;
		      background: color-mix(in srgb, var(--text) 8%, transparent);
		      color: var(--text-secondary);
		      cursor: pointer;
		      display: none;
		      align-items: center;
		      justify-content: center;
		    }
		    .library-search-popover .pop-search-clear:hover { background: color-mix(in srgb, var(--text) 15%, transparent); }
		    .library-search-popover.has-query .pop-search-clear { display: inline-flex; }

		    /* Results list */
		    .library-search-popover .pop-list {
		      flex: 1;
		      padding: 8px;
		      overflow-y: auto;
		      overscroll-behavior: contain;
		    }
		    .library-search-popover .pop-section {
		      padding: 8px 10px 6px;
		      font-size: 0.7rem;
		      font-weight: 600;
		      text-transform: uppercase;
		      letter-spacing: 0.5px;
		      color: var(--text-secondary);
		      opacity: 0.7;
		    }
		    .library-search-popover .pop-empty {
		      padding: 48px 20px;
		      color: var(--text-secondary);
		      text-align: center;
		      font-size: 0.9rem;
		    }
		    .library-search-popover .pop-empty-icon {
		      width: 48px;
		      height: 48px;
		      margin: 0 auto 12px;
		      opacity: 0.3;
		    }

		    /* Result items */
		    .library-search-popover .pop-item {
		      display: flex;
		      align-items: center;
		      gap: 12px;
		      padding: 10px 12px;
		      border-radius: 10px;
		      cursor: pointer;
		      transition: background 0.08s ease, transform 0.1s ease;
		      animation: popItemIn 0.15s ease backwards;
		      border: none;
		      background: transparent;
		      text-align: left;
		      width: 100%;
		      font: inherit;
		      color: inherit;
		    }
		    @keyframes popItemIn {
		      from { opacity: 0; transform: translateY(-4px); }
		    }
		    .library-search-popover .pop-item:nth-child(2) { animation-delay: 0.02s; }
		    .library-search-popover .pop-item:nth-child(3) { animation-delay: 0.04s; }
		    .library-search-popover .pop-item:nth-child(4) { animation-delay: 0.06s; }
		    .library-search-popover .pop-item:nth-child(5) { animation-delay: 0.08s; }
		    .library-search-popover .pop-item:hover { background: color-mix(in srgb, var(--text) 5%, transparent); }
		    .library-search-popover .pop-item.selected {
		      background: var(--primary);
		      color: white;
		      transform: scale(1.01);
		    }
		    .library-search-popover .pop-cover {
		      width: 36px;
		      height: 50px;
		      border-radius: 5px;
		      overflow: hidden;
		      background: linear-gradient(135deg, color-mix(in srgb, var(--primary-light) 50%, #fff) 0%, var(--primary-light) 100%);
		      display: flex;
		      align-items: center;
		      justify-content: center;
		      flex-shrink: 0;
		      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
		    }
		    .library-search-popover .pop-cover img { width: 100%; height: 100%; object-fit: cover; }
		    .library-search-popover .pop-cover svg { width: 16px; height: 16px; color: var(--primary); opacity: 0.6; }
		    .library-search-popover .pop-item.selected .pop-cover svg { color: white; }
		    .library-search-popover .pop-info { flex: 1; min-width: 0; }
		    .library-search-popover .pop-titleline {
		      font-weight: 600;
		      font-size: 0.9rem;
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		      color: var(--text);
		    }
		    .library-search-popover .pop-item.selected .pop-titleline { color: white; }
		    .library-search-popover .pop-metaline {
		      font-size: 0.8rem;
		      color: var(--text-secondary);
		      white-space: nowrap;
		      overflow: hidden;
		      text-overflow: ellipsis;
		      margin-top: 2px;
		    }
		    .library-search-popover .pop-item.selected .pop-metaline { color: rgba(255,255,255,0.8); }
		    .library-search-popover mark {
		      background: color-mix(in srgb, var(--primary) 20%, transparent);
		      color: var(--primary);
		      font-weight: 600;
		      padding: 0 2px;
		      border-radius: 3px;
		    }
		    .library-search-popover .pop-item.selected mark { background: rgba(255,255,255,0.2); color: white; }
		    .library-search-popover .pop-badge {
		      font-size: 0.7rem;
		      font-weight: 500;
		      padding: 3px 8px;
		      border-radius: 6px;
		      background: color-mix(in srgb, var(--text) 6%, transparent);
		      color: var(--text-secondary);
		      flex-shrink: 0;
		    }
		    .library-search-popover .pop-item.selected .pop-badge { background: rgba(255,255,255,0.15); color: white; }

		    /* Filter chips */
		    .library-search-popover .pop-filters {
		      display: flex;
		      align-items: center;
		      gap: 6px;
		      padding: 10px 16px;
		      border-bottom: 1px solid var(--hairline);
		      flex-wrap: wrap;
		    }
		    .library-search-popover .filter-chip {
		      padding: 4px 10px;
		      font-size: 0.72rem;
		      font-weight: 500;
		      border-radius: 6px;
		      border: 1px solid var(--hairline);
		      background: transparent;
		      color: var(--text-secondary);
		      cursor: pointer;
		      transition: all 0.12s ease;
		    }
		    .library-search-popover .filter-chip:hover {
		      border-color: var(--primary);
		      color: var(--primary);
		    }
		    .library-search-popover .filter-chip.active {
		      background: var(--primary);
		      border-color: var(--primary);
		      color: white;
		    }
		    .library-search-popover .filter-sep {
		      width: 1px;
		      height: 16px;
		      background: var(--hairline);
		      margin: 0 4px;
		    }

		    /* Recent search items */
		    .library-search-popover .pop-recent-search {
		      display: flex;
		      align-items: center;
		      gap: 10px;
		      width: 100%;
		      padding: 8px 12px;
		      border: none;
		      background: transparent;
		      color: var(--text-secondary);
		      font-size: 0.85rem;
		      cursor: pointer;
		      border-radius: 8px;
		      transition: background 0.1s;
		    }
		    .library-search-popover .pop-recent-search:hover {
		      background: color-mix(in srgb, var(--text) 5%, transparent);
		      color: var(--text);
		    }
		    .library-search-popover .pop-recent-search svg { opacity: 0.5; flex-shrink: 0; }

		    /* Format badge in results */
		    .library-search-popover .pop-format {
		      font-size: 0.65rem;
		      font-weight: 600;
		      padding: 1px 5px;
		      border-radius: 4px;
		      background: color-mix(in srgb, var(--text) 8%, transparent);
		      color: var(--text-secondary);
		      margin-left: 6px;
		      vertical-align: middle;
		    }
		    .library-search-popover .pop-item.selected .pop-format { background: rgba(255,255,255,0.15); color: white; }

		    /* Footer hints */
		    .library-search-popover .pop-hint {
		      padding: 10px 16px;
		      border-top: 1px solid var(--hairline);
		      display: flex;
		      align-items: center;
		      gap: 16px;
		      font-size: 0.75rem;
		      color: var(--text-secondary);
		      background: color-mix(in srgb, var(--bg) 50%, var(--bg-card) 50%);
		    }
		    .library-search-popover .pop-hint span { display: flex; align-items: center; gap: 5px; }
		    .library-search-popover .pop-hint kbd {
		      font-size: 0.65rem;
		      font-weight: 600;
		      padding: 2px 5px;
		      background: var(--bg-card);
		      border: 1px solid var(--hairline);
		      border-radius: 4px;
		      color: var(--text);
		      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
		    }

		    /* Legacy search-box for reader */
		    .search-box { display: flex; align-items: center; background: color-mix(in srgb, var(--bg-card) 82%, var(--bg) 18%); border: 1px solid var(--hairline); border-radius: 999px; padding: 9px 14px; width: min(360px, 34vw); transition: transform 140ms var(--ease-out), box-shadow 140ms var(--ease-out), border-color 140ms var(--ease-out), background 140ms var(--ease-out); }
	    .search-box:focus-within { border-color: color-mix(in srgb, var(--primary) 35%, var(--hairline) 65%); box-shadow: var(--ring); transform: translateY(-1px); }
	    .search-box input { border: none; background: transparent; outline: none; width: 100%; font-size: 0.9rem; }
	    .search-box svg { width: 16px; height: 16px; color: var(--text-secondary); margin-right: 8px; flex-shrink: 0; }
	    header button { padding: 9px 14px; border: 1px solid var(--hairline); border-radius: 999px; background: var(--glass); color: var(--text); cursor: pointer; font-size: 0.875rem; font-weight: 680; transition: transform 160ms var(--ease-out), box-shadow 160ms var(--ease-out), background 160ms var(--ease-out), border-color 160ms var(--ease-out), color 160ms var(--ease-out); }
	    header button:hover { background: color-mix(in srgb, var(--bg-card) 86%, transparent); transform: translateY(-1px); box-shadow: var(--shadow); }
	    header button:active { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.10); }
	    header button.primary { background: var(--primary); color: white; }
	    header button.primary:hover { background: var(--primary-dark); }
	    header .icon-btn { width: 40px; height: 40px; padding: 0; border: 1px solid var(--hairline); background: var(--glass); display: inline-flex; align-items: center; justify-content: center; }
	    header .icon-btn:hover { background: color-mix(in srgb, var(--bg-card) 86%, transparent); }
	    header .icon-btn:active { transform: translateY(0); }
	    header .icon-btn svg { width: 18px; height: 18px; }

    /* Content */
    .content { flex: 1; overflow: hidden; padding: 0; min-height: 0; display: flex; }
    .empty { text-align: center; padding: 80px 40px; color: var(--text-secondary); }
    .empty-illustration { margin-bottom: 24px; animation: floatBooks 4s ease-in-out infinite; }
    @keyframes floatBooks { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px); } }
    .empty h2 { font-size: 1.5rem; color: var(--text); margin-bottom: 12px; font-weight: 600; }
    .empty p { margin-bottom: 24px; line-height: 1.6; }
    .empty button { padding: 12px 24px; }

		    /* Library sidebar */
		    .library-layout { display: flex; flex: 1; gap: 0; min-height: 0; height: 100%; }
		    .library-sidebar { width: 280px; background: var(--glass); border-right: 1px solid var(--hairline); display: flex; flex-direction: column; flex-shrink: 0; min-height: 0; backdrop-filter: blur(18px) saturate(140%); }
		    #library-view.sidebar-collapsed .library-sidebar { display: none; }
		    #library-view.sidebar-collapsed .books-area { padding-left: 32px; padding-right: 32px; }
    .library-sidebar-header { padding: 16px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .library-sidebar-header h3 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-secondary); font-weight: 600; }
    .library-sidebar-header button { width: 28px; height: 28px; border-radius: 6px; display: flex; align-items: center; justify-content: center; padding: 0; }
    .sidebar-header-actions { display: flex; gap: 8px; }
	    .sidebar-tabs { display: flex; gap: 6px; padding: 10px 12px; border-bottom: 1px solid var(--hairline); }
	    .sidebar-tabs button { flex: 1; border: 1px solid var(--hairline); background: color-mix(in srgb, var(--bg-card) 70%, transparent); padding: 8px 10px; border-radius: 999px; cursor: pointer; font-size: 0.84rem; color: var(--text-secondary); font-weight: 720; transition: transform 140ms var(--ease-out), background 140ms var(--ease-out), border-color 140ms var(--ease-out), color 140ms var(--ease-out); }
	    .sidebar-tabs button:hover { background: var(--bg-hover); }
	    .sidebar-tabs button.active { background: color-mix(in srgb, var(--primary-light) 92%, transparent); border-color: color-mix(in srgb, var(--primary) 25%, var(--hairline) 75%); color: var(--primary-dark); }
    .library-list { flex: 1; overflow-y: auto; padding: 8px; }
	    .library-item { display: flex; align-items: center; padding: 10px 12px; border-radius: 14px; cursor: pointer; margin-bottom: 4px; transition: transform 140ms var(--ease-out), background 140ms var(--ease-out); }
	    .library-item:hover { background: color-mix(in srgb, var(--bg-card) 82%, transparent); transform: translateY(-1px); }
	    .library-item.active { background: color-mix(in srgb, var(--primary-light) 80%, transparent); color: var(--primary-dark); }
    .library-item svg { width: 18px; height: 18px; margin-right: 10px; opacity: 0.7; }
    .library-item span { flex: 1; font-size: 0.9rem; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .library-item .lib-actions { display: none; gap: 4px; }
    .library-item:hover .lib-actions { display: flex; }
    .library-item .lib-actions button { width: 24px; height: 24px; padding: 0; border-radius: 4px; background: transparent; color: var(--text-secondary); }
    .library-item .lib-actions button:hover { background: var(--bg); color: var(--text); }

    /* Books grid */
		    .books-area { flex: 1; overflow-y: auto; padding: 22px; min-height: 0; height: 100%; }
    .books-split { display: flex; gap: 16px; align-items: stretch; }
    .folder-sidebar { width: 280px; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; flex-shrink: 0; display: flex; flex-direction: column; box-shadow: var(--shadow); }
    .folder-sidebar.hidden { display: none; }
    .folder-header { padding: 14px 14px; border-bottom: 1px solid var(--border); display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .folder-header .title { font-size: 0.85rem; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .folder-header .actions { display: flex; gap: 6px; }
    .folder-header button { width: 28px; height: 28px; padding: 0; border-radius: 8px; border: 1px solid var(--border); background: var(--bg); cursor: pointer; }
    .folder-header button:hover { background: var(--bg-hover); }
    .folder-tree { padding: 6px; overflow-y: auto; flex: 1; }
    .folder-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: var(--transition); user-select: none; }
    .folder-item:hover { background: var(--bg-hover); }
    .folder-item.active { background: var(--primary-light); color: var(--primary-dark); }
    .folder-item .caret { width: 16px; text-align: center; opacity: 0.75; }
    .folder-item .name { flex: 1; font-size: 0.92rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .folder-item.drop { outline: 2px solid var(--primary); outline-offset: 2px; background: var(--primary-light); }
		    .books-main { flex: 1; min-width: 0; width: 100%; max-width: var(--library-max-width); margin: 0 auto; display: flex; flex-direction: column; align-items: stretch; padding-bottom: 52px; }
		    .books-main > * { width: 100%; }
	    .books-header { position: relative; display: flex; align-items: center; justify-content: space-between; margin-bottom: 18px; padding: 12px 0; }
    .books-header h2 { font-size: 1.4rem; font-weight: 600; }
    .books-count { color: var(--text-secondary); font-size: 0.9rem; }
    .books-controls { display: flex; align-items: center; gap: 10px; }
	    .books-controls select, .books-controls button { border: 1px solid var(--hairline); background: var(--glass); border-radius: 999px; padding: 8px 12px; font-size: 0.9rem; cursor: pointer; font-weight: 700; transition: transform 140ms var(--ease-out), box-shadow 140ms var(--ease-out), background 140ms var(--ease-out); }
	    .books-controls select:hover, .books-controls button:hover { transform: translateY(-1px); box-shadow: var(--shadow); }
	    .books-controls select:active, .books-controls button:active { transform: translateY(0); box-shadow: 0 6px 18px rgba(0,0,0,0.10); }
    .books-controls button { width: 38px; height: 38px; display: inline-flex; align-items: center; justify-content: center; }
    .books-controls button:hover { background: var(--bg-hover); }
	    .books-grid { display: grid; grid-template-columns: repeat(auto-fill, var(--main-hall-tile-size)); gap: 14px; align-items: start; justify-content: start; }
	    .book-card { background: var(--surface); border-radius: 16px; padding: 12px; cursor: pointer; border: 1px solid var(--hairline); position: relative; display: flex; flex-direction: column; box-shadow: var(--shadow); transition: transform 180ms var(--ease-out), box-shadow 180ms var(--ease-out), border-color 180ms var(--ease-out); min-height: 348px; }
	    .book-card:hover { transform: translateY(-5px) scale(1.01); box-shadow: 0 20px 50px rgba(212, 67, 106, 0.12), var(--shadow-lg); border-color: color-mix(in srgb, var(--primary) 25%, var(--hairline) 75%); }
    .book-icon { position: relative; overflow: hidden; }
	    .book-icon .book-cover { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; display: block; opacity: 0; transition: opacity 0.18s ease, transform 0.3s var(--ease-out); }
	    .has-cover .book-cover { opacity: 1; }
	    .book-card:hover .book-cover { transform: scale(1.03); }
	    .has-cover .book-icon svg { display: none; }

	    .book-card .book-icon { width: 100%; aspect-ratio: 3 / 4; background: linear-gradient(145deg, color-mix(in srgb, var(--primary-light) 60%, #fff 40%) 0%, color-mix(in srgb, var(--primary-light) 20%, #fff 80%) 100%); border-radius: 14px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; border: 1px solid var(--hairline); box-shadow: inset 0 1px 0 rgba(255,255,255,0.65), inset 0 -2px 8px rgba(212, 67, 106, 0.06); overflow: hidden; }
    .book-card .book-icon svg { width: 24px; height: 24px; color: var(--primary); }
	    .book-card .book-title { font-weight: 600; font-size: 0.93rem; margin-bottom: 4px; line-height: 1.25; height: calc(1.25em * 3); display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden; }
	    .book-card .book-author { color: var(--text-secondary); font-size: 0.82rem; line-height: 1.25; white-space: normal; overflow: visible; text-overflow: clip; word-break: break-word; }
	    .book-card .book-progress { margin-top: 8px; height: 4px; background: color-mix(in srgb, var(--border) 70%, transparent); border-radius: 999px; overflow: hidden; }
	    .book-card .book-progress-bar { height: 100%; background: linear-gradient(90deg, var(--primary), color-mix(in srgb, var(--primary) 70%, #ffb3c7 30%)); border-radius: 999px; transition: width 0.3s var(--ease-out); }
	    .book-card .book-footer { margin-top: 8px; display:flex; flex-direction:column; justify-content:flex-end; gap: 3px; min-height: 48px; }
	    .book-card .book-progress-row { display:flex; align-items:center; justify-content: space-between; gap: 6px; margin-top: 0; }
	    .book-card .book-progress-row .book-progress { margin-top: 0; flex: 1; }
	    .book-card .book-progress-pct { font-size: 0.72rem; color: var(--text-secondary); font-weight: 720; min-width: 30px; text-align: right; font-variant-numeric: tabular-nums; }
	    .book-card .book-progress-meta { font-size: 0.68rem; color: var(--text-secondary); line-height: 1.2; white-space: normal; word-break: break-word; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; min-height: calc(1.2em * 2); }
	    .recent-book .book-progress-meta { font-size: 0.68rem; color: var(--text-secondary); line-height: 1.2; white-space: normal; word-break: break-word; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; min-height: calc(1.2em * 2); }
	    .book-card .pin-badge { position: absolute; top: 12px; left: 12px; padding: 6px 10px; border-radius: 999px; background: var(--glass-strong); border: 1px solid var(--hairline); color: color-mix(in srgb, var(--text) 80%, transparent); font-size: 0.78rem; font-weight: 760; backdrop-filter: blur(14px) saturate(160%); }
	    .book-card .menu-btn { position: absolute; top: 12px; right: 12px; width: 36px; height: 36px; border: 1px solid var(--hairline); border-radius: 999px; background: var(--glass-strong); color: color-mix(in srgb, var(--text) 62%, transparent); font-size: 18px; cursor: pointer; opacity: 0; transform: translateY(2px); transition: transform 160ms var(--ease-out), opacity 160ms var(--ease-out), background 160ms var(--ease-out), box-shadow 160ms var(--ease-out); backdrop-filter: blur(14px) saturate(160%); box-shadow: 0 10px 28px rgba(0,0,0,0.12); }
	    .book-card:hover .menu-btn { opacity: 1; transform: translateY(0); }
	    .book-card .menu-btn:hover { background: color-mix(in srgb, var(--bg-card) 92%, transparent); }
	    body[data-card-density="dense"] .book-card { min-height: 320px; }
	    body[data-card-density="dense"] .book-card .book-title { height: calc(1.25em * 2); -webkit-line-clamp: 2; }
	    body[data-card-density="dense"] .book-card .book-footer { min-height: 36px; gap: 2px; }

    /* Folder tree (legacy support) */
    .library-node { margin-bottom: 4px; }
    .folder-name { font-weight: 500; padding: 10px 14px; background: var(--bg-card); border-radius: var(--radius-sm); cursor: pointer; display: flex; align-items: center; gap: 10px; border: 1px solid var(--border); transition: var(--transition); }
    .folder-name:hover { background: var(--bg-hover); }
    .folder-name::before { content: '▶'; font-size: 10px; transition: transform 0.2s; color: var(--text-secondary); }
    .folder-name.open::before { transform: rotate(90deg); }
    .folder-children { display: none; margin-left: 20px; margin-top: 4px; }
    .folder-children.open { display: block; }
    .book-item { display: flex; align-items: center; padding: 12px 16px; margin: 4px 0; background: var(--bg-card); border-radius: var(--radius-sm); cursor: pointer; border: 1px solid var(--border); transition: var(--transition); }
    .book-item:hover { background: var(--primary-light); border-color: var(--primary-light); }
    .book-item .book-title { flex: 1; font-weight: 500; }
    .book-item .book-author { color: var(--text-secondary); font-size: 0.9em; margin-right: 12px; }
    .book-item .delete-btn { width: 28px; height: 28px; border: none; border-radius: 50%; background: transparent; color: var(--text-secondary); font-size: 18px; cursor: pointer; }
    .book-item .delete-btn:hover { background: #fee2e2; color: #dc2626; }

		    /* Reader */
		    .reader-wrapper { display: flex; flex: 1; overflow: hidden; }
		    #reader-view.reader-topbar-hidden > header { display: none !important; }
		    #reader-view.reader-topbar-hidden .reader-wrapper { height: 100vh; }
		    .floating-topbar-toggle {
		      position: fixed;
		      top: 14px;
		      left: 14px;
		      z-index: 260;
		      width: 40px;
		      height: 40px;
		      border-radius: 999px;
		      border: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
		      background: color-mix(in srgb, var(--bg-card) 78%, transparent);
		      box-shadow: var(--shadow);
		      backdrop-filter: blur(14px);
		      display: none;
		      align-items: center;
		      justify-content: center;
		      cursor: pointer;
		      transition: var(--transition);
		      color: var(--text);
		    }
		    .floating-topbar-toggle:hover { background: var(--bg-hover); }
		    #reader-view.reader-topbar-hidden .floating-topbar-toggle { display: inline-flex; }
			    #reader-view.fit-reader-width .reader-content { padding-left: clamp(24px, 8vw, 120px); padding-right: clamp(24px, 8vw, 120px); }
		    #reader-view.fit-reader-width .reader-scroll-body { max-width: 100% !important; margin: 0 !important; }
        .reader-wrapper { position: relative; display: flex; height: 100%; }
		    .toc-sidebar { position: absolute; left: 0; top: 0; bottom: 0; z-index: 50; width: var(--toc-width, 300px); min-width: 240px; max-width: 520px; background: var(--glass-strong); border-right: 1px solid var(--hairline); overflow-y: auto; backdrop-filter: blur(18px) saturate(160%); transform: translateX(0); opacity: 1; transition: transform 0.28s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.28s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 4px 0 24px rgba(0,0,0,0.12); }
		    .toc-sidebar.hidden { display: none; }
			    .toc-sidebar h3 { padding: 16px 18px; border-bottom: 1px solid var(--hairline); font-size: 0.8rem; font-weight: 780; letter-spacing: 0.12em; text-transform: uppercase; color: color-mix(in srgb, var(--text-secondary) 85%, var(--text) 15%); }
			    .toc-item { position: relative; padding: 12px 18px; cursor: pointer; border-bottom: 1px solid color-mix(in srgb, var(--hairline) 70%, transparent); font-size: 0.92em; transition: transform 140ms var(--ease-out), background 140ms var(--ease-out); display: flex; align-items: center; gap: 6px; }
			    .toc-item.hidden { display: none; }
			    .toc-item:hover { background: color-mix(in srgb, var(--primary-light) 65%, transparent); transform: translateX(2px); }
			    .toc-item.active { background: color-mix(in srgb, var(--primary-light) 80%, transparent); color: color-mix(in srgb, var(--primary) 70%, var(--text) 30%); font-weight: 720; }
			    .toc-item.active::before { content: ''; position: absolute; left: 0; top: 18%; bottom: 18%; width: 4px; border-radius: 0 6px 6px 0; background: var(--primary); box-shadow: 0 6px 18px color-mix(in srgb, var(--primary) 35%, transparent); }
			    .toc-toggle { font-size: 0.7em; width: 16px; text-align: center; color: var(--text-secondary); cursor: pointer; flex-shrink: 0; user-select: none; }
			    .toc-toggle:hover { color: var(--primary); }
			    .toc-toggle-spacer { width: 16px; flex-shrink: 0; }
		    #reader-view header { position: absolute; left: 0; right: 0; top: 0; z-index: 100; background: var(--glass-strong); backdrop-filter: blur(18px) saturate(160%); box-shadow: 0 2px 16px rgba(0,0,0,0.08); }
		    #reader-view header.reader-header { display: grid; grid-template-columns: auto minmax(0, 1fr) auto; align-items: center; gap: 12px; overflow: visible; }
		    .reader-header-left, .reader-header-right { display: flex; align-items: center; gap: 10px; }
		    .reader-header-right { justify-content: flex-end; min-width: 0; overflow: visible; }
		    .reader-header-center { min-width: 0; display: flex; align-items: center; justify-content: center; gap: 12px; }
		    #reader-view .reader-header-center .book-name { text-align: center; flex: 0 1 auto; max-width: min(60vw, 720px); font-weight: 780; }
		    #reader-view.reader-ui-hidden header.reader-header { opacity: 0; pointer-events: none; transform: translateY(-100%); transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1), transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); }
		    #reader-view header.reader-header { transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1), transform 0.25s cubic-bezier(0.4, 0, 0.2, 1); overflow: hidden; }
		    #reader-view.reader-ui-hidden header.reader-header > * { opacity: 0; }
		    #reader-view.reader-ui-hidden .reader-progress-bar { opacity: 0; transform: translateY(-8px); }
        #reader-view.reader-toc-hidden .toc-sidebar { transform: translateX(-100%); opacity: 0; pointer-events: none; }
		    .reader-progress-bar { position: absolute; left: 0; right: 0; bottom: 0; height: 3px; background: color-mix(in srgb, var(--border) 70%, transparent); }
		    .reader-progress-bar .fill { height: 100%; width: 0%; background: var(--primary); transition: width 0.15s ease; }
		    .reader-progress-pill { font-size: 0.82rem; color: var(--text-secondary); padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; background: color-mix(in srgb, var(--bg-card) 75%, transparent); }
		    #reader-view .icon-btn.active { background: color-mix(in srgb, var(--primary-light) 85%, transparent); border-color: color-mix(in srgb, var(--primary) 25%, var(--border) 75%); color: var(--primary-dark); }
		    #reader-view header .reader-progress-pill { background: color-mix(in srgb, var(--bg-card) 86%, transparent); border-color: var(--hairline); color: color-mix(in srgb, var(--text) 82%, transparent); font-weight: 720; }
    .reader-content { flex: 1; overflow-y: auto; width: 100%; padding: 0; line-height: 1.8; min-height: 0; font-feature-settings: "kern" 1, "liga" 1; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; }
    .reader-content { scroll-behavior: auto; }
    .reader-scroll-body { max-width: 100%; margin: 0; padding: var(--reader-margin, 48px); padding-top: 32px; }
		    .reader-content:not(.pdf-mode) .reader-scroll-body { }
    .reader-content img { max-width: 100%; height: auto; }
    .reader-content svg { max-width: 100%; height: auto; }
    .reader-content p { margin-bottom: 1.2em; text-align: justify; hyphens: auto; -webkit-hyphens: auto; }
    .reader-content h1, .reader-content h2, .reader-content h3, .reader-content h4, .reader-content h5, .reader-content h6 { margin-top: 1.5em; margin-bottom: 0.6em; line-height: 1.3; }
    .reader-content a { color: inherit; text-decoration-color: color-mix(in srgb, currentColor 40%, transparent); text-underline-offset: 3px; }
    .book-hero { display: flex; gap: 18px; align-items: flex-end; padding: 26px 0 18px; border-bottom: 1px solid var(--border); margin-bottom: 18px; }
    .book-hero .cover { width: 160px; aspect-ratio: 3/4; border-radius: 14px; border: 1px solid var(--border); background: linear-gradient(135deg, var(--primary-light), #fff); overflow: hidden; box-shadow: var(--shadow); flex-shrink: 0; }
    .book-hero .cover img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .book-hero .meta .title { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.2px; line-height: 1.2; }
    .book-hero .meta .sub { margin-top: 6px; color: var(--text-secondary); }
			    .chapter { margin-bottom: 48px; content-visibility: auto; contain-intrinsic-size: auto 900px; }
		    .chapter img { max-width: 100%; height: auto; border-radius: var(--radius-sm); }
		    .book-name { flex: 1; text-align: left; font-weight: 650; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
		    mark.hl {
		      border-radius: 3px;
		      padding: 1px 2px;
		      margin: 0 -1px;
		      box-decoration-break: clone;
		      -webkit-box-decoration-break: clone;
		      cursor: pointer;
		      transition: all 0.3s ease;
		      position: relative;
		    }
		    mark.hl:hover {
		      filter: brightness(1.1);
		    }
		    mark.hl.highlight-flash {
		      animation: highlightPulse 1.2s ease-out;
		      z-index: 100;
		    }
		    mark.hl.highlight-flash::before {
		      content: '';
		      position: absolute;
		      inset: -6px;
		      border: 3px solid var(--hl-glow, #ffc107);
		      border-radius: 6px;
		      animation: highlightRing 1.2s ease-out;
		      pointer-events: none;
		      box-shadow: 0 0 12px var(--hl-glow, #ffc107), 0 0 24px var(--hl-glow, #ffc107);
		    }
		    /* Color-specific glow variables */
		    mark.hl[data-color="yellow"].highlight-flash, mark.hl:not([data-color]).highlight-flash { --hl-glow: #ffd600; }
		    mark.hl[data-color="green"].highlight-flash { --hl-glow: #00e676; }
		    mark.hl[data-color="blue"].highlight-flash { --hl-glow: #2196f3; }
		    mark.hl[data-color="pink"].highlight-flash { --hl-glow: #ff4081; }
		    mark.hl[data-color="purple"].highlight-flash { --hl-glow: #e040fb; }
		    mark.hl[data-color="orange"].highlight-flash { --hl-glow: #ff9100; }
		    @keyframes highlightPulse {
		      0%, 100% { filter: brightness(1); }
		      15%, 45% { filter: brightness(1.6) drop-shadow(0 0 10px var(--hl-glow, #ffc107)); }
		      30% { filter: brightness(1.3); }
		    }
		    @keyframes highlightRing {
		      0% { opacity: 0; transform: scale(0.9); }
		      20% { opacity: 1; transform: scale(1); }
		      60% { opacity: 0.7; transform: scale(1.08); }
		      100% { opacity: 0; transform: scale(1.15); }
		    }
		    /* Highlight locator arrow */
		    .highlight-locator {
		      position: fixed;
		      left: 50%;
		      transform: translateX(-50%);
		      z-index: 9999;
		      pointer-events: none;
		      animation: locatorBounce 1.2s ease-out forwards;
		    }
		    .highlight-locator::after {
		      content: '▼';
		      font-size: 28px;
		      color: var(--hl-arrow, #ffc107);
		      text-shadow: 0 0 8px var(--hl-arrow, #ffc107), 0 0 16px var(--hl-arrow, #ffc107), 0 2px 4px rgba(0,0,0,0.6);
		      animation: locatorPulse 0.3s ease-in-out infinite alternate;
		    }
		    @keyframes locatorBounce {
		      0% { opacity: 0; }
		      15% { opacity: 1; }
		      75% { opacity: 1; }
		      100% { opacity: 0; }
		    }
		    @keyframes locatorPulse {
		      0% { transform: scale(1); }
		      100% { transform: scale(1.15); }
		    }
		    /* Highlight colors */
		    mark.hl[data-color="yellow"], mark.hl:not([data-color]) {
		      background: rgba(255, 235, 59, 0.45);
		      border-bottom: 2px solid rgba(255, 193, 7, 0.7);
		    }
		    mark.hl[data-color="green"] {
		      background: rgba(76, 175, 80, 0.35);
		      border-bottom: 2px solid rgba(56, 142, 60, 0.7);
		    }
		    mark.hl[data-color="blue"] {
		      background: rgba(33, 150, 243, 0.35);
		      border-bottom: 2px solid rgba(25, 118, 210, 0.7);
		    }
		    mark.hl[data-color="pink"] {
		      background: rgba(233, 30, 99, 0.3);
		      border-bottom: 2px solid rgba(194, 24, 91, 0.7);
		    }
		    mark.hl[data-color="purple"] {
		      background: rgba(156, 39, 176, 0.3);
		      border-bottom: 2px solid rgba(123, 31, 162, 0.7);
		    }
		    mark.hl[data-color="orange"] {
		      background: rgba(255, 152, 0, 0.4);
		      border-bottom: 2px solid rgba(245, 124, 0, 0.7);
		    }
		    /* Nested highlights - stronger colors and visual distinction */
		    mark.hl mark.hl {
		      padding: 1px 2px;
		      border-radius: 3px;
		      box-shadow: 0 0 0 1px rgba(0,0,0,0.15);
		    }
		    mark.hl mark.hl[data-color="yellow"], mark.hl mark.hl:not([data-color]) {
		      background: rgba(255, 235, 59, 0.7);
		      border-bottom: 2px solid rgba(255, 193, 7, 0.9);
		    }
		    mark.hl mark.hl[data-color="green"] {
		      background: rgba(76, 175, 80, 0.6);
		      border-bottom: 2px solid rgba(56, 142, 60, 0.9);
		    }
		    mark.hl mark.hl[data-color="blue"] {
		      background: rgba(33, 150, 243, 0.6);
		      border-bottom: 2px solid rgba(25, 118, 210, 0.9);
		    }
		    mark.hl mark.hl[data-color="pink"] {
		      background: rgba(233, 30, 99, 0.55);
		      border-bottom: 2px solid rgba(194, 24, 91, 0.9);
		    }
		    mark.hl mark.hl[data-color="purple"] {
		      background: rgba(156, 39, 176, 0.55);
		      border-bottom: 2px solid rgba(123, 31, 162, 0.9);
		    }
		    mark.hl mark.hl[data-color="orange"] {
		      background: rgba(255, 152, 0, 0.65);
		      border-bottom: 2px solid rgba(245, 124, 0, 0.9);
		    }
		    .note-anchor {
		      background: color-mix(in srgb, var(--primary) 12%, transparent);
		      border-bottom: 2px dotted color-mix(in srgb, var(--primary) 55%, transparent);
		      border-radius: 6px;
		      padding: 0 2px;
		      cursor: pointer;
		      box-decoration-break: clone;
		      -webkit-box-decoration-break: clone;
		    }
		    .note-anchor:hover { background: color-mix(in srgb, var(--primary) 18%, transparent); }

		    /* In-book search - Modern floating search */
		    .reader-search {
		      display: flex;
		      align-items: center;
		      gap: 6px;
		      position: relative;
		      flex: 0 1 auto;
		      z-index: 200;
		    }
		    .reader-search .search-box {
		      position: relative;
		      min-width: 200px;
		      width: auto;
		      height: 36px;
		      display: flex;
		      align-items: center;
		      gap: 8px;
		      padding: 0 12px;
		      border-radius: 8px;
		      border: 1px solid var(--hairline);
		      background: color-mix(in srgb, var(--bg) 60%, var(--bg-card) 40%);
		      transition: all 0.15s ease;
		    }
		    .reader-search .search-box:focus-within {
		      border-color: var(--primary);
		      background: var(--bg-card);
		      box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 12%, transparent);
		    }
		    .reader-search .search-box svg { width: 15px; height: 15px; flex-shrink: 0; color: var(--text-secondary); }
		    .reader-search .search-box:focus-within svg { color: var(--primary); }

		    .reader-search .search-box input {
		      min-width: 0;
		      width: 140px;
		      border: none;
		      background: transparent;
		      outline: none;
		      font-size: 0.875rem;
		      color: var(--text);
		      height: 100%;
		      transition: width 0.15s ease;
		    }
		    .reader-search .search-box:focus-within input { width: 200px; }
		    .reader-search .search-box input::placeholder { color: var(--text-secondary); opacity: 0.6; }

		    .reader-search .search-kbd-hint {
		      font-size: 0.65rem;
		      font-weight: 500;
		      padding: 2px 5px;
		      border-radius: 4px;
		      border: 1px solid color-mix(in srgb, var(--text) 8%, transparent);
		      background: color-mix(in srgb, var(--text) 4%, transparent);
		      color: var(--text-secondary);
		      opacity: 0.7;
		    }
		    .reader-search.has-query .search-kbd-hint { display: none; }

		    .reader-search .search-nav { display: flex; align-items: center; gap: 2px; flex-shrink: 0; }
		    .reader-search .search-nav .search-count {
		      font-size: 0.7rem;
		      font-weight: 600;
		      padding: 3px 8px;
		      border-radius: 4px;
		      background: color-mix(in srgb, var(--primary) 10%, transparent);
		      color: var(--primary);
		      font-variant-numeric: tabular-nums;
		      margin-right: 2px;
		    }
		    .reader-search .search-nav .search-ctrl {
		      width: 26px;
		      height: 26px;
		      border-radius: 6px;
		      border: none;
		      background: transparent;
		      color: var(--text-secondary);
		      display: inline-flex;
		      align-items: center;
		      justify-content: center;
		      cursor: pointer;
		      transition: all 0.1s;
		    }
		    .reader-search .search-nav .search-ctrl svg { width: 14px; height: 14px; }
		    .reader-search .search-nav .search-ctrl:hover {
		      background: color-mix(in srgb, var(--text) 8%, transparent);
		      color: var(--text);
		    }
			    .reader-search .search-nav .search-ctrl:active { transform: scale(0.92); }
			    .reader-search .search-nav .search-close { color: var(--text-secondary); }
			    .reader-search .search-nav .search-close:hover { background: color-mix(in srgb, #dc2626 12%, transparent); color: #dc2626; }
			    .reader-search .search-filter {
			      display: inline-flex;
			      align-items: center;
			      gap: 6px;
			      padding: 6px 10px;
			      border-radius: 20px;
			      border: 1px solid var(--hairline);
			      background: color-mix(in srgb, var(--bg-card) 70%, transparent);
			      color: var(--text-secondary);
			      font-size: 0.76rem;
			      font-weight: 650;
			      cursor: pointer;
			      transition: all 0.15s ease;
			    }
			    .reader-search .search-filter:hover { color: var(--text); border-color: color-mix(in srgb, var(--primary) 30%, var(--hairline)); }
			    .reader-search .search-filter.active {
			      background: color-mix(in srgb, var(--primary) 18%, transparent);
			      color: var(--primary-dark);
			      border-color: color-mix(in srgb, var(--primary) 40%, var(--hairline));
			      box-shadow: 0 6px 18px color-mix(in srgb, var(--primary) 18%, transparent);
			    }

		    /* Search Results Dropdown - Modern Aesthetic Design */
		    .search-results-panel {
		      position: fixed;
		      top: 70px;
		      right: 60px;
		      width: 320px;
		      max-height: min(380px, 50vh);
		      background: var(--bg-card);
		      border: 1px solid var(--border);
		      border-radius: 14px;
		      box-shadow: 0 8px 32px rgba(0,0,0,0.12), 0 2px 8px rgba(0,0,0,0.08);
		      overflow: hidden;
		      z-index: 1000;
		      display: flex;
		      flex-direction: column;
		    }
		    .search-results-panel.hidden { display: none; }
		    :root[data-app-theme="dark"] .search-results-panel,
		    :root[data-app-theme="silk"] .search-results-panel {
		      background: #1c1c22;
		      border-color: rgba(255,255,255,0.08);
		      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
		    }

		    .search-results-header {
		      padding: 12px 16px;
		      border-bottom: 1px solid var(--border);
		      display: flex;
		      align-items: center;
		      justify-content: space-between;
		      flex-shrink: 0;
		      background: linear-gradient(to bottom, var(--bg-card), color-mix(in srgb, var(--bg) 30%, var(--bg-card) 70%));
		    }
		    :root[data-app-theme="dark"] .search-results-header,
		    :root[data-app-theme="silk"] .search-results-header {
		      background: linear-gradient(to bottom, #1c1c22, #18181c);
		      border-color: rgba(255,255,255,0.06);
		    }
		    .search-results-header span:first-child {
		      font-size: 0.8rem;
		      font-weight: 600;
		      color: var(--text);
		    }
		    .search-results-header .search-meta {
		      font-size: 0.7rem;
		      color: var(--text-secondary);
		      opacity: 0.7;
		    }

		    .search-results-body {
		      flex: 1;
		      overflow-y: auto;
		      padding: 8px;
		    }

		    .search-result-item {
		      padding: 12px 14px;
		      border-radius: 10px;
		      cursor: pointer;
		      transition: all 0.12s ease;
		      width: 100%;
		      text-align: left;
		      background: transparent;
		      border: none;
		      color: inherit;
		      display: flex;
		      flex-direction: column;
		      gap: 6px;
		      margin-bottom: 4px;
		    }
		    .search-result-item:last-child { margin-bottom: 0; }
		    .search-result-item:hover {
		      background: color-mix(in srgb, var(--primary) 8%, transparent);
		    }
		    .search-result-item.active-item {
		      background: var(--primary);
		      color: white;
		      transform: scale(1.01);
		    }

		    .search-result-item .result-chapter {
		      font-size: 0.68rem;
		      text-transform: uppercase;
		      letter-spacing: 0.04em;
		      color: var(--primary);
		      font-weight: 700;
		      opacity: 0.9;
		    }
		    .search-result-item.active-item .result-chapter {
		      color: rgba(255,255,255,0.8);
		    }

		    .search-result-item .result-text {
		      font-size: 0.88rem;
		      line-height: 1.5;
		      color: var(--text);
		      display: -webkit-box;
		      -webkit-line-clamp: 2;
		      -webkit-box-orient: vertical;
		      overflow: hidden;
		    }
		    .search-result-item.active-item .result-text { color: white; }

		    .search-result-item .result-text mark {
		      background: color-mix(in srgb, var(--primary) 25%, transparent);
		      color: var(--primary);
		      font-weight: 600;
		      padding: 1px 3px;
		      border-radius: 3px;
		    }
		    .search-result-item.active-item .result-text mark {
		      background: rgba(255,255,255,0.25);
		      color: white;
		    }

		    /* Codemap - Fixed right side of reader */
		    .search-codemap {
		      position: fixed;
		      top: 70px;
		      right: 12px;
		      bottom: 20px;
		      width: 32px;
		      z-index: 500;
		      display: none;
		      flex-direction: column;
		      align-items: center;
		      padding: 8px 0;
		    }
		    .search-codemap.visible { display: flex; }
		    .codemap-track {
		      flex: 1;
		      width: 100%;
		      position: relative;
		      background: color-mix(in srgb, var(--border) 30%, transparent);
		      border-radius: 4px;
		    }
		    .codemap-marker {
		      position: absolute;
		      left: 50%;
		      transform: translateX(-50%);
		      width: 10px;
		      height: 10px;
		      border-radius: 50%;
		      background: var(--primary);
		      opacity: 0.5;
		      border: 2px solid transparent;
		      padding: 0;
		      cursor: pointer;
		      transition: all 0.15s ease;
		    }
		    .codemap-marker:hover {
		      opacity: 0.8;
		      transform: translateX(-50%) scale(1.3);
		    }
		    .codemap-marker.current {
		      opacity: 1;
		      background: var(--primary);
		      border-color: white;
		      transform: translateX(-50%) scale(1.5);
		      box-shadow: 0 0 8px var(--primary);
		    }
		    .codemap-location {
		      font-size: 0.65rem;
		      font-weight: 600;
		      color: var(--text-secondary);
		      text-align: center;
		      padding: 6px 0;
		      white-space: nowrap;
		    }

			    /* In-book Search Highlights */
			    .search-highlight {
			      position: relative;
			      color: inherit;
			      padding: 1px 4px;
			      border-radius: 6px;
			      background: linear-gradient(130deg, color-mix(in srgb, var(--primary) 28%, transparent), color-mix(in srgb, var(--primary-light) 22%, transparent));
			      box-shadow: 0 4px 12px color-mix(in srgb, var(--primary) 18%, transparent);
			      border-bottom: 2px solid color-mix(in srgb, var(--primary) 50%, transparent);
			      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
			    }
			    .search-highlight.current {
			      z-index: 10;
			      background: color-mix(in srgb, var(--primary) 70%, transparent);
			      color: #0a0a0a;
			      border-bottom-color: color-mix(in srgb, var(--primary-dark) 85%, #0a0a0a 15%);
			      box-shadow: 0 6px 20px color-mix(in srgb, var(--primary) 35%, transparent), 0 0 0 1px color-mix(in srgb, #000 12%, transparent);
			      animation: search-pulse 1.3s ease-out;
			    }
			    /* Search highlights inside user highlights - use user's color */
			    .search-highlight[data-hl-color="yellow"] { background: linear-gradient(120deg, rgba(255, 235, 59, 0.65), rgba(255, 249, 196, 0.8)); border-bottom-color: #f3c200; }
			    .search-highlight[data-hl-color="yellow"].current { background: #ffd400; }
			    .search-highlight[data-hl-color="green"] { background: linear-gradient(120deg, rgba(0, 230, 118, 0.55), rgba(200, 255, 224, 0.8)); border-bottom-color: #1fa96b; }
			    .search-highlight[data-hl-color="green"].current { background: #1fa96b; }
			    .search-highlight[data-hl-color="blue"] { background: linear-gradient(120deg, rgba(33, 150, 243, 0.55), rgba(210, 235, 255, 0.8)); border-bottom-color: #1c74c6; }
			    .search-highlight[data-hl-color="blue"].current { background: #1c74c6; }
			    .search-highlight[data-hl-color="pink"] { background: linear-gradient(120deg, rgba(233, 30, 99, 0.45), rgba(255, 223, 235, 0.8)); border-bottom-color: #c2185b; }
			    .search-highlight[data-hl-color="pink"].current { background: #c2185b; }
			    .search-highlight[data-hl-color="purple"] { background: linear-gradient(120deg, rgba(156, 39, 176, 0.45), rgba(234, 214, 252, 0.8)); border-bottom-color: #7b1fa2; }
			    .search-highlight[data-hl-color="purple"].current { background: #7b1fa2; }
			    .search-highlight[data-hl-color="orange"] { background: linear-gradient(120deg, rgba(255, 152, 0, 0.5), rgba(255, 236, 204, 0.85)); border-bottom-color: #f57c00; }
			    .search-highlight[data-hl-color="orange"].current { background: #f57c00; }
			    @keyframes search-pulse {
			      0% { transform: translateY(0) scale(1); box-shadow: 0 12px 30px color-mix(in srgb, var(--primary) 40%, transparent), 0 0 0 0 color-mix(in srgb, var(--primary) 55%, transparent); }
			      55% { transform: translateY(-1px) scale(1.02); box-shadow: 0 18px 40px color-mix(in srgb, var(--primary) 38%, transparent), 0 0 0 10px color-mix(in srgb, var(--primary) 10%, transparent); }
			      100% { transform: translateY(0) scale(1); box-shadow: 0 6px 14px color-mix(in srgb, var(--primary) 18%, transparent), 0 0 0 0 color-mix(in srgb, var(--primary) 0%, transparent); }
			    }


    .search-nav { display: flex; align-items: center; gap: 4px; }
    .search-nav button { width: 28px; height: 28px; padding: 0; display: flex; align-items: center; justify-content: center; }
    .search-nav span { font-size: 0.8rem; color: var(--text-secondary); min-width: 60px; text-align: center; }

    /* Modals */
	    .modal { position: fixed; inset: 0; background: rgba(0,0,0,0.42); display: flex; align-items: center; justify-content: center; z-index: 100; backdrop-filter: blur(10px) saturate(140%); }
	    .modal-content { background: var(--glass-strong); padding: 28px; border-radius: 22px; width: 440px; max-width: 92vw; max-height: 90vh; overflow-y: auto; box-shadow: var(--shadow-lg); border: 1px solid var(--hairline); }
	    .modal-content h2 { margin-bottom: 24px; font-size: 1.25rem; font-weight: 600; }
	    .modal-content h3 { margin-bottom: 16px; font-size: 1.1rem; font-weight: 600; }
	    .modal-content p { color: color-mix(in srgb, var(--text) 78%, transparent); line-height: 1.55; }
	    .modal-content label { color: var(--text-secondary); }
	    .modal-content input, .modal-content select {
	      width: 100%;
	      padding: 10px 12px;
	      border: 1px solid var(--border);
	      border-radius: var(--radius-sm);
	      background: color-mix(in srgb, var(--bg-card) 72%, var(--bg) 28%);
	      color: var(--text);
	      font-size: 0.9rem;
	    }
	    .modal-content input::placeholder { color: color-mix(in srgb, var(--text-secondary) 90%, transparent); }
    .setting-row { margin-bottom: 20px; }
    .setting-row label { display: block; margin-bottom: 8px; font-weight: 500; font-size: 0.9rem; }
    .setting-row select, .setting-row input[type="range"] { width: 100%; }
    .setting-row select { padding: 10px 12px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--bg); font-size: 0.9rem; }
    .setting-row input[type="range"] { -webkit-appearance: none; height: 6px; background: var(--border); border-radius: 3px; }
    .setting-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: var(--primary); border-radius: 50%; cursor: pointer; }
    .theme-buttons { display: flex; gap: 10px; }
    .theme-buttons button { flex: 1; padding: 12px; border: 2px solid var(--border); border-radius: var(--radius-sm); background: var(--bg-card); cursor: pointer; font-weight: 500; transition: var(--transition); }
    .theme-buttons button:hover { border-color: var(--primary-light); }
    .theme-buttons button.active { border-color: var(--primary); background: var(--primary-light); }
    .close-btn { width: 100%; padding: 14px; margin-top: 20px; border: none; border-radius: var(--radius-sm); background: var(--primary); color: white; cursor: pointer; font-weight: 500; font-size: 0.95rem; transition: var(--transition); }
    .close-btn:hover { background: var(--primary-dark); }
    .btn-secondary { background: var(--bg); color: var(--text); border: 1px solid var(--border); }
    .btn-secondary:hover { background: var(--bg-hover); }

    /* Text selection popup */
	    .search-popup { position: fixed; background: var(--glass-strong); border-radius: 14px; box-shadow: var(--shadow-lg); padding: 8px; z-index: 450; border: 1px solid var(--hairline); backdrop-filter: blur(16px) saturate(160%); }
	    .search-popup button { display: block; width: 100%; padding: 10px 14px; border: none; background: transparent; cursor: pointer; text-align: left; border-radius: 12px; font-size: 0.9rem; transition: transform 140ms var(--ease-out), background 140ms var(--ease-out); font-weight: 650; color: var(--text); }
	    .search-popup button:hover { background: color-mix(in srgb, var(--primary-light) 70%, transparent); transform: translateY(-1px); }

    /* Delete modal */
    .delete-modal p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.5; }
    .delete-modal button { display: block; width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--bg-card); cursor: pointer; font-weight: 500; transition: var(--transition); }
    .delete-modal button:hover { background: var(--bg-hover); }
    .delete-modal button.danger { background: #dc2626; color: white; border-color: #dc2626; }
    .delete-modal button.danger:hover { background: #b91c1c; }
    .delete-modal button:last-child { margin-bottom: 0; }

    /* Library management modal */
    .lib-modal input[type="text"] { width: 100%; padding: 12px 14px; border: 1px solid var(--border); border-radius: var(--radius-sm); font-size: 0.95rem; margin-bottom: 16px; }
    .lib-modal input[type="text"]:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px var(--primary-light); }
    .lib-modal .btn-row { display: flex; gap: 10px; margin-top: 20px; }
    .lib-modal .btn-row button { flex: 1; }

    /* Search results highlight */
    .search-highlight { background: #fef08a; padding: 2px 0; border-radius: 2px; }
    .search-highlight.current { background: #fb923c; }

	    /* Recent books section */
	    .recent-section { margin-bottom: 32px; width: 100%; }
	    .recent-section h3 { font-size: 1rem; font-weight: 700; margin-bottom: 14px; color: color-mix(in srgb, var(--text-secondary) 85%, var(--text) 15%); letter-spacing: -0.2px; }
	    .recent-books { display: flex; gap: 14px; overflow-x: auto; padding-bottom: 10px; scroll-snap-type: x mandatory; scrollbar-width: none; }
	    .recent-books::-webkit-scrollbar { display: none; }
	    .recent-book { flex-shrink: 0; width: 212px; min-height: 372px; background: var(--surface); border-radius: 16px; padding: 12px; cursor: pointer; border: 1px solid var(--hairline); transition: transform 180ms var(--ease-out), box-shadow 180ms var(--ease-out), border-color 180ms var(--ease-out); display: flex; flex-direction: column; box-shadow: var(--shadow); position: relative; }
	    .recent-book { scroll-snap-align: start; }
	    .recent-book:hover { transform: translateY(-3px); box-shadow: var(--shadow-lg); border-color: color-mix(in srgb, var(--primary) 16%, var(--hairline) 84%); }
	    .recent-book .recent-remove { position: absolute; top: 8px; right: 8px; width: 22px; height: 22px; border-radius: 50%; border: none; background: rgba(0,0,0,0.5); color: white; cursor: pointer; display: none; align-items: center; justify-content: center; font-size: 14px; line-height: 1; z-index: 2; }
	    .recent-book:hover .recent-remove { display: flex; }
	    .recent-book .recent-remove:hover { background: rgba(0,0,0,0.7); }
	    .recent-book .book-icon { width: 100%; aspect-ratio: 3 / 4; background: linear-gradient(135deg, color-mix(in srgb, var(--primary-light) 70%, #fff 30%) 0%, #fff 100%); border-radius: 12px; margin-bottom: 8px; display: flex; align-items: center; justify-content: center; border: 1px solid var(--border); overflow: hidden; }
	    .recent-book .book-title { font-size: 0.86rem; font-weight: 500; margin-bottom: 3px; line-height: 1.2; height: calc(1.2em * 2); display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
	    .recent-book .book-author { font-size: 0.77rem; line-height: 1.1; height: 1.1em; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
	    .recent-book .book-footer { margin-top: 6px; display:flex; flex-direction:column; justify-content:flex-end; gap: 3px; min-height: 44px; }
	    .recent-book .book-progress-row { display:flex; align-items:center; justify-content: space-between; gap: 6px; margin-top: 0; }
	    .recent-book .book-progress-row .book-progress { margin-top: 0; flex: 1; height: 4px; background: color-mix(in srgb, var(--border) 70%, transparent); border-radius: 999px; overflow: hidden; }
	    .recent-book .book-progress-bar { height: 100%; background: linear-gradient(90deg, var(--primary), color-mix(in srgb, var(--primary) 70%, #ffb3c7 30%)); border-radius: 999px; transition: width 0.3s var(--ease-out); }
	    .recent-book .book-progress-pct { font-size: 0.72rem; color: var(--text-secondary); font-weight: 720; min-width: 30px; text-align: right; font-variant-numeric: tabular-nums; }
	    body[data-card-density="dense"] .recent-book { width: 192px; min-height: 328px; }
	    body[data-card-density="dense"] .recent-book .book-title { height: 1.2em; -webkit-line-clamp: 1; }
	    body[data-card-density="dense"] .recent-book .book-footer { min-height: 32px; gap: 2px; }

	    /* Stats */
	    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); gap: 14px; margin-bottom: 20px; }
	    .stat-card { background: var(--surface); border: 1px solid var(--hairline); border-radius: 18px; padding: 18px 18px; box-shadow: var(--shadow); }
	    .stat-card .stat-value { font-size: 1.65rem; font-weight: 800; color: color-mix(in srgb, var(--primary) 92%, var(--text) 8%); letter-spacing: -0.02em; }
	    .stat-card .stat-value.subtle-time { font-size: 1.05rem; line-height: 1.3; font-weight: 760; letter-spacing: 0; }
	    .stat-card .stat-label { font-size: 0.86rem; color: var(--text-secondary); margin-top: 6px; }
	    .stat-card .stat-action { margin-top: 12px; display:flex; justify-content:flex-end; }
	    .stat-card .stat-action button { border: 1px solid var(--hairline); background: var(--glass); border-radius: 999px; padding: 8px 12px; cursor: pointer; font-weight: 720; color: var(--text); transition: transform 140ms var(--ease-out), box-shadow 140ms var(--ease-out); }
	    .stat-card .stat-action button:hover { transform: translateY(-1px); box-shadow: var(--shadow); }

	    .insights-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; margin-top: 14px; }
	    .insights-card { background: var(--surface); border: 1px solid var(--hairline); border-radius: 18px; padding: 14px; box-shadow: var(--shadow); }
	    .insights-card .k { font-size: 0.78rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--text-secondary); font-weight: 780; }
	    .insights-card .v { margin-top: 8px; font-size: 1.35rem; font-weight: 820; color: color-mix(in srgb, var(--text) 92%, transparent); }
	    .insights-bars { display:flex; align-items:flex-end; gap: 6px; height: 90px; margin-top: 12px; }
	    .insights-bar { flex: 1; min-width: 8px; border-radius: 10px; background: color-mix(in srgb, var(--border) 70%, transparent); position: relative; overflow: hidden; }
	    .insights-bar > span { position:absolute; inset:0; transform-origin: bottom; background: linear-gradient(180deg, color-mix(in srgb, var(--primary) 72%, transparent), color-mix(in srgb, var(--primary) 24%, transparent)); }
	    .insights-bar[data-active="true"] { background: color-mix(in srgb, var(--primary) 12%, transparent); }
	    .insights-list { margin-top: 10px; display:flex; flex-direction:column; gap: 8px; }
	    .insights-item { display:flex; align-items:center; justify-content:space-between; gap: 12px; padding: 10px 12px; border-radius: 14px; border: 1px solid var(--hairline); background: var(--glass); }
	    .insights-item .name { font-weight: 700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
	    .insights-item .meta { color: var(--text-secondary); font-weight: 720; font-size: 0.85rem; }

    .hidden { display: none !important; }

	    /* Animations */
	    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
	    @keyframes slideUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
	    @keyframes cardIn {
	      from { opacity: 0; transform: translateY(10px) scale(0.985); filter: blur(2px); }
	      to { opacity: 1; transform: translateY(0) scale(1); filter: blur(0); }
	    }
	    .modal { animation: fadeIn 0.2s ease; }
	    .modal-content { animation: slideUp 0.2s ease; }
	    .book-card { animation: cardIn 520ms var(--ease-out) both; }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(29, 29, 31, 0.92);
      color: white;
      padding: 12px 16px;
      border-radius: 999px;
      box-shadow: var(--shadow-lg);
      z-index: 300;
      font-size: 0.9rem;
      max-width: 90vw;
      backdrop-filter: blur(8px);
    }
    .toast.success { background: rgba(34, 197, 94, 0.92); }
    .toast.error { background: rgba(220, 38, 38, 0.92); }

	    /* Context menu */
	    .context-menu { position: fixed; min-width: 230px; background: var(--glass-strong); border: 1px solid var(--hairline); border-radius: 14px; box-shadow: var(--shadow-lg); padding: 8px; z-index: 400; backdrop-filter: blur(16px) saturate(160%); }
	    .context-menu button { width: 100%; padding: 10px 12px; border: none; background: transparent; text-align: left; cursor: pointer; border-radius: 12px; font-size: 0.92rem; color: var(--text); display: flex; align-items: center; justify-content: space-between; gap: 10px; font-weight: 650; }
	    .context-menu button:hover { background: color-mix(in srgb, var(--bg-card) 86%, transparent); }
	    .context-menu .danger { color: #dc2626; }
		    .context-menu .sep { height: 1px; background: var(--hairline); margin: 6px 4px; }

    /* App Themes */
			    :root[data-app-theme="dark"] {
			      color-scheme: dark;
			      --bg: #0f0b0c;
			      --bg-card: #171012;
			      --bg-hover: rgba(255, 244, 240, 0.055);
			      --text: rgba(255, 244, 240, 0.94);
			      --text-secondary: rgba(255, 244, 240, 0.66);
		      --border: rgba(255, 244, 240, 0.10);
		      --shadow: 0 10px 30px rgba(0,0,0,0.46);
		      --shadow-lg: 0 24px 74px rgba(0,0,0,0.60);
		      --primary-light: color-mix(in srgb, var(--primary) 18%, transparent);
		      --paper: color-mix(in srgb, #1a1314 78%, var(--bg) 22%);
		    }
	    :root[data-app-theme="dark"] body::after {
	      opacity: 0.28;
	      mix-blend-mode: screen;
	      filter: saturate(1.14) contrast(1.06);
	    }
		    :root[data-app-theme="rose"] {
		      color-scheme: light;
		      --bg: #fff0f3;
		      --bg-card: #ffffff;
		      --bg-hover: #fff5f7;
		      --text: #4a3b40;
		      --text-secondary: rgba(74,59,64,0.68);
	      --border: #f0d6de;
	    }

	    /* Silk Theme - Modern, elegant glassmorphism */
	    :root[data-app-theme="silk"] {
	      color-scheme: dark;
	      --bg: #0a0a0c;
	      --bg-card: rgba(22, 22, 28, 0.72);
	      --bg-hover: rgba(255, 255, 255, 0.04);
	      --text: rgba(255, 255, 255, 0.92);
	      --text-secondary: rgba(255, 255, 255, 0.52);
	      --border: rgba(255, 255, 255, 0.06);
	      --shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
	      --shadow-lg: 0 24px 64px rgba(0, 0, 0, 0.5);
	      --primary-light: color-mix(in srgb, var(--primary) 14%, transparent);
	      --paper: rgba(18, 18, 22, 0.85);
	      --glass: rgba(28, 28, 36, 0.55);
	      --glass-strong: rgba(24, 24, 32, 0.78);
	      --hairline: rgba(255, 255, 255, 0.05);
	      --surface: rgba(32, 32, 42, 0.52);
	      --radius: 20px;
	      --radius-sm: 12px;
	      --silk-shimmer: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0) 50%, rgba(255,255,255,0.02) 100%);
	      --silk-glow: 0 0 80px rgba(var(--primary-rgb, 212, 67, 106), 0.12);
	    }
	    :root[data-app-theme="silk"] body {
	      background: linear-gradient(165deg, #0a0a0c 0%, #0d0d12 50%, #08080a 100%);
	    }
	    :root[data-app-theme="silk"] body::after {
	      background:
	        radial-gradient(ellipse 1200px 900px at 15% 10%, rgba(var(--primary-rgb, 212, 67, 106), 0.08), transparent 50%),
	        radial-gradient(ellipse 1000px 800px at 85% 20%, rgba(180, 140, 255, 0.05), transparent 50%),
	        radial-gradient(ellipse 900px 700px at 70% 90%, rgba(var(--primary-rgb, 212, 67, 106), 0.06), transparent 50%),
	        radial-gradient(ellipse 800px 600px at 20% 85%, rgba(100, 180, 255, 0.04), transparent 50%);
	      opacity: 1;
	      mix-blend-mode: normal;
	      filter: none;
	    }
	    :root[data-app-theme="silk"] header {
	      background: rgba(14, 14, 18, 0.65);
	      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
	      backdrop-filter: blur(24px) saturate(180%);
	    }
	    :root[data-app-theme="silk"] .library-sidebar {
	      background: rgba(14, 14, 18, 0.55);
	      border-right: 1px solid rgba(255, 255, 255, 0.04);
	      backdrop-filter: blur(24px) saturate(180%);
	    }
	    :root[data-app-theme="silk"] .book-card {
	      background: var(--silk-shimmer), rgba(28, 28, 38, 0.45);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      backdrop-filter: blur(16px);
	      box-shadow: var(--shadow), inset 0 1px 0 rgba(255, 255, 255, 0.04);
	    }
	    :root[data-app-theme="silk"] .book-card:hover {
	      background: var(--silk-shimmer), rgba(38, 38, 50, 0.55);
	      border-color: rgba(255, 255, 255, 0.1);
	      box-shadow: var(--silk-glow), var(--shadow-lg), inset 0 1px 0 rgba(255, 255, 255, 0.06);
	      transform: translateY(-6px) scale(1.015);
	    }
	    :root[data-app-theme="silk"] .book-card .book-icon {
	      background: linear-gradient(145deg, rgba(var(--primary-rgb, 212, 67, 106), 0.12) 0%, rgba(var(--primary-rgb, 212, 67, 106), 0.04) 100%);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
	    }
	    :root[data-app-theme="silk"] .stat-card,
	    :root[data-app-theme="silk"] .insights-card {
	      background: var(--silk-shimmer), rgba(24, 24, 32, 0.5);
	      border: 1px solid rgba(255, 255, 255, 0.05);
	      backdrop-filter: blur(16px);
	      box-shadow: var(--shadow), inset 0 1px 0 rgba(255, 255, 255, 0.03);
	    }
	    :root[data-app-theme="silk"] .recent-book {
	      background: var(--silk-shimmer), rgba(28, 28, 38, 0.45);
	      border: 1px solid rgba(255, 255, 255, 0.05);
	      backdrop-filter: blur(16px);
	    }
	    :root[data-app-theme="silk"] .recent-book:hover {
	      background: var(--silk-shimmer), rgba(38, 38, 50, 0.55);
	      border-color: rgba(255, 255, 255, 0.08);
	      box-shadow: var(--silk-glow), var(--shadow);
	    }
	    :root[data-app-theme="silk"] .search-box {
	      background: rgba(255, 255, 255, 0.04);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      backdrop-filter: blur(12px);
	    }
		    :root[data-app-theme="silk"] .search-box:focus-within {
		      background: rgba(255, 255, 255, 0.06);
		      border-color: rgba(var(--primary-rgb, 212, 67, 106), 0.3);
		      box-shadow: 0 0 0 3px rgba(var(--primary-rgb, 212, 67, 106), 0.1);
		    }
		    :root[data-app-theme="silk"] .library-search {
		      background: rgba(255, 255, 255, 0.05);
		      border: 1px solid rgba(255, 255, 255, 0.10);
		      box-shadow: 0 14px 40px rgba(0,0,0,0.35);
		    }
		    :root[data-app-theme="silk"] .library-search:hover {
		      border-color: rgba(255, 255, 255, 0.14);
		      background: rgba(255, 255, 255, 0.07);
		    }
		    :root[data-app-theme="silk"] .library-search kbd {
		      background: rgba(255, 255, 255, 0.06);
		      border-color: rgba(255, 255, 255, 0.10);
		    }
		    :root[data-app-theme="silk"] .library-search-popover {
		      background: rgba(20, 20, 26, 0.92);
		      border-color: rgba(255, 255, 255, 0.08);
		      box-shadow: 0 0 0 1px rgba(255,255,255,0.06), 0 42px 110px rgba(0,0,0,0.55);
		      backdrop-filter: blur(32px) saturate(180%);
		    }
	    :root[data-app-theme="silk"] header button {
	      background: rgba(255, 255, 255, 0.04);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      backdrop-filter: blur(8px);
	    }
	    :root[data-app-theme="silk"] header button:hover {
	      background: rgba(255, 255, 255, 0.08);
	      border-color: rgba(255, 255, 255, 0.1);
	    }
	    :root[data-app-theme="silk"] header button.primary {
	      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
	      border: none;
	      box-shadow: 0 4px 16px rgba(var(--primary-rgb, 212, 67, 106), 0.3);
	    }
	    :root[data-app-theme="silk"] header button.primary:hover {
	      box-shadow: 0 6px 24px rgba(var(--primary-rgb, 212, 67, 106), 0.4);
	      transform: translateY(-2px);
	    }
	    :root[data-app-theme="silk"] .library-item {
	      border-radius: 12px;
	    }
	    :root[data-app-theme="silk"] .library-item:hover {
	      background: rgba(255, 255, 255, 0.04);
	    }
	    :root[data-app-theme="silk"] .library-item.active {
	      background: linear-gradient(135deg, rgba(var(--primary-rgb, 212, 67, 106), 0.15) 0%, rgba(var(--primary-rgb, 212, 67, 106), 0.08) 100%);
	      border: 1px solid rgba(var(--primary-rgb, 212, 67, 106), 0.2);
	    }
	    :root[data-app-theme="silk"] .sidebar-tabs button {
	      background: rgba(255, 255, 255, 0.03);
	      border: 1px solid rgba(255, 255, 255, 0.05);
	    }
	    :root[data-app-theme="silk"] .sidebar-tabs button.active {
	      background: linear-gradient(135deg, rgba(var(--primary-rgb, 212, 67, 106), 0.18) 0%, rgba(var(--primary-rgb, 212, 67, 106), 0.08) 100%);
	      border-color: rgba(var(--primary-rgb, 212, 67, 106), 0.25);
	    }
	    :root[data-app-theme="silk"] .modal-content {
	      background: rgba(20, 20, 26, 0.92);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      backdrop-filter: blur(32px) saturate(180%);
	      box-shadow: 0 32px 80px rgba(0, 0, 0, 0.5);
	    }
	    :root[data-app-theme="silk"] .context-menu,
	    :root[data-app-theme="silk"] .search-popup {
	      background: rgba(22, 22, 28, 0.92);
	      border: 1px solid rgba(255, 255, 255, 0.06);
	      backdrop-filter: blur(24px) saturate(180%);
	    }
	    :root[data-app-theme="silk"] .toc-sidebar {
	      background: rgba(14, 14, 18, 0.65);
	      border-right: 1px solid rgba(255, 255, 255, 0.04);
	      backdrop-filter: blur(24px) saturate(180%);
	    }
	    :root[data-app-theme="silk"] .book-progress-bar {
	      background: linear-gradient(90deg, var(--primary), color-mix(in srgb, var(--primary) 60%, #fff 40%));
	      box-shadow: 0 0 12px rgba(var(--primary-rgb, 212, 67, 106), 0.4);
	    }
	    :root[data-app-theme="silk"] .stat-card .stat-value {
	      background: linear-gradient(135deg, var(--primary) 0%, color-mix(in srgb, var(--primary) 70%, #fff 30%) 100%);
	      -webkit-background-clip: text;
	      -webkit-text-fill-color: transparent;
	      background-clip: text;
	    }
	    :root[data-app-theme="silk"] ::-webkit-scrollbar-thumb {
	      background: rgba(255, 255, 255, 0.08);
	    }
	    :root[data-app-theme="silk"] ::-webkit-scrollbar-thumb:hover {
	      background: rgba(255, 255, 255, 0.12);
	    }

	    /* Accent variants (works with any app theme; designed for warm-dark) */
	    :root[data-accent="rose-gold"] {
	      --primary: #ff4d7d;
	      --primary-dark: #e23b6a;
	      --primary-rgb: 255, 77, 125;
	      --glow-1: rgba(255, 77, 125, 0.18);
	      --glow-2: rgba(255, 206, 187, 0.18);
	      --glow-3: rgba(226, 170, 208, 0.16);
	      --glow-4: rgba(255, 230, 198, 0.16);
	    }
	    :root[data-accent="saffron"] {
	      --primary: #ffb020;
	      --primary-dark: #e08c15;
	      --primary-rgb: 255, 176, 32;
	      --glow-1: rgba(255, 176, 32, 0.20);
	      --glow-2: rgba(255, 220, 150, 0.18);
	      --glow-3: rgba(255, 168, 116, 0.14);
	      --glow-4: rgba(255, 246, 210, 0.18);
	    }
	    :root[data-accent="copper"] {
	      --primary: #e86a3b;
	      --primary-dark: #c7542b;
	      --primary-rgb: 232, 106, 59;
	      --glow-1: rgba(232, 106, 59, 0.20);
	      --glow-2: rgba(255, 210, 178, 0.16);
	      --glow-3: rgba(255, 165, 135, 0.12);
	      --glow-4: rgba(255, 236, 218, 0.16);
	    }
	    :root[data-accent="fig"] {
	      --primary: #d46ad6;
	      --primary-dark: #b54ab8;
	      --primary-rgb: 212, 106, 214;
	      --glow-1: rgba(212, 106, 214, 0.18);
	      --glow-2: rgba(255, 199, 236, 0.16);
	      --glow-3: rgba(194, 174, 255, 0.16);
	      --glow-4: rgba(255, 230, 212, 0.12);
	    }
	    :root[data-accent="moss"] {
	      --primary: #7fcf92;
	      --primary-dark: #56ad6c;
	      --primary-rgb: 127, 207, 146;
	      --glow-1: rgba(127, 207, 146, 0.16);
	      --glow-2: rgba(255, 224, 188, 0.12);
	      --glow-3: rgba(175, 226, 192, 0.14);
	      --glow-4: rgba(255, 242, 214, 0.14);
	    }

    /* PDF Mode */
    .reader-content.pdf-mode { padding: 0 !important; overflow: auto; }
    .reader-content.pdf-mode .reader-scroll-body { max-width: none; margin: 0; padding: 20px; display: flex; flex-direction: column; align-items: center; }
    .pdf-page { display: flex; justify-content: center; margin-bottom: 20px; min-height: 400px; position: relative; }
    .pdf-page-container { position: relative; box-shadow: 0 2px 12px rgba(0,0,0,0.15); }
    .pdf-page canvas { display: block; }
	    .pdf-page .textLayer {
	      position: absolute;
	      left: 0;
	      top: 0;
	      right: 0;
	      bottom: 0;
	      overflow: hidden;
	      line-height: 1.0;
	      pointer-events: auto;
	    }
	    .pdf-page .highlightLayer {
	      position: absolute;
	      left: 0;
	      top: 0;
	      right: 0;
	      bottom: 0;
	      pointer-events: none;
	    }
	    .pdf-page .highlightLayer .pdf-highlight-rect {
	      position: absolute;
	      border-radius: 3px;
	    }
	    .pdf-page .pdf-search-layer {
	      position: absolute;
	      left: 0;
	      top: 0;
	      right: 0;
	      bottom: 0;
	      pointer-events: none;
	    }
	    .pdf-page .pdf-search-layer .pdf-search-mark {
	      position: absolute;
	      border-radius: 4px;
	      background: linear-gradient(135deg, color-mix(in srgb, var(--accent, #b8860b) 60%, transparent), color-mix(in srgb, var(--accent, #b8860b) 30%, transparent));
	      box-shadow: 0 4px 12px color-mix(in srgb, var(--accent, #b8860b) 28%, transparent), 0 0 0 1px color-mix(in srgb, var(--accent, #b8860b) 40%, transparent);
	      transition: box-shadow 0.2s ease, transform 0.2s ease;
	    }
	    .pdf-page .pdf-search-layer .pdf-search-mark.current {
	      box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent, #b8860b) 95%, transparent), 0 10px 24px color-mix(in srgb, var(--accent, #b8860b) 60%, transparent);
	      background: color-mix(in srgb, var(--accent, #b8860b) 85%, transparent);
	      animation: search-pulse 1.1s ease-out;
	      transform: translateY(-1px);
	    }
	    .pdf-page .textLayer > span {
	      color: transparent;
	      position: absolute;
	      white-space: pre;
	      transform-origin: 0% 0%;
	    }
	    .pdf-page .textLayer > span::selection {
	      background: color-mix(in srgb, var(--accent, #b8860b) 40%, transparent);
	    }
	    .pdf-page .textLayer > span.search-highlight-span.current {
	      outline: 2px solid color-mix(in srgb, var(--accent, #b8860b) 75%, transparent);
	      outline-offset: 1px;
	      box-shadow: 0 0 0 3px color-mix(in srgb, var(--accent, #b8860b) 22%, transparent);
	    }
	    .pdf-page .textLayer .highlight {
	      border-radius: 3px;
	      cursor: pointer;
	    }
	    .pdf-page .textLayer .highlight-flash,
	    .pdf-page .highlightLayer .pdf-highlight-rect.highlight-flash {
	      animation: pdf-highlight-flash 1.5s ease-out;
	    }
    @keyframes pdf-highlight-flash {
      0%, 50% { box-shadow: 0 0 0 3px var(--hl-flash-color, #ffd600), 0 0 12px 4px var(--hl-flash-color, #ffd600); }
      100% { box-shadow: none; }
    }
    @keyframes pdf-indicator-flash {
      0% { opacity: 1; }
      70% { opacity: 1; }
      100% { opacity: 0; }
    }
    .pdf-location-indicator {
      animation: pdf-indicator-fade 1.2s ease-out forwards;
    }
    .pdf-indicator-arrow {
      color: var(--accent, #b8860b);
      font-size: 18px;
      margin-right: 4px;
      animation: pdf-arrow-slide 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      filter: drop-shadow(0 0 6px var(--accent, #b8860b));
    }
    .pdf-indicator-bar {
      flex: 1;
      height: 2px;
      background: linear-gradient(90deg, var(--accent, #b8860b), transparent 80%);
      animation: pdf-bar-expand 0.5s cubic-bezier(0.22, 1, 0.36, 1) forwards;
      transform-origin: left;
      box-shadow: 0 0 8px var(--accent, #b8860b);
    }
    @keyframes pdf-indicator-fade {
      0%, 60% { opacity: 1; }
      100% { opacity: 0; }
    }
    @keyframes pdf-arrow-slide {
      0% { transform: translateX(-20px); opacity: 0; }
      100% { transform: translateX(0); opacity: 1; }
    }
    @keyframes pdf-bar-expand {
      0% { transform: scaleX(0); opacity: 0; }
      100% { transform: scaleX(1); opacity: 1; }
    }
    .pdf-page .annotationLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }
    .pdf-page .annotationLayer section {
      position: absolute;
      pointer-events: auto;
    }
    .pdf-page .annotationLayer .linkAnnotation > a {
      position: absolute;
      font-size: 1em;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      cursor: pointer;
    }
    .pdf-page .annotationLayer .linkAnnotation > a:hover {
      background: rgba(255, 255, 0, 0.2);
    }
  </style>
</head>
<body>
	    <div class="app" id="app">
	      <div id="search-overlay"></div>
	      <div class="library-search-popover" id="library-search-popover" role="dialog" aria-label="Search">
	        <div class="pop-search-row">
	          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
	          <input type="text" id="library-search-input" placeholder="Search title, author, or file…" autocomplete="off" spellcheck="false" aria-label="Search books">
	          <button type="button" class="pop-search-clear" id="library-search-clear" title="Clear" aria-label="Clear search">
	            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M18 6L6 18M6 6l12 12"/></svg>
	          </button>
	        </div>
	        <div class="pop-filters" id="pop-filters">
	          <button type="button" class="filter-chip" data-filter="format" data-value="epub">EPUB</button>
	          <button type="button" class="filter-chip" data-filter="format" data-value="pdf">PDF</button>
	          <button type="button" class="filter-chip" data-filter="format" data-value="txt">TXT</button>
	          <span class="filter-sep"></span>
	          <button type="button" class="filter-chip" data-filter="status" data-value="unread">Unread</button>
	          <button type="button" class="filter-chip" data-filter="status" data-value="reading">Reading</button>
	          <button type="button" class="filter-chip" data-filter="status" data-value="finished">Finished</button>
	        </div>
	        <div class="pop-list" id="library-search-list"></div>
	        <div class="pop-hint">
	          <span><kbd>↑↓</kbd> navigate</span>
	          <span><kbd>↵</kbd> open</span>
	          <span><kbd>esc</kbd> close</span>
	        </div>
	      </div>
	      <!-- Library View -->
	      <div id="library-view">
	      <header>
	        <button class="icon-btn" onclick="toggleSidebarCollapsed()" title="Toggle sidebar">
	          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"><path d="M4 6h16M4 12h16M4 18h16"/></svg>
	        </button>
	        <div class="logo-group">
	          <svg class="logo-rose" viewBox="0 0 32 32" width="28" height="28">
	            <defs>
	              <linearGradient id="roseGradLogo" x1="0%" y1="0%" x2="100%" y2="100%">
	                <stop offset="0%" style="stop-color:#e8a4b8"/>
	                <stop offset="50%" style="stop-color:#d4436a"/>
	                <stop offset="100%" style="stop-color:#b8345a"/>
	              </linearGradient>
	            </defs>
	            <g transform="translate(16, 16)">
	              <ellipse cx="0" cy="0" rx="10" ry="6.5" fill="url(#roseGradLogo)" transform="rotate(0)" opacity="0.9"/>
	              <ellipse cx="0" cy="0" rx="10" ry="6.5" fill="url(#roseGradLogo)" transform="rotate(72)" opacity="0.9"/>
	              <ellipse cx="0" cy="0" rx="10" ry="6.5" fill="url(#roseGradLogo)" transform="rotate(144)" opacity="0.9"/>
	              <ellipse cx="0" cy="0" rx="10" ry="6.5" fill="url(#roseGradLogo)" transform="rotate(216)" opacity="0.9"/>
	              <ellipse cx="0" cy="0" rx="10" ry="6.5" fill="url(#roseGradLogo)" transform="rotate(288)" opacity="0.9"/>
	              <ellipse cx="0" cy="0" rx="7" ry="4.5" fill="#e07090" transform="rotate(36)"/>
	              <ellipse cx="0" cy="0" rx="7" ry="4.5" fill="#e07090" transform="rotate(108)"/>
	              <ellipse cx="0" cy="0" rx="7" ry="4.5" fill="#e07090" transform="rotate(180)"/>
	              <ellipse cx="0" cy="0" rx="7" ry="4.5" fill="#e07090" transform="rotate(252)"/>
	              <ellipse cx="0" cy="0" rx="7" ry="4.5" fill="#e07090" transform="rotate(324)"/>
	              <circle cx="0" cy="0" r="3" fill="#b8345a"/>
	            </g>
		          </svg>
		          <h1>RoseReader</h1>
		        </div>
		        <div class="library-search" id="library-search" role="search" aria-label="Search library">
		          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
		          <input type="text" id="library-search-trigger" placeholder="Search books…" readonly aria-label="Search books">
		          <kbd id="library-search-kbd" aria-hidden="true">⌘K</kbd>
		        </div>
	        <div class="header-spacer"></div>
		        <button id="btn-new-library" onclick="showCreateLibraryModal()">+ New Library</button>
	        <button id="btn-import-dir" class="primary" onclick="importDir()">Import Directory</button>
	        <button id="btn-settings" onclick="showSettings()">Settings</button>
      </header>
      <div class="content" id="library-content">
        <div class="library-layout">
          <!-- Library Sidebar -->
          <div class="library-sidebar">
            <div class="library-sidebar-header">
              <h3 id="sidebar-title">Libraries</h3>
              <div class="sidebar-header-actions">
                <button id="sidebar-add-library" onclick="showCreateLibraryModal()" title="Create Library">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
                </button>
                <button id="sidebar-add-folder" class="hidden" onclick="createFolderPrompt()" title="Create Folder">
                  <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 5v14M5 12h14"/></svg>
                </button>
              </div>
            </div>
            <div class="sidebar-tabs">
              <button id="tab-libraries" onclick="setSidebarMode('libraries')" class="active">Libraries</button>
              <button id="tab-folders" onclick="setSidebarMode('folders')">Folders</button>
            </div>
            <div class="library-list" id="library-list">
              <div class="library-item active" onclick="selectLibrary('all')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
	                <span id="nav-all-books">All Books</span>
              </div>
            </div>
            <div class="folder-tree hidden" id="folder-tree"></div>
          </div>
          <!-- Books Area -->
          <div class="books-area" id="books-area">
	            <div class="empty" id="empty-msg">
	              <div class="empty-illustration">
	                <svg viewBox="0 0 200 160" width="200" height="160">
	                  <defs>
	                    <linearGradient id="emptyBookGrad" x1="0%" y1="0%" x2="100%" y2="100%">
	                      <stop offset="0%" style="stop-color:#f5f0eb"/>
	                      <stop offset="100%" style="stop-color:#e8e0d8"/>
	                    </linearGradient>
	                    <linearGradient id="emptyRoseGrad" x1="0%" y1="0%" x2="100%" y2="100%">
	                      <stop offset="0%" style="stop-color:#e8a4b8"/>
	                      <stop offset="50%" style="stop-color:#d4436a"/>
	                      <stop offset="100%" style="stop-color:#b8345a"/>
	                    </linearGradient>
	                  </defs>
	                  <!-- Stack of books -->
	                  <rect x="40" y="90" width="120" height="16" rx="2" fill="#d4436a" opacity="0.9"/>
	                  <rect x="45" y="74" width="110" height="16" rx="2" fill="#e07090"/>
	                  <rect x="50" y="58" width="100" height="16" rx="2" fill="#e8a4b8"/>
	                  <!-- Open book on top -->
	                  <g transform="translate(100, 45)">
	                    <path d="M-4 -20 Q-50 -25 -60 -10 L-60 35 Q-50 20 -4 25 Z" fill="url(#emptyBookGrad)"/>
	                    <path d="M4 -20 Q50 -25 60 -10 L60 35 Q50 20 4 25 Z" fill="url(#emptyBookGrad)"/>
	                    <path d="M-4 -20 L-4 25 L4 25 L4 -20 Z" fill="#d4436a"/>
	                  </g>
	                  <!-- Rose -->
	                  <g transform="translate(155, 35)">
	                    <ellipse cx="0" cy="0" rx="12" ry="8" fill="url(#emptyRoseGrad)" transform="rotate(0)" opacity="0.9"/>
	                    <ellipse cx="0" cy="0" rx="12" ry="8" fill="url(#emptyRoseGrad)" transform="rotate(72)" opacity="0.9"/>
	                    <ellipse cx="0" cy="0" rx="12" ry="8" fill="url(#emptyRoseGrad)" transform="rotate(144)" opacity="0.9"/>
	                    <ellipse cx="0" cy="0" rx="12" ry="8" fill="url(#emptyRoseGrad)" transform="rotate(216)" opacity="0.9"/>
	                    <ellipse cx="0" cy="0" rx="12" ry="8" fill="url(#emptyRoseGrad)" transform="rotate(288)" opacity="0.9"/>
	                    <circle cx="0" cy="0" r="4" fill="#b8345a"/>
	                  </g>
	                  <!-- Decorative dots -->
	                  <circle cx="30" cy="50" r="3" fill="#d4436a" opacity="0.3"/>
	                  <circle cx="170" cy="80" r="2" fill="#d4436a" opacity="0.2"/>
	                  <circle cx="25" cy="100" r="2" fill="#d4436a" opacity="0.15"/>
	                </svg>
	              </div>
	              <h2 id="empty-title">Welcome to RoseReader</h2>
	              <p id="empty-sub">Your personal e-book library. Import a directory to get started,<br>or create an empty library to organize your books.</p>
	              <button id="empty-import" class="primary" onclick="importDir()">Import Directory</button>
	            </div>
            <div id="books-container" class="hidden">
              <div class="books-main">
	                  <div class="stats-row" id="stats-row">
	                    <div class="stat-card">
	                      <div class="stat-value" id="stat-books-read">0</div>
		                      <div class="stat-label" id="label-books-finished">Books finished</div>
	                    </div>
	                    <div class="stat-card">
	                      <div class="stat-value" id="stat-read-time">0m</div>
		                      <div class="stat-label" id="label-total-reading-time">Total reading time</div>
	                    </div>
	                    <div class="stat-card">
	                      <div class="stat-value" id="stat-streak">0</div>
	                      <div class="stat-label" id="label-reading-streak">Reading streak</div>
	                      <div class="stat-action">
	                        <button id="btn-insights" onclick="showInsights()">Insights</button>
	                      </div>
	                    </div>
	                    <div class="stat-card">
	                      <div class="stat-value subtle-time" id="stat-last-read">-</div>
	                      <div class="stat-label" id="label-last-read-global">Last read (global)</div>
	                    </div>
	                    <div class="stat-card">
	                      <div class="stat-value" id="stat-books-touched-30d">0</div>
	                      <div class="stat-label" id="label-books-touched-30d">Books touched (30d)</div>
	                    </div>
	                  </div>
	                  <div class="recent-section" id="recent-section">
	                    <h3 id="label-continue-reading">Continue Reading</h3>
	                    <div class="recent-books" id="recent-books"></div>
	                  </div>
                  <div class="books-header">
                    <h2 id="books-header-title">All Books</h2>
                    <div class="books-controls">
                      <span class="books-count" id="books-count"></span>
                      <select id="sort-select" onchange="updateSort(this.value)">
                        <option value="recent">Recent</option>
                        <option value="added">Date Added</option>
                        <option value="title">Title</option>
                        <option value="author">Author</option>
                        <option value="progress">Progress</option>
                      </select>
                      <button title="Toggle sort direction" onclick="toggleSortDir()" id="sort-dir-btn">↓</button>
                    </div>
                  </div>
                  <div class="books-grid" id="books-grid"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

		    <!-- Reader View -->
		    <div id="reader-view" class="hidden" style="display:none;flex-direction:column;height:100vh;">
		      <header class="reader-header">
		        <div class="reader-header-left">
		          <button class="icon-btn" onclick="backToLibrary()" title="Back to library">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 18l-6-6 6-6"/><path d="M9 12h12"/></svg>
		          </button>
		          <button class="icon-btn" onclick="toggleToc()" title="Toggle table of contents">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg>
		          </button>
		          <button class="icon-btn" onclick="toggleBookmarks()" title="Bookmarks & highlights">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg>
		          </button>
		        </div>

		        <div class="reader-header-center">
		          <span class="book-name" id="current-book-title"></span>
		          <span class="reader-progress-pill" id="reader-progress-pill">0%</span>
		        </div>

		        <div class="reader-header-right">
		          <button class="icon-btn" data-toggle="topbar" onclick="toggleReaderTopBar()" title="Toggle top bar">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h10"/></svg>
		          </button>
		          <button class="icon-btn" data-toggle="fit" onclick="fitReaderWidth()" title="Fit reader width">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 8V4h4"/><path d="M20 8V4h-4"/><path d="M4 16v4h4"/><path d="M20 16v4h-4"/><path d="M9 12h6"/></svg>
		          </button>
	          <div class="reader-search" id="reader-search">
	            <div class="search-box">
	              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
	              <input type="text" id="book-search" placeholder="Search in book..." oninput="scheduleBookSearch()" onkeydown="onBookSearchKeydown(event)">
	              <div class="search-nav" id="search-nav" style="display:none;">
	                <button type="button" class="search-ctrl" onclick="prevSearchResult()" title="Previous match" aria-label="Previous match">
	                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 15l-6-6-6 6"/></svg>
	                </button>
	                <span id="search-position" class="search-count">0/0</span>
	                <button type="button" class="search-ctrl" onclick="nextSearchResult()" title="Next match" aria-label="Next match">
	                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 9l6 6 6-6"/></svg>
	                </button>
	                <button type="button" class="search-ctrl search-close" onclick="clearBookSearch()" title="Clear search" aria-label="Clear search">
	                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
	                </button>
	              </div>
	              <kbd class="search-kbd-hint" title="Press / to search">/</kbd>
	            </div>
		          <div class="search-results-panel hidden" id="search-results-panel"></div>
		        </div>
		      <button class="icon-btn" onclick="showSettings()" title="Settings">
		            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
		              <path d="M4 21v-7"/><path d="M4 10V3"/><path d="M12 21v-9"/><path d="M12 8V3"/><path d="M20 21v-5"/><path d="M20 12V3"/>
		              <path d="M2 14h4"/><path d="M10 8h4"/><path d="M18 16h4"/>
		            </svg>
		          </button>
		        </div>

		        <div class="reader-progress-bar" aria-hidden="true"><div class="fill" id="reader-progress-fill"></div></div>
		      </header>
	      <button class="floating-topbar-toggle" onclick="toggleReaderTopBar(true)" title="Show top bar">
	        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 6h16"/><path d="M4 12h10"/><path d="M4 18h16"/></svg>
	      </button>
	      <div class="reader-wrapper">
        <div class="toc-sidebar" id="toc-sidebar">
          <h3>Table of Contents</h3>
          <div id="toc-list"></div>
        </div>
        <div class="toc-sidebar hidden" id="bookmarks-sidebar">
          <div style="padding:12px 16px 6px;">
            <div style="display:flex;align-items:center;gap:8px;">
              <h3 style="padding:0;border:0;margin:0;flex:1;">Bookmarks & Highlights</h3>
              <input id="annotation-search" type="text" placeholder="Search annotations" style="width: 52%; padding: 6px 10px; border-radius: 10px; border: 1px solid var(--hairline); background: var(--glass-strong);" oninput="onAnnotationSearch(this.value, true)" autocomplete="off">
            </div>
          </div>
          <div id="bookmarks-list"></div>
        </div>
        <div class="reader-content" id="reader-content"></div>
        <div class="search-codemap" id="search-codemap">
          <div class="codemap-track" id="codemap-track"></div>
        </div>
      </div>
    </div>
	  </div>

	  <!-- Settings Modal -->
		  <div id="settings-modal" class="modal hidden">
		    <div class="modal-content">
	      <h2 id="settings-title">Reader Settings</h2>
      <div class="setting-row">
        <label>Font</label>
        <select id="font-mode" onchange="updateFontMode(this.value)">
          <option value="book">Use book fonts (EPUB)</option>
          <option value="system">System font</option>
          <option value="custom">Choose a font…</option>
        </select>
        <div id="font-custom" class="hidden" style="margin-top:10px;">
	      <input type="text" id="font-family-input" list="system-fonts" placeholder="Type to search fonts…" style="width:100%;padding:10px 12px;" oninput="updateCustomFont(this.value)">
          <datalist id="system-fonts"></datalist>
          <button class="btn-secondary" style="margin-top:10px;width:100%;padding:10px;border-radius:var(--radius-sm);" onclick="reloadSystemFonts()">Reload System Fonts</button>
        </div>
      </div>
      <div class="setting-row">
        <label>Font Size: <span id="font-size-val">18</span>px</label>
        <input type="range" id="font-size" min="12" max="32" value="18" oninput="updateSetting('fontSize', +this.value)">
      </div>
      <div class="setting-row">
        <label>Line Height: <span id="line-height-val">1.8</span></label>
        <input type="range" id="line-height" min="1" max="3" step="0.1" value="1.8" oninput="updateSetting('lineHeight', +this.value)">
      </div>
      <div class="setting-row">
        <label>Margin: <span id="margin-val">40</span>px</label>
        <input type="range" id="margin" min="0" max="100" value="40" oninput="updateSetting('margin', +this.value)">
      </div>
      <div class="setting-row">
        <label>Theme</label>
        <div class="theme-buttons">
          <button data-theme="light" onclick="setTheme('light','#ffffff','#1a1a1a')">Light</button>
          <button data-theme="sepia" onclick="setTheme('sepia','#f4ecd8','#5c4b37')">Sepia</button>
          <button data-theme="dark" onclick="setTheme('dark','#1a1a1a','#e0e0e0')">Dark</button>
          <button data-theme="midnight" onclick="setTheme('midnight','#0d1117','#c9d1d9')">Midnight</button>
        </div>
      </div>
		      <div class="setting-row">
		        <label id="label-app-theme">App Theme</label>
		        <select id="app-theme" onchange="updateSetting('appTheme', this.value)">
		          <option value="silk">Silk</option>
		          <option value="light">Light</option>
		          <option value="dark">Dark</option>
		          <option value="rose">Rose</option>
		        </select>
		      </div>
		      <div class="setting-row">
		        <label id="label-color-variant">Color Variant</label>
		        <select id="app-accent" onchange="updateSetting('appAccent', this.value)">
		          <option value="rose-gold">Rose Gold</option>
		          <option value="saffron">Saffron</option>
		          <option value="copper">Copper</option>
		          <option value="fig">Fig</option>
		          <option value="moss">Moss</option>
		        </select>
		      </div>
		      <div class="setting-row">
		        <label id="label-language">Language</label>
		        <select id="locale-select" onchange="updateSetting('locale', this.value)">
		          <option value="system">System</option>
		          <option value="en">English</option>
		          <option value="zh-CN">简体中文</option>
		        </select>
		      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span>Show cover header in reader</span>
	          <input type="checkbox" id="hero-cover-toggle" onchange="updateSetting('showHeroCover', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span id="label-show-first-completion-hall">Show first 100% in library cards</span>
	          <input type="checkbox" id="show-first-completion-hall-toggle" onchange="updateSetting('showFirstCompletionInHall', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label id="label-card-density">Card density</label>
	        <select id="card-density" onchange="updateSetting('cardDensity', this.value)">
	          <option value="comfortable" id="opt-card-density-comfortable">Comfortable</option>
	          <option value="dense" id="opt-card-density-dense">Dense</option>
	        </select>
	      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span>Collapse library sidebar</span>
	          <input type="checkbox" id="sidebar-collapsed-toggle" onchange="updateSetting('sidebarCollapsed', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label>PDF Zoom: <span id="pdf-zoom-val">120</span>%</label>
	        <input type="range" id="pdf-zoom" min="50" max="220" value="120" oninput="updateSetting('pdfZoom', +this.value)">
	      </div>
		      <div class="setting-row">
		        <label>Reader Width: <span id="reader-width-val">1600</span>px</label>
		        <input type="range" id="reader-width" min="520" max="2200" value="1600" oninput="updateSetting('readerMaxWidth', +this.value)">
		      </div>
	      <div class="setting-row">
	        <label>Reader Padding: <span id="reader-margin-val">48</span>px</label>
	        <input type="range" id="reader-margin" min="16" max="200" value="48" oninput="updateSetting('readerMargin', +this.value)">
	      </div>
	      <div class="setting-row">
	        <label>TOC Width: <span id="toc-width-val">300</span>px</label>
	        <input type="range" id="toc-width" min="240" max="520" value="300" oninput="updateSetting('tocWidth', +this.value)">
	      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span>Fit reader width</span>
	          <input type="checkbox" id="fit-reader-width-toggle" onchange="updateSetting('fitReaderWidth', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span>Show reader top bar</span>
	          <input type="checkbox" id="reader-topbar-toggle" onchange="updateSetting('readerTopBarVisible', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
	          <span>Selection Popup</span>
	          <input type="checkbox" id="selection-popup-toggle" onchange="updateSetting('selectionPopupEnabled', this.checked)">
	        </label>
	      </div>
	      <div class="setting-row">
	        <label style="display:block;margin-bottom:8px;font-weight:500;font-size:0.9rem;">TOC Hide Delay: <span id="toc-hide-delay-val">500</span>ms</label>
	        <input type="range" id="toc-hide-delay" min="200" max="2000" step="100" value="500" oninput="updateSetting('tocHideDelay', +this.value)">
	      </div>
      <div class="setting-row">
        <label>Reader Theme</label>
        <div class="reader-theme-presets" style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-bottom:12px;">
          <button class="reader-theme-btn" data-bg="#f8f1e3" data-text="#4f321c" onclick="setReaderTheme('#f8f1e3','#4f321c')" style="background:#f8f1e3;color:#4f321c;border:2px solid var(--border);border-radius:10px;padding:10px 8px;font-weight:600;font-size:0.8rem;cursor:pointer;transition:all 0.15s ease;">Warm</button>
          <button class="reader-theme-btn" data-bg="#fdfcfa" data-text="#37352f" onclick="setReaderTheme('#fdfcfa','#37352f')" style="background:#fdfcfa;color:#37352f;border:2px solid var(--border);border-radius:10px;padding:10px 8px;font-weight:600;font-size:0.8rem;cursor:pointer;transition:all 0.15s ease;">Cream</button>
          <button class="reader-theme-btn" data-bg="#f8f5f0" data-text="#4a4540" onclick="setReaderTheme('#f8f5f0','#4a4540')" style="background:#f8f5f0;color:#4a4540;border:2px solid var(--border);border-radius:10px;padding:10px 8px;font-weight:600;font-size:0.8rem;cursor:pointer;transition:all 0.15s ease;">Sepia</button>
          <button class="reader-theme-btn" data-bg="#e8e4dc" data-text="#3d3a36" onclick="setReaderTheme('#e8e4dc','#3d3a36')" style="background:#e8e4dc;color:#3d3a36;border:2px solid var(--border);border-radius:10px;padding:10px 8px;font-weight:600;font-size:0.8rem;cursor:pointer;transition:all 0.15s ease;">Paper</button>
          <button class="reader-theme-btn" data-bg="#1e1e1e" data-text="#e0e0e0" onclick="setReaderTheme('#1e1e1e','#e0e0e0')" style="background:#1e1e1e;color:#e0e0e0;border:2px solid var(--border);border-radius:10px;padding:10px 8px;font-weight:600;font-size:0.8rem;cursor:pointer;transition:all 0.15s ease;">Night</button>
        </div>
      </div>
      <div class="setting-row">
        <label>Background Color</label>
        <input type="color" id="bg-color" value="#fdfcfa" style="width:100%;height:38px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg);" oninput="updateSetting('bgColor', this.value)">
      </div>
      <div class="setting-row">
        <label>Text Color</label>
        <input type="color" id="text-color" value="#37352f" style="width:100%;height:38px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg);" oninput="updateSetting('textColor', this.value)">
      </div>
      <div class="setting-row">
        <label>App Background Image</label>
        <div class="theme-buttons">
          <button onclick="chooseAppBackgroundImage()">Choose Image</button>
          <button onclick="clearAppBackgroundImage()">Remove</button>
        </div>
        <div style="margin-top:10px;">
          <label style="display:block;margin-bottom:8px;font-weight:500;font-size:0.9rem;">Opacity: <span id="app-bg-opacity-val">0.14</span></label>
          <input type="range" id="app-bg-opacity" min="0" max="0.5" step="0.01" value="0.14" oninput="updateSetting('appBgOpacity', +this.value)">
        </div>
        <div style="margin-top:10px;">
          <label style="display:block;margin-bottom:8px;font-weight:500;font-size:0.9rem;">Blur: <span id="app-bg-blur-val">12</span>px</label>
          <input type="range" id="app-bg-blur" min="0" max="30" step="1" value="12" oninput="updateSetting('appBgBlur', +this.value)">
        </div>
      </div>
      <div class="setting-row">
        <label id="label-data-tools">Data</label>
        <div class="theme-buttons">
          <button onclick="exportAppData()">Export</button>
          <button onclick="importAppData()">Import</button>
        </div>
      </div>
      <div class="setting-row">
        <label id="label-merge-moved-books">Reading state recovery</label>
        <button id="btn-merge-moved-books" class="btn-secondary" style="width:100%;" onclick="mergeMovedBookStateNow()">Merge moved/duplicate books</button>
      </div>
      <button class="close-btn" onclick="hideSettings()">Close</button>
    </div>
  </div>

  <!-- Text Selection Popup -->
  <div id="search-popup" class="search-popup hidden"></div>

  <!-- Delete Book Modal -->
  <div id="delete-modal" class="modal hidden">
    <div class="modal-content delete-modal">
      <h3 id="delete-title">Delete book?</h3>
      <p>Choose how you want to remove this book:</p>
      <button onclick="deleteBook(false)">Remove from Library Only</button>
      <button class="danger" onclick="deleteBook(true)">Delete from Disk</button>
      <button onclick="hideDeleteModal()">Cancel</button>
    </div>
  </div>

  <!-- Create Library Modal -->
  <div id="create-library-modal" class="modal hidden">
    <div class="modal-content lib-modal">
      <h3>Create New Library</h3>
      <label style="display:block;margin-bottom:8px;font-weight:500;">Library Name</label>
      <input type="text" id="new-library-name" placeholder="My Library">
      <div class="btn-row">
        <button class="close-btn btn-secondary" onclick="hideCreateLibraryModal()">Cancel</button>
        <button class="close-btn" onclick="createEmptyLibrary()">Create Empty</button>
        <button class="close-btn" onclick="createLibraryFromDir()">Choose Folder</button>
      </div>
    </div>
  </div>

  <!-- Delete Library Modal -->
  <div id="delete-library-modal" class="modal hidden">
    <div class="modal-content delete-modal">
      <h3 id="delete-library-title">Delete library?</h3>
      <p>This will remove the library from RoseReader.</p>
      <button onclick="deleteLibrary('keep')">Remove from RoseReader (Keep Files)</button>
      <button class="danger" id="delete-library-dir-btn" onclick="deleteLibrary('dir')">Delete Folder from Disk</button>
      <button onclick="hideDeleteLibraryModal()">Cancel</button>
    </div>
  </div>

	  <!-- Move Book Modal -->
	  <div id="move-book-modal" class="modal hidden">
	    <div class="modal-content delete-modal">
	      <h3 id="move-book-title">Move book?</h3>
	      <p id="move-book-desc">Choose destination and whether to also move the file on disk:</p>
	      <select id="move-target-select" style="margin:10px 0;" onchange="if(pendingMove){pendingMove.targetNodeId=this.value}">
	      </select>
	      <button onclick="confirmMoveBook(false)">Move in Library Only</button>
	      <button class="danger" id="move-book-disk-btn" onclick="confirmMoveBook(true)">Move File on Disk Too</button>
	      <button onclick="hideMoveBookModal()">Cancel</button>
	    </div>
	  </div>

	  <!-- Note Modal -->
		  <div id="note-modal" class="modal hidden">
		    <div class="modal-content">
		      <h3 id="note-modal-title">Note</h3>
		      <p id="note-modal-sub" style="margin-top:-8px;margin-bottom:14px;">Add an annotation for this passage.</p>
		      <textarea id="note-text" rows="6" style="width:100%;padding:12px 12px;border:1px solid var(--hairline);border-radius:14px;background:var(--glass-strong);color:var(--text);font-size:0.95rem;resize:vertical;min-height:120px;"></textarea>
		      <div style="display:flex;gap:10px;margin-top:14px;">
		        <button class="btn-secondary" style="flex:1;" onclick="hideNoteModal()">Cancel</button>
		        <button class="close-btn" style="flex:1;" onclick="saveNoteModal()">Save</button>
		      </div>
		      <button id="note-delete-btn" class="close-btn btn-secondary" style="margin-top:10px;border-color:color-mix(in srgb, #dc2626 35%, var(--hairline));color:#dc2626;" onclick="deleteNoteModal()">Delete Note</button>
		    </div>
		  </div>

	  <!-- Insights Modal -->
	  <div id="insights-modal" class="modal hidden" onclick="if(event.target===this)hideInsights()">
	    <div class="modal-content" style="width: 820px; max-width: 94vw;">
	      <div style="display:flex; align-items:center; justify-content:space-between; gap: 14px;">
	        <h2 id="insights-title" style="margin-bottom:0;">Insights</h2>
	        <div style="display:flex;align-items:center;gap:8px;">
	          <button id="insights-share" class="btn-secondary" onclick="shareInsightsSnapshot()">Share snapshot</button>
	          <button id="insights-close" class="btn-secondary" onclick="hideInsights()">Close</button>
	        </div>
	      </div>
	      <div id="insights-body" style="margin-top: 14px;"></div>
	    </div>
	  </div>

	  <div id="context-menu" class="context-menu hidden"></div>
	  <div id="toast" class="toast hidden"></div>

  <script>
    const { ipcRenderer } = require('electron');
    const path = require('path');
    const { pathToFileURL } = require('url');

		    const els = {
	      toast: document.getElementById('toast'),
	      searchOverlay: document.getElementById('search-overlay'),
	      libraryView: document.getElementById('library-view'),
	      readerView: document.getElementById('reader-view'),
	      librarySearch: document.getElementById('library-search'),
	      librarySearchTrigger: document.getElementById('library-search-trigger'),
	      librarySearchInput: document.getElementById('library-search-input'),
	      librarySearchClear: document.getElementById('library-search-clear'),
	      librarySearchPopover: document.getElementById('library-search-popover'),
	      librarySearchList: document.getElementById('library-search-list'),
	      librarySearchKbd: document.getElementById('library-search-kbd'),
	      libraryList: document.getElementById('library-list'),
	      emptyMsg: document.getElementById('empty-msg'),
	      booksContainer: document.getElementById('books-container'),
      booksGrid: document.getElementById('books-grid'),
      booksCount: document.getElementById('books-count'),
      booksHeaderTitle: document.getElementById('books-header-title'),
	      recentSection: document.getElementById('recent-section'),
	      recentBooks: document.getElementById('recent-books'),
	      statBooksRead: document.getElementById('stat-books-read'),
	      statReadTime: document.getElementById('stat-read-time'),
	      statStreak: document.getElementById('stat-streak'),
	      statLastRead: document.getElementById('stat-last-read'),
	      statBooksTouched30d: document.getElementById('stat-books-touched-30d'),
	      btnInsights: document.getElementById('btn-insights'),
	      insightsShare: document.getElementById('insights-share'),
	      insightsModal: document.getElementById('insights-modal'),
	      insightsBody: document.getElementById('insights-body'),
      folderTree: document.getElementById('folder-tree'),
      sidebarTitle: document.getElementById('sidebar-title'),
      tabLibraries: document.getElementById('tab-libraries'),
      tabFolders: document.getElementById('tab-folders'),
      sidebarAddLibrary: document.getElementById('sidebar-add-library'),
      sidebarAddFolder: document.getElementById('sidebar-add-folder'),

      createLibraryModal: document.getElementById('create-library-modal'),
      newLibraryName: document.getElementById('new-library-name'),
      deleteModal: document.getElementById('delete-modal'),
      deleteTitle: document.getElementById('delete-title'),
      deleteLibraryModal: document.getElementById('delete-library-modal'),
      deleteLibraryTitle: document.getElementById('delete-library-title'),
      deleteLibraryDirBtn: document.getElementById('delete-library-dir-btn'),
      moveBookModal: document.getElementById('move-book-modal'),
      moveBookTitle: document.getElementById('move-book-title'),
      moveBookDesc: document.getElementById('move-book-desc'),
      moveBookDiskBtn: document.getElementById('move-book-disk-btn'),
      moveTargetSelect: document.getElementById('move-target-select'),
      contextMenu: document.getElementById('context-menu'),

      readerContent: document.getElementById('reader-content'),
      currentBookTitle: document.getElementById('current-book-title'),
      bookSearch: document.getElementById('book-search'),
      searchNav: document.getElementById('search-nav'),
      searchPosition: document.getElementById('search-position'),
	      searchResultsPanel: document.getElementById('search-results-panel'),

      tocSidebar: document.getElementById('toc-sidebar'),
      tocList: document.getElementById('toc-list'),
      bookmarksSidebar: document.getElementById('bookmarks-sidebar'),
      bookmarksList: document.getElementById('bookmarks-list'),
      readerHeader: document.querySelector('#reader-view header.reader-header')
    };

    const defaultEmptyHtml = els.emptyMsg ? els.emptyMsg.innerHTML : '';

	    let state = {
	      libraries: [],
	      booksById: {},
	      settings: {},
	      stats: {},
	      analytics: {}
	    };
    let settings = {};

    let selectedLibraryId = 'all';
    let selectedFolderNodeId = '__ALL__';
    const expandedFolderIds = new Set();
    let libraryQuery = '';

    let currentBook = null;
    let deleteTargetBookId = null;
    let deleteTargetLibraryId = null;
    let pendingMove = null;
    let draggingBookId = null;
    const coverUrlCache = new Map();
    let navigation = { stack: [{ view: 'library' }], index: 0 };
    let lastOpenedBookId = null;

    ipcRenderer.on('libraries-auto-refreshed', async (_, payload = {}) => {
      await refreshState();
      renderLibraries();
      renderStats();
      renderBooks();
      if (payload?.silent) return;
      showToast('Libraries synced automatically', 'success');
    });

	    // PDF.js state
	    let pdfDoc = null;
	    let pdfRenderedPages = new Map();
	    let pdfObserver = null;
	    let pdfjsLib = null;
	    let pdfPageViewports = new Map();
	    let pdfPageTextItems = new Map();
	    let pdfPageDataPromises = new Map();

    const readerWaypointState = {
      waypoints: [],
      cursor: -1,
      jumpToken: 0,
      activeJumpToken: 0
    };

    const readerWaypointConfig = {
      maxWaypoints: 80,
      minDistancePx: 64,
      settleMs: 480
    };

    function canTrackReaderWaypoint() {
      return !!(currentBook && els.readerContent);
    }

    function getReaderWaypointTop() {
      if (!els.readerContent) return 0;
      return Math.max(0, Math.round(els.readerContent.scrollTop));
    }

    function trimReaderWaypointOverflow() {
      const overflow = readerWaypointState.waypoints.length - readerWaypointConfig.maxWaypoints;
      if (overflow <= 0) return;
      readerWaypointState.waypoints.splice(0, overflow);
      readerWaypointState.cursor = Math.max(-1, readerWaypointState.cursor - overflow);
    }

    function trimReaderForwardWaypoints() {
      if (readerWaypointState.cursor < 0) {
        readerWaypointState.waypoints = [];
        return;
      }
      if (readerWaypointState.cursor >= readerWaypointState.waypoints.length - 1) return;
      readerWaypointState.waypoints = readerWaypointState.waypoints.slice(0, readerWaypointState.cursor + 1);
    }

    function pushReaderWaypoint(top, { force = false } = {}) {
      if (!canTrackReaderWaypoint()) return false;

      const boundedTop = Math.max(0, Math.round(top));
      const last = readerWaypointState.waypoints[readerWaypointState.waypoints.length - 1];
      if (last && last.bookId === currentBook.id) {
        const delta = Math.abs(last.top - boundedTop);
        if (delta < readerWaypointConfig.minDistancePx && !force) return false;
        if (delta === 0) return false;
      }

      readerWaypointState.waypoints.push({
        bookId: currentBook.id,
        top: boundedTop,
        capturedAt: Date.now()
      });
      trimReaderWaypointOverflow();
      readerWaypointState.cursor = readerWaypointState.waypoints.length - 1;
      return true;
    }

    function snapshotReaderWaypoint({ force = false } = {}) {
      if (!canTrackReaderWaypoint()) return false;
      trimReaderForwardWaypoints();
      return pushReaderWaypoint(getReaderWaypointTop(), { force });
    }

    function jumpToReaderWaypoint(index) {
      if (!canTrackReaderWaypoint()) return false;
      if (index < 0 || index >= readerWaypointState.waypoints.length) return false;

      const waypoint = readerWaypointState.waypoints[index];
      if (!waypoint || waypoint.bookId !== currentBook.id) return false;

      const container = els.readerContent;
      const maxTop = Math.max(0, container.scrollHeight - container.clientHeight);
      const targetTop = Math.max(0, Math.min(maxTop, waypoint.top));

      readerWaypointState.cursor = index;
      readerWaypointState.jumpToken += 1;
      const token = readerWaypointState.jumpToken;
      readerWaypointState.activeJumpToken = token;

      container.scrollTo({ top: targetTop, behavior: 'smooth' });
      setTimeout(() => {
        if (readerWaypointState.activeJumpToken === token) {
          readerWaypointState.activeJumpToken = 0;
        }
      }, readerWaypointConfig.settleMs);

      return true;
    }

    function recordReaderPosition() {
      if (!canTrackReaderWaypoint()) return;
      if (readerWaypointState.activeJumpToken) return;
      snapshotReaderWaypoint();
    }

    function navigateReaderBack() {
      if (!canTrackReaderWaypoint()) return false;
      if (readerWaypointState.waypoints.length === 0) return false;

      const atEnd = readerWaypointState.cursor === readerWaypointState.waypoints.length - 1;
      if (atEnd) {
        snapshotReaderWaypoint({ force: true });
      }

      const targetIndex = readerWaypointState.cursor - 1;
      if (targetIndex < 0) return false;
      return jumpToReaderWaypoint(targetIndex);
    }

    function navigateReaderForward() {
      if (!canTrackReaderWaypoint()) return false;
      if (readerWaypointState.waypoints.length === 0) return false;

      const targetIndex = readerWaypointState.cursor + 1;
      if (targetIndex >= readerWaypointState.waypoints.length) return false;
      return jumpToReaderWaypoint(targetIndex);
    }

    function clearReaderHistory() {
      readerWaypointState.waypoints = [];
      readerWaypointState.cursor = -1;
      readerWaypointState.jumpToken = 0;
      readerWaypointState.activeJumpToken = 0;
    }

    async function initPdfJs() {
      if (pdfjsLib) return pdfjsLib;
      pdfjsLib = require('pdfjs-dist');
      pdfjsLib.GlobalWorkerOptions.workerSrc = require.resolve('pdfjs-dist/build/pdf.worker.min.mjs');
      return pdfjsLib;
    }

    // Parse hex color to RGB
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : { r: 255, g: 255, b: 255 };
    }

    // Recolor canvas pixels - replace white with bgColor, black with textColor
    // Preserves colorful pixels (images) by checking saturation
    // preserveImages: if true, uses a smarter algorithm to preserve colorful images while still theming text
    function recolorCanvas(ctx, width, height, bgColor, textColor, preserveImages = false) {
      const bg = hexToRgb(bgColor);
      const fg = hexToRgb(textColor);
      const imageData = ctx.getImageData(0, 0, width, height);
      const data = imageData.data;

      // Saturation threshold - pixels with saturation above this are considered "colorful" (images)
      const saturationThreshold = preserveImages ? 0.15 : 0.12;

      for (let i = 0; i < data.length; i += 4) {
        const r = data[i], g = data[i + 1], b = data[i + 2];

        // Calculate saturation to detect colorful pixels (images)
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const saturation = max === 0 ? 0 : (max - min) / max;

        // If pixel is colorful (part of an image), preserve it
        if (saturation > saturationThreshold) {
          continue;
        }

        // Calculate luminance (0 = black, 255 = white)
        const lum = (r * 0.299 + g * 0.587 + b * 0.114);

        // Interpolate between text color (dark) and bg color (light)
        // This handles anti-aliased text edges properly
        const t = lum / 255;
        data[i] = Math.round(fg.r * (1 - t) + bg.r * t);
        data[i + 1] = Math.round(fg.g * (1 - t) + bg.g * t);
        data[i + 2] = Math.round(fg.b * (1 - t) + bg.b * t);
      }

      ctx.putImageData(imageData, 0, 0);
    }

	    async function renderPdfBook(pdfData) {
	      await initPdfJs();
	      pdfPageViewports.clear();
	      pdfPageTextItems.clear();
	      pdfPageDataPromises.clear();
	      const data = Uint8Array.from(atob(pdfData), c => c.charCodeAt(0));
	      pdfDoc = await pdfjsLib.getDocument({ data }).promise;
	      pdfRenderedPages.clear();

      // Extract TOC/Outline
      try {
        const outline = await pdfDoc.getOutline();
        if (outline && outline.length > 0) {
          currentToc = await buildPdfToc(outline);
          renderToc();
        }
      } catch (e) {
        console.warn('Failed to extract PDF outline:', e);
      }
      if (!currentToc.length) {
        renderToc();
      }

      const container = els.readerContent.querySelector('.reader-scroll-body');
      container.innerHTML = '';

      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const pageDiv = document.createElement('div');
        pageDiv.className = 'pdf-page';
        pageDiv.dataset.pageNum = i;
        pageDiv.id = `pdf-page-${i}`;
        container.appendChild(pageDiv);
      }

      observePdfPages();
    }

    async function buildPdfToc(outline, level = 0) {
      const items = [];
      for (const item of outline) {
        let pageNum = 1;
        let dest = null;
        if (item.dest) {
          try {
            dest = typeof item.dest === 'string'
              ? await pdfDoc.getDestination(item.dest)
              : item.dest;
            if (dest) {
              const pageIndex = await pdfDoc.getPageIndex(dest[0]);
              pageNum = pageIndex + 1;
            }
          } catch (e) {}
        }
        const tocItem = {
          title: item.title,
          href: `#pdf-page-${pageNum}`,
          level,
          pageNum,
          pdfDest: dest // Store the full destination for precise navigation
        };
        items.push(tocItem);
        if (item.items && item.items.length > 0) {
          const children = await buildPdfToc(item.items, level + 1);
          items.push(...children);
        }
      }
      return items;
    }

    async function renderPdfPage(pageNum, container) {
      if (!pdfDoc) return;
      try {
        const page = await pdfDoc.getPage(pageNum);
        const scale = (settings.pdfZoom || 120) / 100;
	        const viewport = page.getViewport({ scale });
	        pdfPageViewports.set(pageNum, viewport);
        const outputScale = window.devicePixelRatio || 1;

        // Create container for canvas + text layer + annotation layer
        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.style.width = Math.floor(viewport.width) + 'px';
        pageContainer.style.height = Math.floor(viewport.height) + 'px';

        // Canvas for rendering
        const canvas = document.createElement('canvas');
        canvas.width = Math.floor(viewport.width * outputScale);
        canvas.height = Math.floor(viewport.height * outputScale);
        canvas.style.width = Math.floor(viewport.width) + 'px';
        canvas.style.height = Math.floor(viewport.height) + 'px';

        const ctx = canvas.getContext('2d');
        const transform = outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null;

        // Render PDF page normally first
        await page.render({
          canvasContext: ctx,
          viewport,
          transform,
          background: 'white'
        }).promise;

        // Recolor the canvas to match theme
        const bgColor = settings.bgColor || '#f8f1e3';
        const textColor = settings.textColor || '#4f321c';
        const preserveImages = settings.theme === 'midnight';
	        recolorCanvas(ctx, canvas.width, canvas.height, bgColor, textColor, preserveImages);

	        pageContainer.appendChild(canvas);

	        // Layer for persistent highlights (rect overlays)
	        const highlightLayer = document.createElement('div');
	        highlightLayer.className = 'highlightLayer';
	        pageContainer.appendChild(highlightLayer);

	        // Text layer for selection
	        const textLayer = document.createElement('div');
	        textLayer.className = 'textLayer';
	        const textContent = await page.getTextContent();
	        pdfPageTextItems.set(pageNum, textContent?.items || []);

        textContent.items.forEach(item => {
          const span = document.createElement('span');
          span.textContent = item.str;

          const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
          const angle = Math.atan2(tx[1], tx[0]);

          span.style.left = tx[4] + 'px';
          span.style.top = (tx[5] - fontHeight) + 'px';
          span.style.fontSize = fontHeight + 'px';
          span.style.fontFamily = item.fontName || 'sans-serif';

          if (angle !== 0) {
            span.style.transform = `rotate(${angle}rad)`;
          }

          if (item.width > 0) {
            const textWidth = span.offsetWidth || (item.str.length * fontHeight * 0.5);
            const scaleX = (item.width * scale) / textWidth;
            if (Math.abs(scaleX - 1) > 0.01) {
              span.style.transform = (span.style.transform || '') + ` scaleX(${scaleX})`;
            }
          }

          textLayer.appendChild(span);
        });

        pageContainer.appendChild(textLayer);

        // Annotation layer for links
        const annotationLayer = document.createElement('div');
        annotationLayer.className = 'annotationLayer';

        const annotations = await page.getAnnotations();
        for (const annotation of annotations) {
          if (annotation.subtype === 'Link') {
            const section = document.createElement('section');
            section.className = 'linkAnnotation';

            const rect = annotation.rect;
            const [x1, y1, x2, y2] = pdfjsLib.Util.normalizeRect(
              viewport.convertToViewportRectangle(rect)
            );

            section.style.left = Math.floor(x1) + 'px';
            section.style.top = Math.floor(y1) + 'px';
            section.style.width = Math.ceil(x2 - x1) + 'px';
            section.style.height = Math.ceil(y2 - y1) + 'px';

            const link = document.createElement('a');

            if (annotation.url) {
              // External link
              link.href = annotation.url;
              link.target = '_blank';
              link.rel = 'noopener noreferrer';
            } else if (annotation.dest) {
              // Internal link
              link.href = '#';
              link.dataset.dest = typeof annotation.dest === 'string'
                ? annotation.dest
                : JSON.stringify(annotation.dest);
              link.addEventListener('click', async (e) => {
                e.preventDefault();
                await navigateToPdfDest(annotation.dest);
              });
            }

            section.appendChild(link);
            annotationLayer.appendChild(section);
          }
        }

        pageContainer.appendChild(annotationLayer);

	        container.innerHTML = '';
	        container.appendChild(pageContainer);

	        // Apply existing highlights for this page
	        applyPdfHighlights(pageNum, textLayer);

	        // Enable clicking existing highlight rectangles to edit/remove
	        attachPdfHighlightClickHandler(pageNum, pageContainer);

	        // If there's an active in-book search, apply search highlights to this newly rendered page.
	        if (currentBook?.format === 'pdf' && bookSearchState?.query) {
	          applyPdfSearchHighlightsOnPage(container.closest('.pdf-page') || container, bookSearchState.query, bookSearchState.currentIndex);
	        }

        scheduleTocHighlightUpdate();
	      } catch (e) {
	        console.error('PDF page render error:', e);
	      }
	    }

    // Navigate to PDF destination (internal link or TOC)
    async function navigateToPdfDest(dest) {
      if (!pdfDoc) return;

      // Record current position before navigating
      recordReaderPosition();

      try {
        let resolvedDest = dest;
        if (typeof dest === 'string') {
          resolvedDest = await pdfDoc.getDestination(dest);
        }
        if (!resolvedDest) return;

        const pageIndex = await pdfDoc.getPageIndex(resolvedDest[0]);
        const pageNum = pageIndex + 1;
        const pageEl = document.getElementById(`pdf-page-${pageNum}`);

        if (pageEl) {
          // Ensure page is rendered
          if (!pdfRenderedPages.has(pageNum)) {
            pdfRenderedPages.set(pageNum, true);
            await renderPdfPage(pageNum, pageEl);
          }

          // Get the destination type and coordinates
          // Format: [pageRef, /XYZ, left, top, zoom] or [pageRef, /FitH, top] etc.
          const destType = resolvedDest[1]?.name || resolvedDest[1];
          let yOffset = 0;

          const page = await pdfDoc.getPage(pageNum);
          const scale = (settings.pdfZoom || 120) / 100;
          const viewport = page.getViewport({ scale });

          if (destType === 'XYZ' && resolvedDest[3] !== null) {
            // XYZ destination with top coordinate
            // PDF Y is from bottom, viewport Y is from top
            yOffset = viewport.height - (resolvedDest[3] * scale);
          } else if (destType === 'FitH' && resolvedDest[2] !== null) {
            yOffset = viewport.height - (resolvedDest[2] * scale);
          }

          // First scroll to bring page into view
          pageEl.scrollIntoView({ behavior: 'instant', block: 'start' });

          // Wait a frame for layout to settle
          await new Promise(r => requestAnimationFrame(r));

          // Now calculate precise scroll position
          const container = els.readerContent;
          const pageRect = pageEl.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          const targetY = container.scrollTop + pageRect.top - containerRect.top + Math.max(0, yOffset) - 50;

          container.scrollTo({ top: targetY, behavior: 'smooth' });

          // Show indicator after scroll completes
          setTimeout(() => {
            flashPdfLocation(pageEl, yOffset);
          }, 400);
        }
      } catch (e) {
        console.error('PDF navigation error:', e);
      }
    }

    // Flash a location indicator on PDF page
    function flashPdfLocation(pageEl, yOffset) {
      const container = pageEl.querySelector('.pdf-page-container');
      if (!container) return;

      // Remove existing indicators
      document.querySelectorAll('.pdf-location-indicator').forEach(el => el.remove());

      // Create a more prominent indicator - a pulsing highlight bar with arrow
      const indicator = document.createElement('div');
      indicator.className = 'pdf-location-indicator';
      indicator.innerHTML = `
        <div class="pdf-indicator-arrow">▶</div>
        <div class="pdf-indicator-bar"></div>
      `;
      indicator.style.cssText = `
        position: absolute;
        left: -30px;
        right: 0;
        top: ${Math.max(0, yOffset - 15)}px;
        height: 30px;
        pointer-events: none;
        z-index: 100;
        display: flex;
        align-items: center;
      `;
      container.appendChild(indicator);

      setTimeout(() => indicator.remove(), 1200);
    }

    // Scroll to a PDF highlight and flash it
	    async function scrollToPdfHighlight(highlight) {
	      const pageNum = highlight.pageNum;
	      const pageEl = document.getElementById(`pdf-page-${pageNum}`);
	      if (!pageEl) return;

      // Ensure page is rendered
      if (!pdfRenderedPages.has(pageNum)) {
        pdfRenderedPages.set(pageNum, true);
        await renderPdfPage(pageNum, pageEl);
      }

	      // Find the highlighted spans
	      const textLayer = pageEl.querySelector('.textLayer');
	      if (!textLayer) return;

	      const highlightRects = pageEl.querySelectorAll(`.pdf-highlight-rect[data-highlight-id="${cssEscape(highlight.id)}"]`);
	      const highlightSpans = textLayer.querySelectorAll(`span[data-highlight-id="${highlight.id}"]`);
	      const targets = highlightRects.length ? [...highlightRects] : [...highlightSpans];
	      if (targets.length === 0) {
	        // Fallback: scroll to page
	        pageEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
	        return;
	      }

	      // Scroll to first highlighted element
	      const firstEl = targets[0];
	      firstEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

      // Flash all highlighted spans
      const colorMap = {
        yellow: '#ffd600', green: '#00e676', blue: '#2196f3',
        pink: '#ff4081', purple: '#e040fb', orange: '#ff9100'
      };
      const flashColor = colorMap[highlight.color] || '#ffd600';

	      targets.forEach(el => {
	        el.style.setProperty('--hl-flash-color', flashColor);
	        el.classList.remove('highlight-flash');
	        void el.offsetWidth; // Force reflow
	        el.classList.add('highlight-flash');
	      });

	      setTimeout(() => {
	        targets.forEach(el => el.classList.remove('highlight-flash'));
	      }, 1500);
	    }

	    function mergeRectsPx(rects, eps = 2) {
	      const out = [];
	      const sorted = (rects || []).slice().sort((a, b) => (a.top - b.top) || (a.left - b.left));
	      for (const r of sorted) {
	        const w = r.right - r.left;
	        const h = r.bottom - r.top;
	        if (w < 1 || h < 1) continue;
	        const last = out[out.length - 1];
	        const sameLine = last && Math.abs(r.top - last.top) <= eps && Math.abs(r.bottom - last.bottom) <= eps;
	        const touching = last && r.left <= last.right + eps;
	        if (last && sameLine && touching) {
	          last.left = Math.min(last.left, r.left);
	          last.right = Math.max(last.right, r.right);
	          last.top = Math.min(last.top, r.top);
	          last.bottom = Math.max(last.bottom, r.bottom);
	        } else {
	          out.push({ left: r.left, top: r.top, right: r.right, bottom: r.bottom });
	        }
	      }
	      return out;
	    }

	    function clientRectsToNormalizedRects(pageContainer, clientRects) {
	      if (!pageContainer) return [];
	      const pageRect = pageContainer.getBoundingClientRect();
	      if (!pageRect.width || !pageRect.height) return [];

	      const rectsPx = Array.from(clientRects || []).map(r => {
	        const left = Math.max(0, r.left - pageRect.left);
	        const top = Math.max(0, r.top - pageRect.top);
	        const right = Math.min(pageRect.width, r.right - pageRect.left);
	        const bottom = Math.min(pageRect.height, r.bottom - pageRect.top);
	        return { left, top, right, bottom };
	      }).filter(r => (r.right - r.left) > 1 && (r.bottom - r.top) > 1);

	      const mergedPx = mergeRectsPx(rectsPx, 2);
	      return mergedPx.map(r => ({
	        x: r.left / pageRect.width,
	        y: r.top / pageRect.height,
	        w: (r.right - r.left) / pageRect.width,
	        h: (r.bottom - r.top) / pageRect.height
	      })).filter(r => r.w > 0.001 && r.h > 0.001);
	    }

	    function attachPdfHighlightClickHandler(pageNum, pageContainer) {
	      if (!pageContainer || pageContainer._pdfHlClickAttached) return;
	      pageContainer._pdfHlClickAttached = true;

	      pageContainer.addEventListener('click', (e) => {
	        try {
	          if (!currentBook || currentBook.format !== 'pdf') return;
	          if (e.target?.closest?.('.annotationLayer a')) return;
	          const sel = window.getSelection();
	          if (sel && String(sel.toString() || '').trim()) return;

	          const pageRect = pageContainer.getBoundingClientRect();
	          const x = e.clientX - pageRect.left;
	          const y = e.clientY - pageRect.top;
	          if (x < 0 || y < 0 || x > pageRect.width || y > pageRect.height) return;

	          const candidates = (currentHighlights || []).filter(h =>
	            h && h.pageNum === pageNum && Array.isArray(h.rects) && h.rects.length
	          );

	          const tol = 2;
	          let best = null;
	          let bestArea = Infinity;
	          for (const h of candidates) {
	            for (const r of h.rects) {
	              const left = r.x * pageRect.width;
	              const top = r.y * pageRect.height;
	              const right = (r.x + r.w) * pageRect.width;
	              const bottom = (r.y + r.h) * pageRect.height;
	              if (x >= left - tol && x <= right + tol && y >= top - tol && y <= bottom + tol) {
	                const area = Math.max(1, (right - left) * (bottom - top));
	                if (area < bestArea) {
	                  best = h;
	                  bestArea = area;
	                }
	              }
	            }
	          }

	          if (!best) return;
	          e.stopPropagation();

	          const anchorEl =
	            pageContainer.querySelector(`.pdf-highlight-rect[data-highlight-id="${cssEscape(best.id)}"]`) ||
	            pageContainer.querySelector(`span[data-highlight-id="${cssEscape(best.id)}"]`);

	          showPdfHighlightPopup(best, anchorEl || {
	            left: e.clientX,
	            right: e.clientX,
	            top: e.clientY,
	            bottom: e.clientY,
	            width: 0,
	            height: 0
	          });
	        } catch (err) {
	          console.warn('PDF highlight click handler error:', err);
	        }
	      });
	    }

	    // Apply highlights to PDF text layer
	    function applyPdfHighlights(pageNum, textLayer) {
	      if (!currentBook || !currentHighlights) return;

	      const pageHighlights = currentHighlights.filter(h => h.pageNum === pageNum);
	      const pageContainer = textLayer?.closest?.('.pdf-page-container') || textLayer?.parentElement;
	      let highlightLayer = pageContainer?.querySelector?.('.highlightLayer') || null;
	      if (!highlightLayer && pageContainer) {
	        highlightLayer = document.createElement('div');
	        highlightLayer.className = 'highlightLayer';
	        pageContainer.insertBefore(highlightLayer, textLayer);
	      }
	      if (highlightLayer) highlightLayer.innerHTML = '';

	      // Color map for highlight colors
	      const colorBgs = {
	        yellow: 'rgba(255, 235, 59, 0.5)',
	        green: 'rgba(0, 230, 118, 0.5)',
        blue: 'rgba(33, 150, 243, 0.5)',
        pink: 'rgba(255, 64, 129, 0.5)',
        purple: 'rgba(224, 64, 251, 0.5)',
        orange: 'rgba(255, 145, 0, 0.5)'
      };

      const spans = Array.from(textLayer.querySelectorAll('span'));

      // First, reset all spans
      spans.forEach(span => {
        span.classList.remove('highlight');
        span.style.backgroundColor = '';
        span.style.cursor = '';
        delete span.dataset.highlightId;
        delete span.dataset.color;
        span.onclick = null;
      });

      if (pageHighlights.length === 0) return;

	      // Apply each highlight
	      pageHighlights.forEach(highlight => {
	        // New format: store selection rects (normalized) for accurate highlights
	        if (highlightLayer && Array.isArray(highlight.rects) && highlight.rects.length) {
	          const bgColor = colorBgs[highlight.color] || colorBgs.yellow;
	          highlight.rects.forEach((r) => {
	            if (!r) return;
	            const x = Math.max(0, Math.min(1, r.x || 0));
	            const y = Math.max(0, Math.min(1, r.y || 0));
	            const w = Math.max(0, Math.min(1 - x, r.w || 0));
	            const h = Math.max(0, Math.min(1 - y, r.h || 0));
	            if (w < 0.001 || h < 0.001) return;
	            const el = document.createElement('div');
	            el.className = 'pdf-highlight-rect';
	            el.dataset.highlightId = highlight.id;
	            el.dataset.color = highlight.color || 'yellow';
	            el.style.left = `${(x * 100).toFixed(4)}%`;
	            el.style.top = `${(y * 100).toFixed(4)}%`;
	            el.style.width = `${(w * 100).toFixed(4)}%`;
	            el.style.height = `${(h * 100).toFixed(4)}%`;
	            el.style.backgroundColor = bgColor;
	            highlightLayer.appendChild(el);
	          });
	          return;
	        }

	        let indicesToHighlight = [];

	        // Use exact spanIndices if available (new format)
	        if (highlight.spanIndices && Array.isArray(highlight.spanIndices)) {
	          indicesToHighlight = highlight.spanIndices;
        }
        // Fallback for old highlights using start/end range
        else if (highlight.startSpanIndex !== undefined && highlight.endSpanIndex !== undefined) {
          for (let i = highlight.startSpanIndex; i <= highlight.endSpanIndex; i++) {
            indicesToHighlight.push(i);
          }
        }
        // Fallback for old highlights using offsets
        else if (highlight.startOffset !== undefined) {
          let charCount = 0;
          let startIdx, endIdx;
          for (let i = 0; i < spans.length; i++) {
            const spanEnd = charCount + spans[i].textContent.length;
            if (startIdx === undefined && highlight.startOffset < spanEnd) {
              startIdx = i;
            }
            if (highlight.endOffset <= spanEnd) {
              endIdx = i;
              break;
            }
            charCount = spanEnd;
          }
          if (startIdx !== undefined && endIdx !== undefined) {
            for (let i = startIdx; i <= endIdx; i++) {
              indicesToHighlight.push(i);
            }
          }
        }
        // Fallback: text matching
        else if (highlight.text) {
          const hlText = highlight.text.trim().toLowerCase();
          for (let i = 0; i < spans.length; i++) {
            const spanText = spans[i].textContent.trim().toLowerCase();
            if (spanText && hlText.includes(spanText)) {
              indicesToHighlight.push(i);
            }
          }
        }

        if (indicesToHighlight.length === 0) return;

        // Apply highlight to exact spans only
        indicesToHighlight.forEach(i => {
          if (i >= 0 && i < spans.length) {
            const span = spans[i];
            span.classList.add('highlight');
            const bgColor = colorBgs[highlight.color] || colorBgs.yellow;
            span.style.backgroundColor = bgColor;
            span.style.cursor = 'pointer';
            span.dataset.highlightId = highlight.id;
            span.dataset.color = highlight.color || 'yellow';

            // Add click handler
            span.onclick = (e) => {
              e.stopPropagation();
              showPdfHighlightPopup(highlight, span);
            };
          }
        });
      });
	    }

	    async function getPdfPageData(pageNum) {
	      if (!pdfDoc || !pageNum) return null;
	      if (pdfPageTextItems.has(pageNum) && pdfPageViewports.has(pageNum)) {
	        return { items: pdfPageTextItems.get(pageNum), viewport: pdfPageViewports.get(pageNum) };
	      }
	      if (pdfPageDataPromises.has(pageNum)) return pdfPageDataPromises.get(pageNum);
	      const promise = (async () => {
	        const page = await pdfDoc.getPage(pageNum);
	        const scale = (settings.pdfZoom || 120) / 100;
	        const viewport = page.getViewport({ scale });
	        pdfPageViewports.set(pageNum, viewport);
	        let items = pdfPageTextItems.get(pageNum);
        if (!items) {
          const textContent = await page.getTextContent();
          items = Array.isArray(textContent?.items) ? textContent.items : [];
          pdfPageTextItems.set(pageNum, items);
        }
	        return { items, viewport };
	      })();
	      pdfPageDataPromises.set(pageNum, promise);
	      try {
	        return await promise;
	      } finally {
	        pdfPageDataPromises.delete(pageNum);
	      }
	    }

	    // Show popup for PDF highlight with options to change color or remove
	    function showPdfHighlightPopup(highlight, anchorElOrRect) {
	      const popup = document.getElementById('search-popup');
	      if (!popup) return;

      popup.innerHTML = '';

      // Color picker row
      const hlRow = document.createElement('div');
      hlRow.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px 14px;';
      const hlLabel = document.createElement('span');
      hlLabel.textContent = 'Color:';
      hlLabel.style.cssText = 'font-size:0.85rem;color:var(--text-secondary);margin-right:4px;';
      hlRow.appendChild(hlLabel);

      const colors = [
        { name: 'yellow', bg: '#FFEB3B' },
        { name: 'green', bg: '#4CAF50' },
        { name: 'blue', bg: '#2196F3' },
        { name: 'pink', bg: '#E91E63' },
        { name: 'purple', bg: '#9C27B0' },
        { name: 'orange', bg: '#FF9800' }
      ];

      colors.forEach(c => {
        const colorBtn = document.createElement('button');
        colorBtn.style.cssText = `width:22px;height:22px;border-radius:50%;border:2px solid ${c.name === highlight.color ? 'var(--text)' : 'transparent'};background:${c.bg};cursor:pointer;padding:0;`;
        colorBtn.title = c.name;
        colorBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await updatePdfHighlightColor(highlight.id, c.name);
          hideSelectionPopup();
        });
        hlRow.appendChild(colorBtn);
      });
      popup.appendChild(hlRow);

      // Remove button
      const removeBtn = document.createElement('button');
      removeBtn.textContent = 'Remove highlight';
      removeBtn.style.cssText = 'display:block;width:100%;padding:10px 14px;border:none;background:transparent;cursor:pointer;text-align:left;border-radius:12px;font-size:0.9rem;font-weight:650;color:var(--text);border-top:1px solid var(--border);';
      removeBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await removeHighlights([highlight.id]);
        hideSelectionPopup();
      });
	      popup.appendChild(removeBtn);

	      // Position popup
	      const rect = (anchorElOrRect && typeof anchorElOrRect.getBoundingClientRect === 'function')
	        ? anchorElOrRect.getBoundingClientRect()
	        : anchorElOrRect;
	      if (!rect) return;
	      popup.classList.remove('hidden');
	      popup.style.left = '-9999px';
	      popup.style.top = '-9999px';
	      const w = popup.offsetWidth || 220;
	      const h = popup.offsetHeight || 100;
      const x = Math.min(window.innerWidth - w - 10, Math.max(10, rect.left));
      const y = Math.min(window.innerHeight - h - 10, Math.max(10, rect.bottom + 8));
      popup.style.left = `${x}px`;
      popup.style.top = `${y}px`;
    }

    // Update PDF highlight color
    async function updatePdfHighlightColor(highlightId, color) {
      if (!currentBook) return;
      const highlight = currentHighlights.find(h => h.id === highlightId);
      if (!highlight) return;

      await ipcRenderer.invoke('update-highlight-color', currentBook.id, highlightId, color);
      const idx = currentHighlights.findIndex(x => x.id === highlightId);
      if (idx >= 0) currentHighlights[idx].color = color;

      if (highlight.pageNum) {
        updatePdfPageHighlights(highlight.pageNum);
      }
      await refreshBookmarksAndHighlights();
    }

    // Update highlights on a specific page without re-rendering
    function updatePdfPageHighlights(pageNum) {
      const pageEl = document.getElementById(`pdf-page-${pageNum}`);
      if (!pageEl) return;
      const textLayer = pageEl.querySelector('.textLayer');
      if (!textLayer) return;
      applyPdfHighlights(pageNum, textLayer);
    }

    function observePdfPages() {
      if (pdfObserver) pdfObserver.disconnect();
      pdfObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const pageNum = parseInt(entry.target.dataset.pageNum);
            if (!pdfRenderedPages.has(pageNum)) {
              pdfRenderedPages.set(pageNum, true);
              renderPdfPage(pageNum, entry.target);
            }
          }
        });
      }, { rootMargin: '300px' });

      document.querySelectorAll('.pdf-page').forEach(el => pdfObserver.observe(el));
    }

	    function rerenderPdfPages() {
	      if (!pdfDoc || currentBook?.format !== 'pdf') return;
	      pdfPageViewports.clear();
	      pdfPageTextItems.clear();
	      pdfPageDataPromises.clear();
	      pdfRenderedPages.clear();
	      document.querySelectorAll('.pdf-page').forEach(el => {
	        el.innerHTML = '';
	      });
	      observePdfPages();
	    }

	    let currentToc = [];
    let chapterIds = [];
    let currentTocActiveIndex = -1;
    let tocCollapseState = new Map(); // Track collapsed state by index
    let tocMetadata = []; // parentIndex, hasChildren for each item
    let tocClickLock = false;
    let currentHighlights = [];
    let currentNotes = [];
    let pendingNoteDraft = null;
    let readerUiHideTimer = null;
    let tocHideTimer = null;
    let annotationQuery = '';

	    let readSessionStartedAt = null;
	    let readSessionLastSentAt = null;
	    let readSessionInterval = null;
	    let readerResumeState = {
	      nextRunId: 0,
	      activeRunId: 0,
	      applying: false,
	      releaseTimer: null
	    };
	    let lastEpubLocationSentAt = 0;
	    let pendingEpubLocation = null;

		    let bookSearchState = {
		      query: '',
		      matches: [],
		      currentIndex: -1,
		      highlightsOnly: false
		    };

	    // Search results: click-to-jump (event delegation so it always works)
	    if (els.searchResultsPanel) {
	      els.searchResultsPanel.addEventListener('click', (e) => {
	        const target = e.target?.closest?.('[data-search-index]');
	        if (!target) return;
	        const idx = Number(target.dataset.searchIndex);
	        if (!Number.isFinite(idx)) return;
	        gotoSearchIndex(idx);
	      });
	    }

	    // Codemap click handler
	    const codemapEl = document.getElementById('search-codemap');
	    if (codemapEl) {
	      codemapEl.addEventListener('click', (e) => {
	        const marker = e.target?.closest?.('.codemap-marker[data-index]');
	        if (marker) {
	          const idx = Number(marker.dataset.index);
	          if (!Number.isNaN(idx)) gotoSearchIndex(idx);
	          return;
	        }
	        const track = e.target?.closest?.('.codemap-track');
	        if (track && !e.target.closest('.codemap-marker')) {
	          const rect = track.getBoundingClientRect();
	          const ratio = Math.min(1, Math.max(0, (e.clientY - rect.top) / rect.height));
	          const matches = bookSearchState.matches || [];
	          let bestIdx = -1;
	          let bestDist = Infinity;
	          for (let i = 0; i < matches.length; i++) {
	            const pos = typeof matches[i]?.pos === 'number' ? matches[i].pos : (i + 1) / matches.length;
	            const d = Math.abs(pos - ratio);
	            if (d < bestDist) { bestDist = d; bestIdx = i; }
	          }
	          if (bestIdx >= 0) gotoSearchIndex(bestIdx);
	        }
	      });
	    }

	    // Show results when focusing the search box (if there's an active query).
	    if (els.bookSearch) {
		      els.bookSearch.addEventListener('focus', () => {
		        const q = (els.bookSearch.value || '').trim();
		        if (!q) return;
		        if (bookSearchState.matches.length) {
		          computeSearchMatchPositions();
		          renderSearchCodemap();
		          showBookSearchResults();
		        } else {
		          scheduleBookSearch();
		        }
		      });
		    }

	    function showToast(message, type = 'info', timeoutMs = 2200) {
	      if (!els.toast) return;
	      els.toast.textContent = message;
	      els.toast.classList.remove('hidden', 'success', 'error');
	      if (type === 'success') els.toast.classList.add('success');
	      if (type === 'error') els.toast.classList.add('error');
	      clearTimeout(showToast._t);
	      showToast._t = setTimeout(() => els.toast.classList.add('hidden'), timeoutMs);
	    }

	    let systemLocaleInfo = null;
	    async function getSystemLocaleInfo() {
	      if (systemLocaleInfo) return systemLocaleInfo;
	      try {
	        systemLocaleInfo = await ipcRenderer.invoke('get-system-locale');
	      } catch (e) {
	        systemLocaleInfo = { locale: navigator.language || 'en', languages: [] };
	      }
	      return systemLocaleInfo;
	    }

	    const I18N = {
	      en: {
	        libraries: 'Libraries',
	        folders: 'Folders',
		        allBooks: 'All Books',
		        searchBooks: 'Search title, author, or file…',
		        searchRecent: 'Recent',
		        searchTopResults: 'Top results',
		        searchNoRecent: 'No recent books yet.',
		        searchNoMatches: 'No matches — try title, author, or file name.',
		        newLibrary: '+ New Library',
		        importDirectory: 'Import Directory',
		        settings: 'Settings',
	        welcomeTitle: 'Welcome to RoseReader',
	        welcomeSub: 'Your personal e-book library. Import a directory to get started, or create an empty library to organize your books.',
	        booksFinished: 'Books finished',
	        totalReadingTime: 'Total reading time',
	        continueReading: 'Continue Reading',
	        searchInBook: 'Search in book…',
	        readerSettings: 'Reader Settings',
	        appTheme: 'App Theme',
	        colorVariant: 'Color Variant',
	        language: 'Language',
	        system: 'System',
	        sort_recent: 'Recent',
	        sort_added: 'Date Added',
	        sort_title: 'Title',
	        sort_author: 'Author',
	        sort_progress: 'Progress',
	        selectLibraryToViewFolders: 'Select a library to view folders.',
	        noToc: 'No table of contents available',
	        noBookmarks: 'No bookmarks or highlights yet.'
	        , pin: 'Pin'
	        , unpin: 'Unpin'
	        , pinned: 'Pinned'
	        , insights: 'Insights'
	        , shareSnapshot: 'Share snapshot'
	        , sharedCopied: 'Snapshot copied to clipboard'
	        , shareFailed: 'Unable to copy snapshot'
	        , close: 'Close'
	        , readingStreak: 'Reading streak'
	        , activeDays: 'Active days (30d)'
	        , thisWeek: 'This week'
	        , topBooks: 'Top books (time)'
	        , lastReadGlobal: 'Last read (global)'
	        , booksTouched30d: 'Books touched (30d)'
	        , showFirstCompletionInHall: 'Show first 100% in library cards'
	        , dataTools: 'Data'
	        , mergeMovedBooks: 'Reading state recovery'
	        , mergeMovedBooksAction: 'Merge moved/duplicate books'
	        , mergeMovedBooksDone: 'Recovered reading state for {n} book(s)'
	        , mergeMovedBooksNone: 'No moved-book conflicts found'
	        , mergeMovedBooksFailed: 'Recovery failed'
	        , cardDensity: 'Card density'
	        , cardDensityComfortable: 'Comfortable'
	        , cardDensityDense: 'Dense'
	        , avgActiveDay30d: 'Average active day (30d)'
	        , total30d: 'Total 30d'
	        , first100Reached: 'First 100% reached'
	        , byBookLastRead: 'By-book last read'
	        , unknownFinishTime: 'Unknown finish time'
	        , justNow: 'just now'
	        , minAgo: 'm ago'
	        , hourAgo: 'h ago'
	        , dayAgo: 'd ago'
	        , lastPrefix: 'last'
	        , first100Prefix: 'first 100%'
	        , first100At: 'First 100%'
	        , unknownTimeShort: 'unknown time'
	        , booksCompleted: 'Books completed'
	        , avgPerBook: 'avg/book'
	      },
	      'zh-CN': {
	        libraries: '书库',
	        folders: '文件夹',
		        allBooks: '全部书籍',
		        searchBooks: '搜索标题、作者或文件…',
		        searchRecent: '最近',
		        searchTopResults: '最佳匹配',
		        searchNoRecent: '暂无最近阅读。',
		        searchNoMatches: '没有匹配结果，可尝试标题、作者或文件名。',
		        newLibrary: '+ 新建书库',
		        importDirectory: '导入目录',
		        settings: '设置',
	        welcomeTitle: '欢迎使用 RoseReader',
	        welcomeSub: '你的个人电子书书库。先导入一个目录开始使用，或创建空书库来整理你的书籍。',
	        booksFinished: '已读完',
	        totalReadingTime: '总阅读时长',
	        continueReading: '继续阅读',
	        searchInBook: '书内搜索…',
	        readerSettings: '阅读设置',
	        appTheme: '应用主题',
	        colorVariant: '配色风格',
	        language: '语言',
	        system: '跟随系统',
	        sort_recent: '最近',
	        sort_added: '添加时间',
	        sort_title: '标题',
	        sort_author: '作者',
	        sort_progress: '进度',
	        selectLibraryToViewFolders: '请选择一个书库以查看文件夹结构。',
	        noToc: '没有目录',
	        noBookmarks: '暂无书签或高亮。'
	        , pin: '置顶'
	        , unpin: '取消置顶'
	        , pinned: '已置顶'
	        , insights: '数据洞察'
	        , shareSnapshot: '分享快照'
	        , sharedCopied: '快照已复制到剪贴板'
	        , shareFailed: '无法复制快照'
	        , close: '关闭'
	        , readingStreak: '连续阅读'
	        , activeDays: '活跃天数（30天）'
	        , thisWeek: '本周'
	        , topBooks: '最常读（时长）'
	        , lastReadGlobal: '最近阅读（全局）'
	        , booksTouched30d: '触达书籍（30天）'
	        , showFirstCompletionInHall: '在书库卡片显示首次100%'
	        , dataTools: '数据'
	        , mergeMovedBooks: '阅读状态恢复'
	        , mergeMovedBooksAction: '合并已移动/重复书籍状态'
	        , mergeMovedBooksDone: '已恢复 {n} 本书的阅读状态'
	        , mergeMovedBooksNone: '未发现需要恢复的移动书籍'
	        , mergeMovedBooksFailed: '恢复失败'
	        , cardDensity: '卡片密度'
	        , cardDensityComfortable: '宽松'
	        , cardDensityDense: '紧凑'
	        , avgActiveDay30d: '活跃日均时长（30天）'
	        , total30d: '30天总计'
	        , first100Reached: '首次达到100%'
	        , byBookLastRead: '按书最近阅读'
	        , unknownFinishTime: '完成时间未知'
	        , justNow: '刚刚'
	        , minAgo: '分钟前'
	        , hourAgo: '小时前'
	        , dayAgo: '天前'
	        , lastPrefix: '最近'
	        , first100Prefix: '首次100%'
	        , first100At: '首次100%'
	        , unknownTimeShort: '时间未知'
	        , booksCompleted: '完成书籍'
	        , avgPerBook: '每本均值'
	      }
	    };

	    function normalizeLocale(raw) {
	      const s = String(raw || '').trim();
	      if (!s) return 'en';
	      if (s.toLowerCase().startsWith('zh')) return 'zh-CN';
	      if (s.toLowerCase().startsWith('en')) return 'en';
	      return 'en';
	    }

	    function getActiveLocale() {
	      const pref = String(settings.locale || 'system');
	      if (pref !== 'system') return normalizeLocale(pref);
	      const fromNav = navigator.language || 'en';
	      const fromSys = (systemLocaleInfo?.languages?.[0] || systemLocaleInfo?.locale || '');
	      return normalizeLocale(fromSys || fromNav);
	    }

	    function t(key) {
	      const locale = getActiveLocale();
	      const table = I18N[locale] || I18N.en;
	      return table[key] || I18N.en[key] || key;
	    }

	    function applyI18n() {
	      const locale = getActiveLocale();
	      const setText = (id, value) => {
	        const el = document.getElementById(id);
	        if (el) el.textContent = value;
	      };
	      const setPlaceholder = (id, value) => {
	        const el = document.getElementById(id);
	        if (el) el.setAttribute('placeholder', value);
	      };

		      setPlaceholder('library-search-input', t('searchBooks'));
		      setText('btn-new-library', t('newLibrary'));
	      setText('btn-import-dir', t('importDirectory'));
	      setText('btn-settings', t('settings'));
	      setText('tab-libraries', t('libraries'));
	      setText('tab-folders', t('folders'));
	      setText('nav-all-books', t('allBooks'));
	      setText('empty-title', t('welcomeTitle'));
	      setText('empty-sub', t('welcomeSub'));
	      setText('empty-import', t('importDirectory'));
		      setText('label-books-finished', t('booksFinished'));
		      setText('label-total-reading-time', t('totalReadingTime'));
	      setText('label-reading-streak', t('readingStreak'));
	      setText('label-last-read-global', t('lastReadGlobal'));
	      setText('label-books-touched-30d', t('booksTouched30d'));
	      setText('label-show-first-completion-hall', t('showFirstCompletionInHall'));
	      setText('label-data-tools', t('dataTools'));
	      setText('label-merge-moved-books', t('mergeMovedBooks'));
	      setText('btn-merge-moved-books', t('mergeMovedBooksAction'));
	      setText('label-card-density', t('cardDensity'));
	      setText('label-continue-reading', t('continueReading'));
	      setPlaceholder('book-search', t('searchInBook'));
	      setText('settings-title', t('readerSettings'));
		      setText('label-app-theme', t('appTheme'));
		      setText('label-color-variant', t('colorVariant'));
		      setText('label-language', t('language'));
	      setText('btn-insights', t('insights'));
	      setText('insights-title', t('insights'));
	      setText('insights-share', t('shareSnapshot'));
	      setText('insights-close', t('close'));

	      const localeSelect = document.getElementById('locale-select');
	      if (localeSelect) {
	        const systemOpt = localeSelect.querySelector('option[value="system"]');
	        if (systemOpt) systemOpt.textContent = t('system');
	      }

	      const sortSelect = document.getElementById('sort-select');
	      if (sortSelect) {
	        const setOpt = (value, label) => {
	          const opt = sortSelect.querySelector(`option[value="${value}"]`);
	          if (opt) opt.textContent = label;
	        };
	        setOpt('recent', t('sort_recent'));
	        setOpt('added', t('sort_added'));
	        setOpt('title', t('sort_title'));
	        setOpt('author', t('sort_author'));
	        setOpt('progress', t('sort_progress'));
	      }

	      const cardDensitySelect = document.getElementById('card-density');
	      if (cardDensitySelect) {
	        const comfortableOpt = cardDensitySelect.querySelector('option[value="comfortable"]');
	        const denseOpt = cardDensitySelect.querySelector('option[value="dense"]');
	        if (comfortableOpt) comfortableOpt.textContent = t('cardDensityComfortable');
	        if (denseOpt) denseOpt.textContent = t('cardDensityDense');
	      }

	      if (els.sidebarTitle) {
	        const mode = settings.sidebarMode || 'libraries';
	        els.sidebarTitle.textContent = mode === 'folders' ? t('folders') : t('libraries');
	      }

	      return locale;
	    }

	    function applyAppTheme() {
	      const theme = settings.appTheme || 'silk';
	      const accent = settings.appAccent || 'rose-gold';
	      document.documentElement.dataset.appTheme = theme;
	      document.documentElement.dataset.accent = accent;
	      const select = document.getElementById('app-theme');
	      if (select) select.value = theme;
	      const accentSelect = document.getElementById('app-accent');
	      if (accentSelect) accentSelect.value = accent;

      const img = settings.appBgImageUrl ? `url("${settings.appBgImageUrl.replaceAll('"', '\\"')}")` : 'none';
      document.documentElement.style.setProperty('--app-bg-image', img);
      document.documentElement.style.setProperty('--app-bg-opacity', String(settings.appBgOpacity ?? 0.14));
      document.documentElement.style.setProperty('--app-bg-blur', `${settings.appBgBlur ?? 12}px`);

      const opacityVal = document.getElementById('app-bg-opacity-val');
      const blurVal = document.getElementById('app-bg-blur-val');
      const opacity = document.getElementById('app-bg-opacity');
      const blur = document.getElementById('app-bg-blur');
	      if (opacityVal) opacityVal.textContent = String(settings.appBgOpacity ?? 0.14);
	      if (blurVal) blurVal.textContent = String(settings.appBgBlur ?? 12);
	      if (opacity) opacity.value = String(settings.appBgOpacity ?? 0.14);
	      if (blur) blur.value = String(settings.appBgBlur ?? 12);
	      applyI18n();
	    }

    function cssEscape(value) {
      if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(value);
      return String(value || '').replace(/[^a-zA-Z0-9_-]/g, (ch) => `\\${ch}`);
    }

    async function mapWithConcurrency(items, limit, fn) {
      const results = [];
      const queue = items.slice();
      const workers = Array.from({ length: Math.min(limit, queue.length) }, async () => {
        while (queue.length) {
          const item = queue.shift();
          results.push(await fn(item));
        }
      });
      await Promise.all(workers);
      return results;
    }

    async function ensureCoverUrl(bookId) {
      if (coverUrlCache.has(bookId) && coverUrlCache.get(bookId)) return coverUrlCache.get(bookId);
      const url = await ipcRenderer.invoke('get-cover-url', bookId);
      if (url) coverUrlCache.set(bookId, url);
      return url || null;
    }

    function loadCoversForCurrentGrid() {
      const imgs = [...document.querySelectorAll('img.book-cover[data-book-id]')];
      const uniqueIds = [...new Set(imgs.map(i => i.dataset.bookId).filter(Boolean))];

      mapWithConcurrency(uniqueIds, 6, async (id) => {
        try {
          const url = await ensureCoverUrl(id);
          if (!url) return;
          const selector = `img.book-cover[data-book-id="${cssEscape(id)}"]`;
          document.querySelectorAll(selector).forEach(img => {
            img.src = url;
            img.closest('.book-card')?.classList?.add('has-cover');
            img.closest('.recent-book')?.classList?.add('has-cover');
          });
        } catch (e) {}
      }).catch(() => {});
    }

	    function formatDurationSeconds(totalSeconds) {
	      const s = Math.max(0, Math.floor(totalSeconds || 0));
	      if (s < 60) return `${s}s`;
	      const m = Math.floor(s / 60);
	      if (m < 60) return `${m}m`;
	      const h = Math.floor(m / 60);
	      const mm = m % 60;
	      return mm ? `${h}h ${mm}m` : `${h}h`;
	    }

	    function formatDateTime(ts) {
	      const n = Number(ts || 0);
	      if (!n) return '-';
	      const d = new Date(n);
	      if (!Number.isFinite(d.getTime())) return '-';
	      return d.toLocaleString(undefined, {
	        year: 'numeric',
	        month: 'short',
	        day: 'numeric',
	        hour: '2-digit',
	        minute: '2-digit'
	      });
	    }

	    function formatRelativeTime(ts) {
	      const n = Number(ts || 0);
	      if (!n) return '-';
	      const diffSec = Math.max(0, Math.floor((Date.now() - n) / 1000));
	      if (diffSec < 60) return t('justNow');
	      const diffMin = Math.floor(diffSec / 60);
	      if (diffMin < 60) return `${diffMin}${t('minAgo')}`;
	      const diffHr = Math.floor(diffMin / 60);
	      if (diffHr < 24) return `${diffHr}${t('hourAgo')}`;
	      const diffDay = Math.floor(diffHr / 24);
	      if (diffDay < 30) return `${diffDay}${t('dayAgo')}`;
	      return formatDateTime(n);
	    }

	    function getGlobalLastReadAt() {
	      let maxTs = 0;
	      for (const b of getAllBooksArray()) {
	        const ts = Number(b?.lastRead || 0);
	        if (ts > maxTs) maxTs = ts;
	      }
	      return maxTs;
	    }

	    function getBooksTouchedCount(lastNDays = 30) {
	      const threshold = Date.now() - (Math.max(1, Number(lastNDays || 30)) * 24 * 60 * 60 * 1000);
	      let count = 0;
	      for (const b of getAllBooksArray()) {
	        if (Number(b?.lastRead || 0) >= threshold) count += 1;
	      }
	      return count;
	    }

	    function pad2(n) { return String(n).padStart(2, '0'); }
	    function dateKeyLocal(d) {
	      const dt = d instanceof Date ? d : new Date(d);
	      return `${dt.getFullYear()}-${pad2(dt.getMonth() + 1)}-${pad2(dt.getDate())}`;
	    }

	    function getDailySecondsMap() {
	      return (state.analytics && state.analytics.daily) ? state.analytics.daily : {};
	    }

	    function computeReadingStreakDays() {
	      const daily = getDailySecondsMap();
	      let streak = 0;
	      const today = new Date();
	      for (let i = 0; i < 3650; i++) {
	        const d = new Date(today);
	        d.setDate(today.getDate() - i);
	        const key = dateKeyLocal(d);
	        if ((daily[key] || 0) > 0) streak += 1;
	        else break;
	      }
	      return streak;
	    }

	    function computeActiveDays(lastNDays = 30) {
	      const daily = getDailySecondsMap();
	      let active = 0;
	      const today = new Date();
	      for (let i = 0; i < lastNDays; i++) {
	        const d = new Date(today);
	        d.setDate(today.getDate() - i);
	        const key = dateKeyLocal(d);
	        if ((daily[key] || 0) > 0) active += 1;
	      }
	      return active;
	    }

	    function showInsights() {
	      renderInsights();
	      els.insightsModal?.classList?.remove('hidden');
	    }
	    function hideInsights() {
	      els.insightsModal?.classList?.add('hidden');
	    }

	    function buildInsightsSnapshotText() {
	      const today = new Date();
	      const daily = getDailySecondsMap();
	      const streakDays = computeReadingStreakDays();
	      const activeDays30 = computeActiveDays(30);
	      let weekTotal = 0;
	      let seconds30 = 0;
	      for (let i = 0; i < 30; i++) {
	        const d = new Date(today);
	        d.setDate(today.getDate() - i);
	        const sec = Number(daily[dateKeyLocal(d)] || 0);
	        seconds30 += sec;
	        if (i < 7) weekTotal += sec;
	      }
	
	      const booksTouched30 = getBooksTouchedCount(30);
	      const booksCompletedCount = getAllBooksArray().filter(b => Number(b?.firstCompletedAt || b?.completedAt || 0) > 0).length;
	      const avgActiveDay30 = activeDays30 > 0 ? Math.floor(seconds30 / activeDays30) : 0;
	      const avgPerCompleted = booksCompletedCount > 0
	        ? Math.floor(Number(state.stats.totalReadTime || 0) / booksCompletedCount)
	        : 0;
	
	      const topBooks = getAllBooksArray()
	        .filter(b => (b.timeSpent || 0) > 0)
	        .sort((a, b) => (b.timeSpent || 0) - (a.timeSpent || 0))
	        .slice(0, 3)
	        .map((b, i) => `${i + 1}. ${b.title || 'Untitled'} (${formatDurationSeconds(b.timeSpent || 0)})`)
	        .join('\n');
	
	      return [
	        `📚 RoseReader ${t('insights')}`,
	        `${t('readingStreak')}: ${streakDays}`,
	        `${t('thisWeek')}: ${formatDurationSeconds(weekTotal)}`,
	        `${t('activeDays')}: ${activeDays30}`,
	        `${t('booksTouched30d')}: ${booksTouched30}`,
	        `${t('totalReadingTime')}: ${formatDurationSeconds(state.stats.totalReadTime || 0)}`,
	        `${t('avgActiveDay30d')}: ${formatDurationSeconds(avgActiveDay30)}`,
	        `${t('booksCompleted')}: ${booksCompletedCount}`,
	        `${t('avgPerBook')}: ${formatDurationSeconds(avgPerCompleted)}`,
	        topBooks ? `\n${t('topBooks')}:\n${topBooks}` : ''
	      ].filter(Boolean).join('\n');
	    }

	    async function shareInsightsSnapshot() {
	      try {
	        const text = buildInsightsSnapshotText();
	        await navigator.clipboard.writeText(text);
	        showToast(t('sharedCopied'), 'success');
	      } catch (e) {
	        showToast(t('shareFailed'), 'error');
	      }
	    }

	    function renderInsights() {
	      if (!els.insightsBody) return;
	      const daily = getDailySecondsMap();
	      const today = new Date();

	      const streakDays = computeReadingStreakDays();
	      const activeDays30 = computeActiveDays(30);

	      const weekKeys = [];
	      for (let i = 6; i >= 0; i--) {
	        const d = new Date(today);
	        d.setDate(today.getDate() - i);
	        weekKeys.push(dateKeyLocal(d));
	      }
	      const weekSeconds = weekKeys.map(k => Number(daily[k] || 0));
	      const weekTotal = weekSeconds.reduce((a, b) => a + b, 0);
	      const maxDay = Math.max(1, ...weekSeconds);
	      const seconds30 = (() => {
	        let s = 0;
	        for (let i = 0; i < 30; i++) {
	          const d = new Date(today);
	          d.setDate(today.getDate() - i);
	          s += Number(daily[dateKeyLocal(d)] || 0);
	        }
	        return s;
	      })();
	      const avgActiveDay30 = activeDays30 > 0 ? Math.floor(seconds30 / activeDays30) : 0;
	      const lastReadAt = getGlobalLastReadAt();
	      const booksCompletedCount = getAllBooksArray().filter(b => Number(b?.firstCompletedAt || b?.completedAt || 0) > 0).length;
	      const avgTimePerCompleted = booksCompletedCount > 0
	        ? Math.floor(Number(state.stats.totalReadTime || 0) / booksCompletedCount)
	        : 0;

	      const topBooks = getAllBooksArray()
	        .filter(b => (b.timeSpent || 0) > 0)
	        .sort((a, b) => (b.timeSpent || 0) - (a.timeSpent || 0))
	        .slice(0, 6);

	      const bars = weekSeconds.map((sec, idx) => {
	        const h = Math.max(0.08, Math.min(1, sec / maxDay));
	        const isActive = idx === 6;
	        return `<div class="insights-bar" data-active="${isActive ? 'true' : 'false'}" title="${formatDurationSeconds(sec)}"><span style="transform: scaleY(${h});"></span></div>`;
	      }).join('');

	      const items = topBooks.length
	        ? topBooks.map((b) => {
	          const metaBits = [formatDurationSeconds(b.timeSpent || 0)];
	          if (b.lastRead) metaBits.push(`${t('lastPrefix')} ${formatRelativeTime(b.lastRead)}`);
	          const completedAt = Number(b.firstCompletedAt || 0);
	          const isCompleted = Number(b.progress || 0) >= 0.98 || Number(b.completedAt || 0) > 0;
	          if (completedAt) metaBits.push(`${t('first100Prefix')} ${formatDateTime(completedAt)}`);
	          else if (isCompleted) metaBits.push(`${t('first100Prefix')} ${t('unknownFinishTime')}`);
	          return `<div class="insights-item" onclick="openBook('${escapeHtml(b.id)}')"><div class="name">${escapeHtml(b.title || 'Untitled')}</div><div class="meta">${escapeHtml(metaBits.join(' · '))}</div></div>`;
	        }).join('')
	        : `<div style="padding:12px;color:var(--text-secondary);">${escapeHtml(t('totalReadingTime'))}: ${formatDurationSeconds(0)}</div>`;

	      const byBookLastRead = getAllBooksArray()
	        .filter(b => Number(b?.lastRead || 0) > 0)
	        .sort((a, b) => Number(b?.lastRead || 0) - Number(a?.lastRead || 0))
	        .slice(0, 6)
	        .map((b) => {
	          const completedAt = Number(b.firstCompletedAt || 0);
	          const isCompleted = Number(b.progress || 0) >= 0.98 || Number(b.completedAt || 0) > 0;
	          const completionMeta = completedAt
	            ? `${t('first100Prefix')} ${formatDateTime(completedAt)}`
	            : (isCompleted ? `${t('first100Prefix')} ${t('unknownFinishTime')}` : '');
	          const parts = [`${formatDateTime(b.lastRead)} · ${formatRelativeTime(b.lastRead)}`];
	          if (completionMeta) parts.push(completionMeta);
	          return `<div class="insights-item" onclick="openBook('${escapeHtml(b.id)}')"><div class="name">${escapeHtml(b.title || 'Untitled')}</div><div class="meta">${escapeHtml(parts.join(' · '))}</div></div>`;
	        })
	        .join('');

	      const locale = getActiveLocale();
	      const dayLabel = (n) => {
	        if (locale === 'zh-CN') return `${n}天`;
	        return `${n} ${n === 1 ? 'day' : 'days'}`;
	      };

	      els.insightsBody.innerHTML = `
	        <div class="insights-grid">
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('readingStreak'))}</div>
	            <div class="v">${dayLabel(streakDays)}</div>
	          </div>
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('activeDays'))}</div>
	            <div class="v">${activeDays30}</div>
	          </div>
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('thisWeek'))}</div>
	            <div class="v">${formatDurationSeconds(weekTotal)}</div>
	            <div class="insights-bars" aria-hidden="true">${bars}</div>
	          </div>
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('avgActiveDay30d'))}</div>
	            <div class="v">${formatDurationSeconds(avgActiveDay30)}</div>
	            <div style="margin-top:8px;color:var(--text-secondary);font-size:0.86rem;">${escapeHtml(t('total30d'))}: ${formatDurationSeconds(seconds30)}</div>
	          </div>
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('lastReadGlobal'))}</div>
	            <div class="v" style="font-size:1.05rem;line-height:1.3;">${escapeHtml(formatDateTime(lastReadAt))}</div>
	            <div style="margin-top:8px;color:var(--text-secondary);font-size:0.86rem;">${escapeHtml(formatRelativeTime(lastReadAt))}</div>
	          </div>
	          <div class="insights-card">
	            <div class="k">${escapeHtml(t('booksCompleted'))}</div>
	            <div class="v">${booksCompletedCount}</div>
	            <div style="margin-top:8px;color:var(--text-secondary);font-size:0.86rem;">${escapeHtml(t('avgPerBook'))}: ${formatDurationSeconds(avgTimePerCompleted)}</div>
	          </div>
	        </div>
	        <div class="insights-card" style="margin-top: 12px;">
	          <div class="k">${escapeHtml(t('topBooks'))}</div>
	          <div class="insights-list">${items}</div>
	        </div>
	        <div class="insights-card" style="margin-top: 12px;">
	          <div class="k">${escapeHtml(t('byBookLastRead'))}</div>
	          <div class="insights-list">${byBookLastRead || `<div style="padding:12px;color:var(--text-secondary);">-</div>`}</div>
	        </div>
	      `;
	    }

    function escapeHtml(str) {
      return String(str || '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#39;');
    }

    function getAllBooksArray() {
      return Object.values(state.booksById || {});
    }

    function getActiveBooksArray() {
      return getAllBooksArray().filter(b => !b.missingOnDisk);
    }

    function getCurrentLibrary() {
      if (selectedLibraryId === 'all') return null;
      return state.libraries.find(l => l.id === selectedLibraryId) || null;
    }

	    function findNodeById(root, nodeId) {
	      if (!root) return null;
	      if (root.id === nodeId) return root;
	      for (const child of root.children || []) {
	        const found = findNodeById(child, nodeId);
	        if (found) return found;
	      }
	      return null;
	    }

	    function findPathToNode(root, nodeId, out = []) {
	      if (!root) return null;
	      out.push(root);
	      if (root.id === nodeId) return out;
	      for (const child of root.children || []) {
	        const next = findPathToNode(child, nodeId, out.slice());
	        if (next) return next;
	      }
	      return null;
	    }

	    function collectBookIds(node, outSet) {
	      if (!node) return;
	      (node.books || []).forEach(id => outSet.add(id));
	      (node.children || []).forEach(child => collectBookIds(child, outSet));
	    }

	    function normalizeSearchText(s) {
	      return String(s || '')
	        .normalize('NFKD')
	        .replace(/[\u0300-\u036f]/g, '')
	        .toLowerCase()
	        .replace(/\s+/g, ' ')
	        .trim();
	    }

	    function tokenizeQuery(q) {
	      const normalized = normalizeSearchText(q);
	      if (!normalized) return [];
	      return normalized.split(' ').filter(Boolean).slice(0, 12);
	    }

	    // Fuzzy matching for typo tolerance
	    function fuzzyScore(needle, haystack) {
	      if (!needle || !haystack) return 0;
	      needle = normalizeSearchText(needle);
	      haystack = normalizeSearchText(haystack);
	      if (haystack.includes(needle)) return 100;
	      if (needle.length < 2) return 0;
	      let hi = 0, matched = 0;
	      for (let ni = 0; ni < needle.length && hi < haystack.length; ni++) {
	        const idx = haystack.indexOf(needle[ni], hi);
	        if (idx >= 0) { matched++; hi = idx + 1; }
	      }
	      if (matched < needle.length * 0.7) return 0;
	      const getBigrams = s => { const b = new Set(); for (let i = 0; i < s.length - 1; i++) b.add(s.slice(i, i + 2)); return b; };
	      const nb = getBigrams(needle), hb = getBigrams(haystack);
	      let common = 0;
	      for (const b of nb) if (hb.has(b)) common++;
	      const score = (2 * common) / (nb.size + hb.size) * 100;
	      return score > 35 ? score : 0;
	    }

	    // Recent searches storage
	    let recentSearches = JSON.parse(localStorage.getItem('rr-recent-searches') || '[]').slice(0, 5);
	    function addRecentSearch(query) {
	      const q = String(query || '').trim();
	      if (!q || q.length < 2) return;
	      recentSearches = [q, ...recentSearches.filter(s => s !== q)].slice(0, 5);
	      localStorage.setItem('rr-recent-searches', JSON.stringify(recentSearches));
	    }

	    // Search filters state
	    let searchFilters = { format: null, status: null };

	    function getBooksInCurrentScope() {
	      const base = getActiveBooksArray()
	        .filter(b => (selectedLibraryId === 'all' ? true : b.libraryId === selectedLibraryId));

	      if (selectedLibraryId === 'all' || selectedFolderNodeId === '__ALL__') return base;

	      const lib = getCurrentLibrary();
	      const node = findNodeById(lib?.structure, selectedFolderNodeId);
	      if (!node) return base;

	      const set = new Set();
	      collectBookIds(node, set);
	      return base.filter(b => set.has(b.id));
	    }

	    function getBookSearchHaystack(book) {
	      const title = book?.title || '';
	      const author = book?.author || '';
	      const filename = path.basename(book?.path || '');
	      return normalizeSearchText(`${title} ${author} ${filename}`);
	    }

	    function scoreBookForTokens(book, tokens) {
	      if (!tokens?.length) return 0;
	      const titleRaw = String(book?.title || '');
	      const authorRaw = String(book?.author || '');
	      const filenameRaw = path.basename(book?.path || '');
	      const title = normalizeSearchText(titleRaw);
	      const author = normalizeSearchText(authorRaw);
	      const filename = normalizeSearchText(filenameRaw);

	      let score = 0;
	      for (const t of tokens) {
	        if (!t) continue;
	        const inTitle = title.indexOf(t);
	        const inAuthor = author.indexOf(t);
	        const inFile = filename.indexOf(t);

	        // Exact match scoring
	        if (inTitle >= 0 || inAuthor >= 0 || inFile >= 0) {
	          if (inTitle === 0) score += 80;
	          else if (inTitle > 0 && !/[a-z0-9]/.test(title[inTitle - 1] || '')) score += 58;
	          else if (inTitle >= 0) score += 38;
	          if (inAuthor === 0) score += 34;
	          else if (inAuthor > 0 && !/[a-z0-9]/.test(author[inAuthor - 1] || '')) score += 24;
	          else if (inAuthor >= 0) score += 16;
	          if (inFile === 0) score += 18;
	          else if (inFile >= 0) score += 10;
	        } else {
	          // Fuzzy fallback
	          const fTitle = fuzzyScore(t, title);
	          const fAuthor = fuzzyScore(t, author);
	          if (fTitle > 0) score += fTitle * 0.4;
	          else if (fAuthor > 0) score += fAuthor * 0.2;
	          else return 0;
	        }
	      }

	      const lastRead = Number(book?.lastRead || 0);
	      const pinnedAt = Number(book?.pinnedAt || 0);
	      if (pinnedAt) score += 20;
	      if (lastRead) score += Math.min(18, Math.log10(1 + lastRead) * 2);
	      return score;
	    }

	    function matchesTokens(book, tokens) {
	      if (!tokens?.length) return true;
	      const hay = getBookSearchHaystack(book);
	      return tokens.every(t => hay.includes(t) || fuzzyScore(t, hay) > 0);
	    }

	    function matchesFilters(book) {
	      if (searchFilters.format && book.format !== searchFilters.format) return false;
	      if (searchFilters.status === 'unread' && (book.progress || 0) > 0) return false;
	      if (searchFilters.status === 'reading' && ((book.progress || 0) === 0 || (book.progress || 0) >= 1)) return false;
	      if (searchFilters.status === 'finished' && (book.progress || 0) < 1) return false;
	      return true;
	    }

		    function getVisibleBooks() {
	      const tokens = tokenizeQuery(libraryQuery);
	      const base = getBooksInCurrentScope();

		      const sortKey = state.settings.librarySort || 'recent';
		      const sortDir = state.settings.librarySortDir || 'desc';
		      const dir = sortDir === 'asc' ? 1 : -1;

			      const filtered = base.filter(b => matchesTokens(b, tokens));
			      const scoreMap = tokens.length ? new Map(filtered.map(b => [b.id, scoreBookForTokens(b, tokens)])) : null;

			      const sorted = filtered.sort((a, b) => {
			          const byText = (av, bv) => (String(av || '')).localeCompare(String(bv || ''), undefined, { sensitivity: 'base' }) * dir;
			          const byNum = (av, bv) => ((Number(av || 0) - Number(bv || 0)) * dir);

			          if (scoreMap) {
			            const d = (scoreMap.get(b.id) || 0) - (scoreMap.get(a.id) || 0);
			            if (d) return d;
			          }

			          if (sortKey === 'title') return byText(a.title, b.title);
			          if (sortKey === 'author') return byText(a.author, b.author);
			          if (sortKey === 'progress') return byNum(a.progress, b.progress) || byText(a.title, b.title);
			          if (sortKey === 'added') return byNum(a.createdAt, b.createdAt) || byText(a.title, b.title);
			          return byNum(a.lastRead, b.lastRead) || byNum(a.createdAt, b.createdAt) || byText(a.title, b.title);
			        });
		
		      const pinned = sorted.filter(b => b.pinnedAt).sort((a, b) => (b.pinnedAt || 0) - (a.pinnedAt || 0) || (String(a.title || '')).localeCompare(String(b.title || ''), undefined, { sensitivity: 'base' }));
		      const unpinned = sorted.filter(b => !b.pinnedAt);
		      return [...pinned, ...unpinned];
		    }

	    async function refreshState() {
	      const data = await ipcRenderer.invoke('get-state');
	      state.libraries = data.libraries || [];
	      state.booksById = (data.books || []).reduce((acc, b) => (acc[b.id] = b, acc), {});
	      state.settings = data.settings || {};
	      state.stats = data.stats || {};
	      state.analytics = data.analytics || {};
	      settings = state.settings;
	      getSystemLocaleInfo().then(() => applyI18n()).catch(() => {});
	      applyAppTheme();
	      applySidebarMode();

      selectedLibraryId = state.settings.selectedLibraryId || 'all';
      if (selectedLibraryId !== 'all' && !state.libraries.some(l => l.id === selectedLibraryId)) {
        selectedLibraryId = 'all';
        await persistSelectedLibrary('all');
      }
    }

    async function persistSelectedLibrary(id) {
      state.settings.selectedLibraryId = id;
      await ipcRenderer.invoke('update-settings', state.settings);
    }

	    function renderStats() {
	      if (els.statBooksRead) els.statBooksRead.textContent = String(state.stats.booksRead || 0);
	      if (els.statReadTime) els.statReadTime.textContent = formatDurationSeconds(state.stats.totalReadTime || 0);
	      if (els.statStreak) els.statStreak.textContent = String(computeReadingStreakDays());
	      if (els.statLastRead) {
	        const ts = getGlobalLastReadAt();
	        els.statLastRead.textContent = formatDateTime(ts);
	        els.statLastRead.title = formatDateTime(ts);
	      }
	      if (els.statBooksTouched30d) {
	        els.statBooksTouched30d.textContent = String(getBooksTouchedCount(30));
	      }
	    }

    function renderSortControls() {
      const select = document.getElementById('sort-select');
      const btn = document.getElementById('sort-dir-btn');
      if (select) select.value = state.settings.librarySort || 'recent';
      if (btn) btn.textContent = (state.settings.librarySortDir || 'desc') === 'asc' ? '↑' : '↓';
    }

    function renderLibraries() {
      if (!els.libraryList) return;

      const libCounts = {};
      for (const b of getActiveBooksArray()) {
        if (!b.libraryId) continue;
        libCounts[b.libraryId] = (libCounts[b.libraryId] || 0) + 1;
      }

      const allActive = selectedLibraryId === 'all';
      const items = [];

      items.push(`
        <div class="library-item ${allActive ? 'active' : ''}" onclick="selectLibrary('all')">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
          <span>All Books</span>
        </div>
      `);

      for (const lib of state.libraries) {
        const active = selectedLibraryId === lib.id;
        const count = libCounts[lib.id] || 0;
        const libName = lib.name || 'Untitled';
        items.push(`
          <div class="library-item ${active ? 'active' : ''}" onclick="selectLibrary('${escapeHtml(lib.id)}')">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
            <span>${escapeHtml(libName)} (${count})</span>
            <div class="lib-actions">
              ${lib.path ? `<button title="Sync (add new/remove deleted)" onclick="event.stopPropagation();rescanLibrary('${escapeHtml(lib.id)}')" ondblclick="event.stopPropagation();rescanLibrary('${escapeHtml(lib.id)}', true)">⟳</button>` : ''}
              <button title="Delete" onclick="event.stopPropagation();showDeleteLibraryModal('${escapeHtml(lib.id)}')">🗑</button>
            </div>
          </div>
        `);
      }

      els.libraryList.innerHTML = items.join('');
    }

	    function applySidebarMode() {
	      const mode = settings.sidebarMode || 'libraries';
	      els.tabLibraries?.classList?.toggle('active', mode === 'libraries');
	      els.tabFolders?.classList?.toggle('active', mode === 'folders');
	      els.libraryList?.classList?.toggle('hidden', mode !== 'libraries');
	      els.folderTree?.classList?.toggle('hidden', mode !== 'folders');
	      els.sidebarAddLibrary?.classList?.toggle('hidden', mode !== 'libraries');
	      els.sidebarAddFolder?.classList?.toggle('hidden', mode !== 'folders');
	      if (els.sidebarTitle) els.sidebarTitle.textContent = mode === 'folders' ? t('folders') : t('libraries');
	    }

    function setSidebarMode(mode) {
      settings.sidebarMode = mode;
      ipcRenderer.invoke('update-settings', settings);
      applySidebarMode();
      renderFolderTree();
    }

    function ensureFolderUiState() {
      const lib = getCurrentLibrary();
      if (!lib?.structure) return;
      if (!expandedFolderIds.size) expandedFolderIds.add(lib.structure.id);
      if (selectedFolderNodeId !== '__ALL__' && !findNodeById(lib.structure, selectedFolderNodeId)) {
        selectedFolderNodeId = '__ALL__';
      }
    }

    function renderFolderTree() {
      if (!els.folderTree) return;
      const lib = getCurrentLibrary();

	      if (!lib?.structure) {
	        if (settings.sidebarMode === 'folders') {
	          els.folderTree.innerHTML = `<div style="padding:16px;color:var(--text-secondary);">${escapeHtml(t('selectLibraryToViewFolders'))}</div>`;
	        } else {
	          els.folderTree.innerHTML = '';
	        }
	        return;
	      }

      ensureFolderUiState();

      const countBooks = (node) => {
        const s = new Set();
        collectBookIds(node, s);
        return s.size;
      };

      const renderNode = (node, depth) => {
        const active = selectedFolderNodeId === node.id;
        const hasChildren = (node.children || []).length > 0;
        const expanded = expandedFolderIds.has(node.id);
        const caret = hasChildren ? (expanded ? '▾' : '▸') : '';
        const total = countBooks(node);
        const pad = 10 + depth * 14;

        const row = `
          <div class="folder-item ${active ? 'active' : ''}"
               style="padding-left:${pad}px"
               onclick="selectFolder('${escapeHtml(node.id)}')"
               ondblclick="toggleFolderNode('${escapeHtml(node.id)}')"
               ondragover="onFolderDragOver(event)"
               ondragleave="onFolderDragLeave(event)"
               ondrop="onFolderDrop(event,'${escapeHtml(node.id)}')">
            <span class="caret">${caret}</span>
            <span class="name">${escapeHtml(node.name || 'Folder')} <span style="opacity:.55">(${total})</span></span>
          </div>
        `;

        if (!hasChildren || !expanded) return row;
        const children = (node.children || []).map(c => renderNode(c, depth + 1)).join('');
        return row + children;
      };

      const rootId = lib.structure.id;
      const allActive = selectedFolderNodeId === '__ALL__';
      const allRow = `
        <div class="folder-item ${allActive ? 'active' : ''}"
             onclick="selectFolder('__ALL__')"
             ondragover="onFolderDragOver(event)"
             ondragleave="onFolderDragLeave(event)"
             ondrop="onFolderDrop(event,'${escapeHtml(rootId)}')">
          <span class="caret">⌂</span>
          <span class="name">All folders</span>
        </div>
      `;

      els.folderTree.innerHTML = allRow + renderNode(lib.structure, 0);
    }

    function selectFolder(nodeId) {
      selectedFolderNodeId = nodeId;
      renderFolderTree();
      renderBooks();
    }

    function toggleFolderNode(nodeId) {
      if (expandedFolderIds.has(nodeId)) expandedFolderIds.delete(nodeId);
      else expandedFolderIds.add(nodeId);
      renderFolderTree();
    }

    async function createFolderPrompt() {
      const lib = getCurrentLibrary();
      if (!lib?.structure) return;
      const parentId = (selectedFolderNodeId !== '__ALL__') ? selectedFolderNodeId : lib.structure.id;
      const name = window.prompt('Folder name');
      if (!name) return;

      let createOnDisk = true;
      if (lib.path) {
        createOnDisk = window.confirm('Create folder on disk too?');
      } else {
        createOnDisk = false;
      }

      try {
        await ipcRenderer.invoke('create-folder', lib.id, parentId, name, createOnDisk);
        await refreshState();
        renderFolderTree();
        renderBooks();
        showToast('Folder created', 'success');
      } catch (e) {
        showToast(e?.message || 'Failed to create folder', 'error');
      }
    }

    function onBookDragStart(event, bookId) {
      draggingBookId = bookId;
      try {
        event.dataTransfer.setData('text/plain', bookId);
        event.dataTransfer.effectAllowed = 'move';
      } catch (e) {}
    }

    function hideContextMenu() {
      if (!els.contextMenu) return;
      els.contextMenu.classList.add('hidden');
      els.contextMenu.innerHTML = '';
      els.contextMenu.style.left = '-9999px';
      els.contextMenu.style.top = '-9999px';
    }

    async function onBookContextMenu(event, bookId) {
      event.preventDefault();
      event.stopPropagation();
      hideContextMenu();

      const book = state.booksById[bookId];
      if (!book || !els.contextMenu) return;

      const menu = els.contextMenu;
      const add = (label, handler, opts = {}) => {
        const btn = document.createElement('button');
        btn.textContent = label;
        if (opts.danger) btn.classList.add('danger');
        btn.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          hideContextMenu();
          try { await handler(); } catch (err) { showToast(err?.message || 'Action failed', 'error'); }
        });
        menu.appendChild(btn);
      };
      const sep = () => {
        const div = document.createElement('div');
        div.className = 'sep';
        menu.appendChild(div);
      };

	      add('Open', async () => openBook(bookId));
	      add('Copy book name', async () => {
	        await navigator.clipboard.writeText(book.title || '');
	        showToast('Copied book name', 'success');
	      });
	      add(book.pinnedAt ? t('unpin') : t('pin'), async () => {
	        await ipcRenderer.invoke('toggle-pin', bookId);
	        await refreshState();
	        renderBooks();
	      });
		      add('Search in library', async () => {
		        if (els.librarySearchInput) els.librarySearchInput.value = book.title || '';
		        openSearch();
		        onLibrarySearchInput();
		      });
      sep();

      add('Move…', async () => {
        if (!book.libraryId) return;
        if (selectedLibraryId !== book.libraryId) await selectLibrary(book.libraryId);
        setSidebarMode('folders');
        const lib = getCurrentLibrary();
        if (!lib?.structure) return;
        showMoveBookModal(bookId, lib.structure.id);
      });

      add('Reveal in folder', async () => {
        if (book.path) await ipcRenderer.invoke('show-item-in-folder', book.path);
      });

      add('Regenerate cover', async () => {
        showToast('Regenerating cover…');
        coverUrlCache.delete(bookId);
        const url = await ipcRenderer.invoke('regenerate-cover', bookId);
        if (url) {
          const selector = `img.book-cover[data-book-id="${cssEscape(bookId)}"]`;
          document.querySelectorAll(selector).forEach(img => {
            img.src = url + '?t=' + Date.now();
            img.closest('.book-card')?.classList?.add('has-cover');
            img.closest('.recent-book')?.classList?.add('has-cover');
          });
          coverUrlCache.set(bookId, url);
          showToast('Cover regenerated', 'success');
        } else {
          showToast('Failed to generate cover', 'error');
        }
      });

      sep();
      add('Delete…', async () => showDeleteModal(bookId), { danger: true });

      const x = Math.min(window.innerWidth - 240, Math.max(8, event.clientX));
      const y = Math.min(window.innerHeight - 220, Math.max(8, event.clientY));
      menu.style.left = `${x}px`;
      menu.style.top = `${y}px`;
      menu.classList.remove('hidden');
    }

    function onFolderDragOver(event) {
      event.preventDefault();
      event.currentTarget?.classList?.add('drop');
    }

    function onFolderDragLeave(event) {
      event.currentTarget?.classList?.remove('drop');
    }

    function onFolderDrop(event, targetNodeId) {
      event.preventDefault();
      event.currentTarget?.classList?.remove('drop');
      const bookId = (() => {
        try { return event.dataTransfer.getData('text/plain'); } catch (e) { return ''; }
      })() || draggingBookId;

      if (!bookId || selectedLibraryId === 'all') return;
      const lib = getCurrentLibrary();
      if (!lib?.structure) return;

      showMoveBookModal(bookId, targetNodeId || lib.structure.id);
    }

    function flattenFolderOptions(root, depth = 0, out = []) {
      if (!root) return out;
      const prefix = depth ? `${'—'.repeat(Math.min(8, depth))} ` : '';
      out.push({ id: root.id, label: `${prefix}${root.name || 'Folder'}` });
      (root.children || []).forEach(child => flattenFolderOptions(child, depth + 1, out));
      return out;
    }

    function showMoveBookModal(bookId, targetNodeId) {
      if (selectedLibraryId === 'all') return;
      const lib = getCurrentLibrary();
      if (!lib?.structure) return;
      const book = state.booksById[bookId];
      if (!book) return;

      const options = flattenFolderOptions(lib.structure, 0, []);
      if (els.moveTargetSelect) {
        els.moveTargetSelect.innerHTML = options.map(o =>
          `<option value="${escapeHtml(o.id)}">${escapeHtml(o.label)}</option>`
        ).join('');
        els.moveTargetSelect.value = targetNodeId || lib.structure.id;
      }

      pendingMove = { libraryId: lib.id, bookId, targetNodeId: targetNodeId || lib.structure.id };
      const destNode = findNodeById(lib.structure, pendingMove.targetNodeId);
      if (els.moveBookTitle) els.moveBookTitle.textContent = `Move "${book.title || 'book'}"?`;
      if (els.moveBookDesc) els.moveBookDesc.textContent = `Move to "${destNode?.name || 'folder'}". Choose whether to also move the file on disk.`;
      if (els.moveBookDiskBtn) els.moveBookDiskBtn.style.display = lib.path ? 'block' : 'none';
      els.moveBookModal.classList.remove('hidden');
    }

    function hideMoveBookModal() {
      els.moveBookModal.classList.add('hidden');
      pendingMove = null;
      draggingBookId = null;
    }

    async function confirmMoveBook(moveFile) {
      if (!pendingMove) return;
      try {
        await ipcRenderer.invoke('move-book', pendingMove.libraryId, pendingMove.bookId, pendingMove.targetNodeId, !!moveFile);
        hideMoveBookModal();
        await refreshState();
        renderFolderTree();
        renderBooks();
        showToast(moveFile ? 'Moved book and file' : 'Moved book', 'success');
      } catch (e) {
        showToast(e?.message || 'Move failed', 'error');
      }
    }

    function renderBooks() {
      if (!els.booksGrid || !els.booksContainer || !els.emptyMsg) return;

      const allBooks = getActiveBooksArray();
      const visible = getVisibleBooks();

      const hasBooks = allBooks.length > 0;
      const hasVisible = visible.length > 0;

      if (!hasBooks) {
        els.emptyMsg.classList.remove('hidden');
        els.emptyMsg.innerHTML = defaultEmptyHtml;
        els.booksContainer.classList.add('hidden');
        els.booksGrid.innerHTML = '';
        return;
      }

      els.emptyMsg.classList.add('hidden');
      els.booksContainer.classList.remove('hidden');
      renderFolderTree();

	      const libTitle = selectedLibraryId === 'all'
	        ? 'All Books'
	        : (state.libraries.find(l => l.id === selectedLibraryId)?.name || 'Library');
	      let headerTitle = libTitle;
	      if (selectedLibraryId !== 'all' && selectedFolderNodeId !== '__ALL__') {
	        const lib = getCurrentLibrary();
	        const pathNodes = findPathToNode(lib?.structure, selectedFolderNodeId);
	        const folderPath = (pathNodes || []).slice(1).map(n => n.name || 'Folder').join(' / ');
	        if (folderPath) headerTitle = `${libTitle} / ${folderPath}`;
	      }
	      els.booksHeaderTitle.textContent = headerTitle;
      els.booksCount.textContent = `${visible.length} book${visible.length === 1 ? '' : 's'}`;
      renderSortControls();

      if (!hasVisible) {
        const msgTitle = libraryQuery.trim()
          ? 'No matches'
          : (selectedFolderNodeId !== '__ALL__' ? 'No books in this folder' : 'No books');
        const msgAction = libraryQuery.trim()
          ? `<button class="primary" onclick="clearLibrarySearch()">Clear Search</button>`
          : '';
        els.booksGrid.innerHTML = `
          <div style="grid-column:1/-1;background:var(--bg-card);border:1px solid var(--border);border-radius:var(--radius);padding:22px;box-shadow:var(--shadow);">
            <div style="font-weight:600;margin-bottom:6px;">${msgTitle}</div>
            <div style="color:var(--text-secondary);margin-bottom:14px;">Try a different search or folder.</div>
            ${msgAction}
          </div>
        `;
        els.recentSection.classList.add('hidden');
        return;
      }

      const iconSvg = (format) => {
        if (format === 'pdf') return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/></svg>';
        if (format === 'txt') return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/><path d="M8 13h8"/><path d="M8 17h8"/><path d="M8 9h2"/></svg>';
        return '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>';
      };

	      els.booksGrid.innerHTML = visible.map((b, i) => {
	        const pct = Math.max(0, Math.min(100, Math.round((b.progress || 0) * 100)));
	        const title = escapeHtml(b.title || 'Untitled');
	        const author = escapeHtml(b.author || 'Unknown');
	        const completedAt = Number(b.firstCompletedAt || 0);
	        const isCompleted = Number(b.progress || 0) >= 0.98 || Number(b.completedAt || 0) > 0;
	        const showCompletionMeta = settings.showFirstCompletionInHall !== false;
	        const completionMeta = showCompletionMeta
	          ? (isCompleted
	            ? (completedAt
	              ? `${escapeHtml(t('first100At'))}: ${escapeHtml(formatDateTime(completedAt))}`
	              : `${escapeHtml(t('first100At'))}: ${escapeHtml(t('unknownTimeShort'))}`)
	            : `${escapeHtml(t('lastPrefix'))}: ${pct}%`)
	          : '';
	        const completionMetaHtml = showCompletionMeta
	          ? `<div class="book-progress-meta">${completionMeta}</div>`
	          : '';
	        return `
	          <div class="book-card" style="animation-delay:${Math.min(240, i * 14)}ms" draggable="true" ondragstart="onBookDragStart(event,'${escapeHtml(b.id)}')" oncontextmenu="onBookContextMenu(event,'${escapeHtml(b.id)}')" onclick="openBook('${escapeHtml(b.id)}')">
	            ${b.pinnedAt ? `<div class="pin-badge">${escapeHtml(t('pinned'))}</div>` : ''}
	            <button class="menu-btn" title="More" onclick="event.stopPropagation();onBookContextMenu(event,'${escapeHtml(b.id)}')">⋯</button>
	            <div class="book-icon">
	              <img class="book-cover" data-book-id="${escapeHtml(b.id)}" alt="">
	              ${iconSvg(b.format)}
	            </div>
	            <div class="book-title">${title}</div>
	            <div class="book-author">${author}</div>
	            <div class="book-footer">
	              ${completionMetaHtml}
	              <div class="book-progress-row">
	                <div class="book-progress"><div class="book-progress-bar" style="width:${pct}%"></div></div>
	                <div class="book-progress-pct">${pct}%</div>
	              </div>
	            </div>
	          </div>
	        `;
	      }).join('');

      renderRecent();
      loadCoversForCurrentGrid();
    }

    function renderRecent() {
      if (!els.recentSection || !els.recentBooks) return;
      const recent = getActiveBooksArray()
        .filter(b => (b.lastRead || 0) > 0)
        .sort((a, b) => (b.lastRead || 0) - (a.lastRead || 0))
        .slice(0, 10);

      if (recent.length === 0) {
        els.recentSection.classList.add('hidden');
        els.recentBooks.innerHTML = '';
        return;
      }

      els.recentSection.classList.remove('hidden');
	      els.recentBooks.innerHTML = recent.map(b => {
	        const pct = Math.max(0, Math.min(100, Math.round((b.progress || 0) * 100)));
	        const completedAt = Number(b.firstCompletedAt || 0);
	        const isCompleted = Number(b.progress || 0) >= 0.98 || Number(b.completedAt || 0) > 0;
	        const showCompletionMeta = settings.showFirstCompletionInHall !== false;
	        const completionMeta = showCompletionMeta
	          ? (isCompleted
	            ? (completedAt
	              ? `${escapeHtml(t('first100At'))}: ${escapeHtml(formatDateTime(completedAt))}`
	              : `${escapeHtml(t('first100At'))}: ${escapeHtml(t('unknownTimeShort'))}`)
	            : `${escapeHtml(t('lastPrefix'))}: ${pct}%`)
	          : '';
	        const completionMetaHtml = showCompletionMeta
	          ? `<div class="book-progress-meta">${completionMeta}</div>`
	          : '';
	        return `
	          <div class="recent-book" oncontextmenu="onBookContextMenu(event,'${escapeHtml(b.id)}')" onclick="openBook('${escapeHtml(b.id)}')">
	            <button class="recent-remove" onclick="event.stopPropagation();removeFromRecent('${escapeHtml(b.id)}')" title="Remove from Continue Reading">&times;</button>
	            <div class="book-icon">
	              <img class="book-cover" data-book-id="${escapeHtml(b.id)}" alt="">
	              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:20px;height:20px;color:var(--primary);"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
	            </div>
	            <div class="book-title">${escapeHtml(b.title || 'Untitled')}</div>
	            <div class="book-author">${escapeHtml(b.author || 'Unknown')}</div>
	            <div class="book-footer">
	              ${completionMetaHtml}
	              <div class="book-progress-row">
	                <div class="book-progress"><div class="book-progress-bar" style="width:${pct}%"></div></div>
	                <div class="book-progress-pct">${pct}%</div>
	              </div>
	            </div>
	          </div>
	        `;
	      }).join('');
      loadCoversForCurrentGrid();
    }

    async function init() {
      await refreshState();
      renderLibraries();
      renderStats();
      renderBooks();
      applySettings();
      reloadSystemFonts().catch(() => {});

	      // Update keyboard shortcut display based on platform
	      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
	      if (els.librarySearchKbd) els.librarySearchKbd.textContent = isMac ? '⌘K' : 'Ctrl+K';
	      bindLibrarySearch();

	      els.readerContent?.addEventListener('wheel', (e) => {
	        if (!currentBook) return;

	        const isZoom = e.ctrlKey || e.metaKey;
	        const isWidth = e.altKey || e.shiftKey;
	        if (!isZoom && !isWidth) return;

	        e.preventDefault();
	        const direction = e.deltaY < 0 ? 1 : -1;
	        if (isWidth) {
	          bumpSetting('readerMaxWidth', direction * 40, 520, 2200);
	          return;
	        }
	        if (currentBook.format === 'pdf') bumpSetting('pdfZoom', direction * 10, 50, 220);
	        else bumpSetting('fontSize', direction * 1, 12, 32);
	      }, { passive: false });

      const onMouseNav = (e) => {
        if (e.button === 3) {
          e.preventDefault();
          // In reader: use reader history; otherwise use view navigation
          if (currentBook) {
            if (!navigateReaderBack()) {
              // No more reader history, could go back to library but let's not
            }
          } else {
            goBackNav();
          }
        } else if (e.button === 4) {
          e.preventDefault();
          if (currentBook) {
            navigateReaderForward();
          } else {
            goForwardNav();
          }
        }
      };
      window.addEventListener('mouseup', onMouseNav);
      window.addEventListener('auxclick', onMouseNav);

			    document.addEventListener('keydown', (e) => {
		        if (e.key === 'Escape') {
	            // Check if any modal is open first
	            const modalsOpen = !document.getElementById('settings-modal')?.classList.contains('hidden') ||
	                              !document.getElementById('delete-modal')?.classList.contains('hidden') ||
                              !document.getElementById('note-modal')?.classList.contains('hidden') ||
                              !document.getElementById('insights-modal')?.classList.contains('hidden') ||
                              !document.getElementById('create-library-modal')?.classList.contains('hidden') ||
	                              !document.getElementById('delete-library-modal')?.classList.contains('hidden') ||
	                              !document.getElementById('move-book-modal')?.classList.contains('hidden');

		          closeSearch();
		          hideSettings();
		          hideInsights();
		          hideDeleteModal();
		          hideCreateLibraryModal();
		          hideDeleteLibraryModal();
		          hideMoveBookModal();
		          hideContextMenu();
		          hideNoteModal();
		          const hasBookSearch = currentBook && (isBookSearchResultsVisible() || (els.bookSearch?.value || '').trim());
		          if (modalsOpen) {
		            e.preventDefault();
		            return;
		          }
		          if (hasBookSearch) {
		            e.preventDefault();
		            clearBookSearch();
		            hideBookSearchResults();
		            return;
		          }

	            // If no modals were open and we're in reader, close the book
	            if (!modalsOpen && currentBook) {
	              e.preventDefault();
	              backToLibrary();
            }
	        }
          // Alt+Left: Go back in reader history
          if (e.altKey && e.key === 'ArrowLeft' && currentBook) {
            e.preventDefault();
            navigateReaderBack();
          }
          // Alt+Right: Go forward in reader history
          if (e.altKey && e.key === 'ArrowRight' && currentBook) {
            e.preventDefault();
            navigateReaderForward();
          }
	        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k' && !currentBook) {
	          e.preventDefault();
	          openSearch();
	        }
	        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f' && currentBook) {
	          e.preventDefault();
	          const selection = window.getSelection();
	          const selectedText = selection?.toString()?.trim();
	          if (selectedText && els.bookSearch) {
	            // Get scroll position before search
	            const scrollTop = els.readerContent?.scrollTop || 0;
	            els.bookSearch.value = selectedText;
	            searchInBook({ keepPosition: true, scrollTop });
	          }
	          els.bookSearch?.focus();
	          els.bookSearch?.select();
	        }
	        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'b' && currentBook) {
	          e.preventDefault();
	          toggleReaderTopBar();
	        }
	        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'o') {
	          e.preventDefault();
	          importDir();
	        }
	      });
	    }

    async function selectLibrary(id) {
      selectedLibraryId = id;
      selectedFolderNodeId = '__ALL__';
      expandedFolderIds.clear();
      await persistSelectedLibrary(id);
      renderLibraries();
      renderFolderTree();
      renderBooks();
    }

    function updateSort(value) {
      state.settings.librarySort = value;
      ipcRenderer.invoke('update-settings', state.settings);
      renderBooks();
    }

    function toggleSortDir() {
      state.settings.librarySortDir = (state.settings.librarySortDir || 'desc') === 'asc' ? 'desc' : 'asc';
      ipcRenderer.invoke('update-settings', state.settings);
      renderBooks();
    }

	    function searchLibrary(query) {
	      libraryQuery = String(query || '');
	      if (els.librarySearchInput && els.librarySearchInput.value !== libraryQuery) {
	        els.librarySearchInput.value = libraryQuery;
	      }
	      if (els.librarySearch) els.librarySearch.classList.toggle('has-query', !!libraryQuery.trim());
	      renderBooks();
	    }

	    function clearLibrarySearch() {
	      libraryQuery = '';
	      if (els.librarySearchInput) els.librarySearchInput.value = '';
	      if (els.librarySearch) els.librarySearch.classList.remove('has-query');
	      renderBooks();
	    }

	    // Library search (inline omnibox)
	    let librarySearchState = {
	      open: false,
	      selectedIndex: 0,
	      books: [],
	      debounce: null
	    };

	    function openSearch() {
	      if (!els.librarySearchInput) return;
	      els.librarySearchInput.focus();
	      els.librarySearchInput.select();
	      openLibrarySearchPopover();
	      renderLibrarySearchPopover();
	    }

	    function closeSearch(opts = {}) {
	      const { clear = false } = opts || {};
	      if (clear) clearLibrarySearch();
	      closeLibrarySearchPopover();
	    }

	    function openLibrarySearchPopover() {
	      if (!els.librarySearchPopover) return;
	      els.librarySearch.classList.add('active');
	      els.librarySearchPopover.classList.add('active');
	      librarySearchState.open = true;
	    }

	    function closeLibrarySearchPopover() {
	      if (!els.librarySearchPopover) return;
	      els.librarySearch.classList.remove('active');
	      els.librarySearchPopover.classList.remove('active');
	      librarySearchState.open = false;
	      librarySearchState.selectedIndex = 0;
	      librarySearchState.books = [];
	      searchFilters = { format: null, status: null };
	      if (els.librarySearchList) els.librarySearchList.innerHTML = '';
	      if (els.librarySearchInput) els.librarySearchInput.value = '';
	      els.librarySearchPopover.classList.remove('has-query');
	    }

	    function highlightTokensHtml(text, tokens) {
	      const raw = String(text || '');
	      if (!raw || !tokens?.length) return escapeHtml(raw);
	      const lower = raw.toLowerCase();
	      const ranges = [];
	      for (const t of tokens) {
	        const token = String(t || '').trim();
	        if (!token) continue;
	        const idx = lower.indexOf(token);
	        if (idx >= 0) ranges.push([idx, idx + token.length]);
	      }
	      if (!ranges.length) return escapeHtml(raw);
	      ranges.sort((a, b) => a[0] - b[0]);
	      const merged = [];
	      for (const r of ranges) {
	        const last = merged[merged.length - 1];
	        if (!last || r[0] > last[1]) merged.push([r[0], r[1]]);
	        else last[1] = Math.max(last[1], r[1]);
	      }
	      let out = '';
	      let pos = 0;
	      for (const [s, e] of merged) {
	        out += escapeHtml(raw.slice(pos, s));
	        out += `<mark>${escapeHtml(raw.slice(s, e))}</mark>`;
	        pos = e;
	      }
	      out += escapeHtml(raw.slice(pos));
	      return out;
	    }

	    function computeLibrarySearchResults(query) {
	      const tokens = tokenizeQuery(query);
	      const base = getBooksInCurrentScope().filter(matchesFilters);
	      if (!tokens.length) return [];
	      const scored = base
	        .map(b => ({ b, score: scoreBookForTokens(b, tokens) }))
	        .filter(x => x.score > 0)
	        .sort((a, b) => b.score - a.score || (String(a.b.title || '')).localeCompare(String(b.b.title || ''), undefined, { sensitivity: 'base' }));
	      return scored.slice(0, 10).map(x => x.b);
	    }

	    function getRecentBooksForSearch(limit = 8) {
	      return getBooksInCurrentScope()
	        .filter(b => (b.lastRead || 0) > 0)
	        .filter(matchesFilters)
	        .sort((a, b) => (b.lastRead || 0) - (a.lastRead || 0))
	        .slice(0, limit);
	    }

	    function renderLibrarySearchPopover() {
	      if (!els.librarySearchInput || !els.librarySearchPopover || !els.librarySearchList) return;

	      const query = String(els.librarySearchInput.value || '');
	      const tokens = tokenizeQuery(query);
	      const isEmpty = tokens.length === 0;
	      const list = els.librarySearchList;
	      const hasFilters = searchFilters.format || searchFilters.status;

	      // Update filter chip states
	      els.librarySearchPopover.querySelectorAll('.filter-chip').forEach(chip => {
	        const f = chip.dataset.filter, v = chip.dataset.value;
	        chip.classList.toggle('active', searchFilters[f] === v);
	      });

	      els.librarySearchPopover.classList.toggle('has-query', !!query.trim() || hasFilters);

	      // Show recent searches when empty
	      if (isEmpty && !hasFilters && recentSearches.length > 0) {
	        const recentBooks = getRecentBooksForSearch(5);
	        let html = `<div class="pop-section">Recent Searches</div>`;
	        html += recentSearches.map(q => `<button type="button" class="pop-recent-search" data-query="${escapeHtml(q)}"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14"><path d="M12 8v4l3 3"/><circle cx="12" cy="12" r="9"/></svg>${escapeHtml(q)}</button>`).join('');
	        if (recentBooks.length) {
	          html += `<div class="pop-section">Recent Books</div>`;
	          html += recentBooks.map((b, i) => renderSearchResultItem(b, i, tokens)).join('');
	        }
	        list.innerHTML = html;
	        librarySearchState.books = recentBooks;
	        librarySearchState.selectedIndex = 0;
	        loadCoversForLibrarySearch(list);
	        return;
	      }

	      const items = isEmpty ? getRecentBooksForSearch(8) : computeLibrarySearchResults(query);
	      librarySearchState.books = items;
	      librarySearchState.selectedIndex = 0;

	      if (!items.length) {
	        const emptyMsg = isEmpty ? 'No recent books' : 'No results found';
	        list.innerHTML = `<div class="pop-empty"><svg class="pop-empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>${escapeHtml(emptyMsg)}</div>`;
	        return;
	      }

	      const sectionLabel = isEmpty ? 'Recent' : 'Results';
	      list.innerHTML = `<div class="pop-section">${sectionLabel}</div>` + items.map((b, i) => renderSearchResultItem(b, i, tokens)).join('');
	      loadCoversForLibrarySearch(list);
	    }

	    function renderSearchResultItem(b, i, tokens) {
	      const pct = Math.max(0, Math.min(100, Math.round((b.progress || 0) * 100)));
	      const titleHtml = highlightTokensHtml(b.title || 'Untitled', tokens);
	      const authorHtml = highlightTokensHtml(b.author || 'Unknown', tokens);
	      const formatBadge = b.format ? `<span class="pop-format">${b.format.toUpperCase()}</span>` : '';
	      return `
	        <button type="button" class="pop-item${i === 0 ? ' selected' : ''}" data-book-id="${escapeHtml(b.id)}" data-index="${i}">
	          <div class="pop-cover" data-cover-book-id="${escapeHtml(b.id)}">
	            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"/></svg>
	          </div>
	          <div class="pop-info">
	            <div class="pop-titleline">${titleHtml}</div>
	            <div class="pop-metaline">${authorHtml} ${formatBadge}</div>
	          </div>
	          <div class="pop-badge">${pct}%</div>
	        </button>
	      `;
	    }

	    function loadCoversForLibrarySearch(container) {
	      if (!container) return;
	      const covers = container.querySelectorAll('[data-cover-book-id]');
	      covers.forEach((el) => {
	        const id = el.getAttribute('data-cover-book-id');
	        if (!id) return;
	        const url = coverUrlCache.get(id);
	        if (url) el.innerHTML = `<img src="${url}" alt="">`;
	      });
	    }

	    function updateLibrarySearchSelection(nextIndex) {
	      if (!els.librarySearchList) return;
	      const items = els.librarySearchList.querySelectorAll('.pop-item');
	      if (!items.length) return;
	      librarySearchState.selectedIndex = Math.max(0, Math.min(items.length - 1, nextIndex));
	      items.forEach((el, i) => el.classList.toggle('selected', i === librarySearchState.selectedIndex));
	      items[librarySearchState.selectedIndex]?.scrollIntoView({ block: 'nearest' });
	    }

	    function selectLibrarySearchIndex(idx) {
	      const book = librarySearchState.books?.[idx];
	      if (!book?.id) return;
	      const query = String(els.librarySearchInput?.value || '').trim();
	      if (query) addRecentSearch(query);
	      closeSearch({ clear: false });
	      openBook(book.id);
	    }

	    function toggleSearchFilter(filterType, value) {
	      if (searchFilters[filterType] === value) {
	        searchFilters[filterType] = null;
	      } else {
	        searchFilters[filterType] = value;
	      }
	      renderLibrarySearchPopover();
	    }

	    function onLibrarySearchInput() {
	      if (!els.librarySearchInput) return;
	      const q = String(els.librarySearchInput.value || '');
	      els.librarySearchPopover?.classList.toggle('has-query', !!q.trim());

	      clearTimeout(librarySearchState.debounce);
	      librarySearchState.debounce = setTimeout(() => {
	        searchLibrary(q);
	      }, 70);

	      renderLibrarySearchPopover();
	    }

	    function onLibrarySearchKeydown(e) {
	      if (!els.librarySearchList) return;
	      const hasItems = !!els.librarySearchList.querySelector('.pop-item');
	      if (e.key === 'ArrowDown') {
	        e.preventDefault();
	        e.stopPropagation();
	        if (!librarySearchState.open) openLibrarySearchPopover();
	        updateLibrarySearchSelection(librarySearchState.selectedIndex + 1);
	      } else if (e.key === 'ArrowUp') {
	        e.preventDefault();
	        e.stopPropagation();
	        if (!librarySearchState.open) openLibrarySearchPopover();
	        updateLibrarySearchSelection(librarySearchState.selectedIndex - 1);
	      } else if (e.key === 'Enter') {
	        if (!hasItems) return;
	        e.preventDefault();
	        e.stopPropagation();
	        selectLibrarySearchIndex(librarySearchState.selectedIndex);
	      } else if (e.key === 'Escape') {
	        e.preventDefault();
	        e.stopPropagation();
	        const q = String(els.librarySearchInput?.value || '').trim();
	        if (q) {
	          els.librarySearchInput.value = '';
	          onLibrarySearchInput();
	          els.librarySearchInput.focus();
	          return;
	        }
	        closeSearch({ clear: false });
	        els.librarySearchInput?.blur();
	      }
	    }

	    function bindLibrarySearch() {
	      if (!els.librarySearchInput || !els.librarySearchClear || !els.librarySearchPopover || !els.librarySearchList) return;

	      // Trigger opens the modal
	      els.librarySearchTrigger?.addEventListener('click', () => {
	        openLibrarySearchPopover();
	        renderLibrarySearchPopover();
	        setTimeout(() => els.librarySearchInput?.focus(), 50);
	      });

	      els.librarySearchInput.addEventListener('input', onLibrarySearchInput);
	      els.librarySearchInput.addEventListener('keydown', onLibrarySearchKeydown);

	      els.librarySearchClear.addEventListener('click', () => {
	        if (!els.librarySearchInput) return;
	        els.librarySearchInput.value = '';
	        onLibrarySearchInput();
	        els.librarySearchInput.focus();
	      });

	      els.librarySearchPopover.addEventListener('mousemove', (e) => {
	        const item = e.target?.closest?.('.pop-item[data-index]');
	        if (!item) return;
	        const idx = Number(item.getAttribute('data-index') || '0');
	        if (!Number.isNaN(idx)) updateLibrarySearchSelection(idx);
	      });
	      els.librarySearchPopover.addEventListener('click', (e) => {
	        // Filter chip click
	        const chip = e.target?.closest?.('.filter-chip');
	        if (chip) {
	          e.preventDefault();
	          toggleSearchFilter(chip.dataset.filter, chip.dataset.value);
	          els.librarySearchInput?.focus();
	          return;
	        }
	        // Recent search click
	        const recentSearch = e.target?.closest?.('.pop-recent-search');
	        if (recentSearch) {
	          e.preventDefault();
	          const q = recentSearch.dataset.query;
	          if (q && els.librarySearchInput) {
	            els.librarySearchInput.value = q;
	            onLibrarySearchInput();
	            els.librarySearchInput.focus();
	          }
	          return;
	        }
	        // Book item click
	        const item = e.target?.closest?.('.pop-item[data-book-id]');
	        if (!item) return;
	        const bookId = item.getAttribute('data-book-id');
	        if (!bookId) return;
	        const query = String(els.librarySearchInput?.value || '').trim();
	        if (query) addRecentSearch(query);
	        closeSearch({ clear: false });
	        openBook(bookId);
	      });

	      if (els.searchOverlay) {
	        els.searchOverlay.addEventListener('click', () => {
	          closeSearch({ clear: false });
	        });
	      }
	    }

    function showCreateLibraryModal() {
      els.newLibraryName.value = '';
      els.createLibraryModal.classList.remove('hidden');
      setTimeout(() => els.newLibraryName.focus(), 0);
    }

    function hideCreateLibraryModal() {
      els.createLibraryModal.classList.add('hidden');
    }

    async function createEmptyLibrary() {
      const name = (els.newLibraryName.value || '').trim() || 'New Library';
      try {
        const lib = await ipcRenderer.invoke('create-empty-library', name);
        hideCreateLibraryModal();
        await refreshState();
        showToast(`Created "${name}"`, 'success');
        await selectLibrary(lib.id);
      } catch (e) {
        showToast(e?.message || 'Failed to create library', 'error');
      }
    }

    async function createLibraryFromDir() {
      const name = (els.newLibraryName.value || '').trim();
      const dir = await ipcRenderer.invoke('select-directory');
      if (!dir) return;
      const libName = name || path.basename(dir);
      try {
        const lib = await ipcRenderer.invoke('create-library', libName, dir);
        hideCreateLibraryModal();
        await refreshState();
        showToast(`Imported "${libName}"`, 'success');
        await selectLibrary(lib.id);
      } catch (e) {
        showToast(e?.message || 'Import failed', 'error');
      }
    }

    async function importDir() {
      const dir = await ipcRenderer.invoke('select-directory');
      if (!dir) return;
      const libName = path.basename(dir);
      try {
        const lib = await ipcRenderer.invoke('create-library', libName, dir);
        await refreshState();
        showToast(`Imported "${libName}"`, 'success');
        await selectLibrary(lib.id);
      } catch (e) {
        showToast(e?.message || 'Import failed', 'error');
      }
    }

    async function rescanLibrary(libraryId, fullRescan = false) {
      if (fullRescan) {
        if (!window.confirm('Full rescan will rebuild the folder structure from disk and may overwrite manual organization. Continue?')) return;
      }
      showToast(fullRescan ? 'Full rescanning…' : 'Syncing…');
      try {
        await ipcRenderer.invoke('rescan-library', libraryId, !fullRescan);
        await refreshState();
        renderLibraries();
        renderBooks();
        showToast(fullRescan ? 'Rescan complete' : 'Sync complete', 'success');
      } catch (e) {
        showToast(e?.message || 'Rescan failed', 'error');
      }
    }

    function showDeleteModal(bookId) {
      deleteTargetBookId = bookId;
      els.deleteTitle.textContent = `Delete "${state.booksById[bookId]?.title || 'book'}"?`;
      els.deleteModal.classList.remove('hidden');
    }

    function hideDeleteModal() {
      els.deleteModal.classList.add('hidden');
      deleteTargetBookId = null;
    }

    async function deleteBook(fromDisk) {
      if (!deleteTargetBookId) return;
      try {
        await ipcRenderer.invoke('delete-book', deleteTargetBookId, fromDisk);
        hideDeleteModal();
        await refreshState();
        renderLibraries();
        renderBooks();
        showToast(fromDisk ? 'Deleted book from disk' : 'Removed book', 'success');
      } catch (e) {
        showToast(e?.message || 'Delete failed', 'error');
      }
    }

    function showDeleteLibraryModal(libraryId) {
      deleteTargetLibraryId = libraryId;
      const lib = state.libraries.find(l => l.id === libraryId);
      els.deleteLibraryTitle.textContent = `Delete "${lib?.name || 'library'}"?`;
      if (els.deleteLibraryDirBtn) {
        els.deleteLibraryDirBtn.style.display = lib?.path ? 'block' : 'none';
      }
      els.deleteLibraryModal.classList.remove('hidden');
    }

    function hideDeleteLibraryModal() {
      els.deleteLibraryModal.classList.add('hidden');
      deleteTargetLibraryId = null;
    }

    async function deleteLibrary(deleteMode) {
      if (!deleteTargetLibraryId) return;
      try {
        if (deleteMode === 'dir') {
          const lib = state.libraries.find(l => l.id === deleteTargetLibraryId);
          const ok = window.confirm(`This will permanently delete the folder on disk:\n\n${lib?.path || ''}\n\nContinue?`);
          if (!ok) return;
        }
        await ipcRenderer.invoke('delete-library', deleteTargetLibraryId, deleteMode);
        hideDeleteLibraryModal();
        await refreshState();
        renderLibraries();
        renderBooks();
        showToast(deleteMode === 'dir' ? 'Deleted library folder from disk' : 'Removed library', 'success');
      } catch (e) {
        showToast(e?.message || 'Delete failed', 'error');
      }
    }

    async function openBook(id, opts = { pushNav: true }) {
	      // Refresh state to get latest progress
	      await refreshState();
	      currentBook = state.booksById[id];
	      if (!currentBook) return;
      currentTocActiveIndex = -1;
      clearTimeout(readerUiHideTimer);
      clearTimeout(tocHideTimer);
      els.readerView?.classList?.add('reader-ui-hidden');
      els.readerView?.classList?.add('reader-toc-hidden');

        // Clear reader history when opening a new book
        clearReaderHistory();

	      hideSelectionPopup();
	      hideContextMenu();

      els.readerContent.classList.toggle('pdf-mode', currentBook.format === 'pdf');

      els.currentBookTitle.textContent = currentBook.title || 'Untitled';
      els.libraryView.style.display = 'none';
      els.readerView.style.display = 'flex';
      els.readerView.classList.remove('hidden');
      lastOpenedBookId = id;
      if (opts.pushNav) pushNav({ view: 'reader', bookId: id });

      clearBookSearch();
      els.bookmarksSidebar.classList.add('hidden');
      els.tocSidebar.classList.remove('hidden');

      let data;
      try {
        data = await ipcRenderer.invoke('read-book', id);
      } catch (e) {
        showToast(e?.message || 'Failed to open book', 'error');
        els.readerView.style.display = 'none';
        els.libraryView.style.display = 'flex';
        currentBook = null;
        return;
      }
      currentToc = data.toc || [];
      tocCollapseState.clear();
      tocMetadata = [];
      chapterIds = data.chapterIds || [];

	      let heroHtml = '';
	      try {
	        const coverUrl = await ensureCoverUrl(id);
	        if (coverUrl && currentBook.format === 'epub' && settings.showHeroCover !== false) {
	          heroHtml = `
	            <div class="book-hero">
	              <div class="cover"><img src="${coverUrl}" alt=""></div>
	              <div class="meta">
	                <div class="title">${escapeHtml(currentBook.title || 'Untitled')}</div>
	                <div class="sub">${escapeHtml(currentBook.author || '')}</div>
	              </div>
	            </div>
	          `;
	        }
	      } catch (e) {}

      const bodyHtml = heroHtml + (data.chapters || []).map((c, i) =>
        `<div class="chapter" id="chapter-${i}" data-href="${escapeHtml(chapterIds[i] || '')}">${c}</div>`
      ).join('');
      els.readerContent.innerHTML = `<div class="reader-scroll-body">${bodyHtml}</div>`;

      // Handle PDF rendering with PDF.js
      if (currentBook.format === 'pdf' && data.pdfData) {
        try {
          await renderPdfBook(data.pdfData);
          // Progress restoration will be handled by the call after startReadingSession()
        } catch (e) {
          console.error('PDF render error:', e);
          showToast('Failed to render PDF', 'error');
        }
      }

      onAnnotationSearch('');

	      els.readerContent.querySelectorAll('a[href]').forEach(link => {
	        link.addEventListener('click', (e) => {
	          const href = link.getAttribute('href');
	          if (!href) return;
	          if (/^(https?:|mailto:|tel:)/i.test(href)) {
	            e.preventDefault();
	            ipcRenderer.invoke('open-external', href);
	            return;
	          }
	          if (/^(data:|blob:)/i.test(href)) return;
	          if (!href.startsWith('#') && /^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(href)) return;
	          e.preventDefault();
	          navigateToHref(href);
	        });
	      });

	      renderToc();
	      applySettings({ revealReaderUi: false });
      scheduleTocHighlightUpdate();

	      startReadingSession();
	      resumeReaderAtRecordedPosition();
	      updateReaderProgressUi();
	      loadAnnotations().catch(() => {});
	      refreshBookmarksAndHighlights().catch(() => {});
	    }

	    function updateReaderProgressUi() {
	      const pill = document.getElementById('reader-progress-pill');
	      const fill = document.getElementById('reader-progress-fill');
	      if (!pill || !fill) return;
	      const progress = currentBook
	        ? (currentBook.format === 'pdf' ? (currentBook.progress || 0) : getReaderProgress().progress)
	        : 0;
	      const pct = Math.max(0, Math.min(100, Math.round(progress * 100)));
	      pill.textContent = `${pct}%`;
	      fill.style.width = `${pct}%`;
	    }

		    function navigateToHref(href) {
	      const safeDecode = (s) => {
	        const raw = String(s || '');
	        try { return decodeURIComponent(raw); } catch (e) { return raw; }
	      };

	      const [fileRaw, anchorRaw] = String(href || '').split('#');
	      const file = safeDecode(fileRaw || '').split('?')[0];
	      const anchor = safeDecode(anchorRaw || '');

		      if (!file && anchor) {
		        const target = document.getElementById(anchor)
		          || document.querySelector(`[id="${cssEscape(anchor)}"]`)
		          || document.querySelector(`[name="${cssEscape(anchor)}"]`);
		        if (target) target.scrollIntoView({ behavior: 'instant', block: 'center' });
		        return;
		      }
	      const filename = file.split('/').pop();

	      // Find chapter by href
	      let chapterIndex = -1;
	      for (let i = 0; i < chapterIds.length; i++) {
	        const cid = safeDecode(String(chapterIds[i] || '')).split('?')[0];
	        const cidBase = cid.split('/').pop();
	        if ((filename && cidBase === filename) || (filename && cid.includes(filename)) || (file && cid.endsWith(file))) {
	          chapterIndex = i;
	          break;
	        }
	      }

		      if (chapterIndex >= 0) {
		        const chapterEl = document.getElementById('chapter-' + chapterIndex);
		        if (chapterEl) {
		          if (anchor) {
		            const anchorEl = chapterEl.querySelector('#' + cssEscape(anchor))
		              || chapterEl.querySelector('[id="' + cssEscape(anchor) + '"]')
		              || chapterEl.querySelector('[name="' + cssEscape(anchor) + '"]');
		            if (anchorEl) {
		              anchorEl.scrollIntoView({ behavior: 'instant' });
		              return;
		            }
		          }
	          chapterEl.scrollIntoView({ behavior: 'instant' });
	        }
	      }
	    }

    function findTocIndexForChapter(chapterIndex) {
      if (!currentToc.length || chapterIndex < 0) return -1;
      let bestIdx = -1;
      let bestChapter = -1;
      for (let i = 0; i < currentToc.length; i++) {
        const metaCi = Number(tocMetadata[i]?.chapterIndexResolved);
        const itemCi = Number(currentToc[i]?.chapterIndex);
        const ci = Number.isFinite(metaCi) ? metaCi : itemCi;
        if (!Number.isFinite(ci)) continue;
        if (ci === chapterIndex) return i;
        if (ci <= chapterIndex && ci >= bestChapter) {
          bestChapter = ci;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    function splitBookHref(href) {
      const decoded = decodeURIComponentSafe(String(href || '').trim());
      const parts = decoded.split('#');
      const file = decodeURIComponentSafe(String(parts[0] || '')).split('?')[0];
      const anchor = decodeURIComponentSafe(parts.slice(1).join('#')).trim();
      return { file, anchor };
    }

    function findChapterIndexFromHrefFile(file) {
      const normalizedFile = String(file || '').trim();
      if (!normalizedFile || !Array.isArray(chapterIds) || !chapterIds.length) return -1;

      const filename = normalizedFile.split('/').pop();
      for (let i = 0; i < chapterIds.length; i++) {
        const chapterHref = decodeURIComponentSafe(String(chapterIds[i] || '')).split('?')[0];
        const chapterBase = chapterHref.split('/').pop();
        if ((filename && chapterBase === filename) || (filename && chapterHref.includes(filename)) || (normalizedFile && chapterHref.endsWith(normalizedFile))) {
          return i;
        }
      }
      return -1;
    }

    function resolveTocChapterIndex(item) {
      const chapterVal = Number(item?.chapterIndex);
      if (Number.isFinite(chapterVal) && chapterVal >= 0) return chapterVal;
      const { file } = splitBookHref(item?.href || '');
      return findChapterIndexFromHrefFile(file);
    }

    function findTocIndexForEpubPosition(chapterIndex, targetTop) {
      if (!currentToc.length || chapterIndex < 0 || !els.readerContent) return -1;
      if (tocMetadata.length !== currentToc.length) buildTocMetadata();

      const chapterEl = document.getElementById(`chapter-${chapterIndex}`);
      let bestBeforeIndex = -1;
      let bestBeforeTop = -Infinity;
      let bestBeforeLevel = -Infinity;
      let chapterFallback = -1;

      for (let i = 0; i < currentToc.length; i++) {
        const ci = Number(tocMetadata[i]?.chapterIndexResolved);
        if (!Number.isFinite(ci) || ci !== chapterIndex) continue;

        if (chapterFallback === -1) chapterFallback = i;

        const anchorId = String(tocMetadata[i]?.anchorId || '').trim();
        if (!anchorId || !chapterEl) continue;

        const anchorEl = findChapterAnchorElement(chapterEl, anchorId);
        if (!anchorEl) continue;

        const anchorTop = computeScrollTopForElementInContainer(els.readerContent, anchorEl, 'start');
        if (anchorTop === null || anchorTop > targetTop + 6) continue;

        const level = Number(currentToc[i]?.level || 0);
        const isBetterTop = anchorTop > bestBeforeTop;
        const sameTopDeeper = Math.abs(anchorTop - bestBeforeTop) < 1 && level > bestBeforeLevel;
        if (isBetterTop || sameTopDeeper) {
          bestBeforeTop = anchorTop;
          bestBeforeLevel = level;
          bestBeforeIndex = i;
        }
      }

      if (bestBeforeIndex >= 0) return bestBeforeIndex;
      if (chapterFallback >= 0) return chapterFallback;
      return findTocIndexForChapter(chapterIndex);
    }

    function findTocIndexForPage(pageNum) {
      if (!currentToc.length || !Number.isFinite(pageNum)) return -1;
      let bestIdx = -1;
      let bestPage = -Infinity;
      for (let i = 0; i < currentToc.length; i++) {
        const pn = Number(currentToc[i]?.pageNum);
        if (!Number.isFinite(pn)) continue;
        if (pn <= pageNum && pn >= bestPage) {
          bestPage = pn;
          bestIdx = i;
        }
      }
      if (bestIdx !== -1) return bestIdx;
      for (let i = 0; i < currentToc.length; i++) {
        const pn = Number(currentToc[i]?.pageNum);
        if (Number.isFinite(pn) && pn >= pageNum) return i;
      }
      return -1;
    }

    function setActiveTocIndex(idx) {
      if (!els.tocList) return;
      currentTocActiveIndex = idx;
      const visibleIdx = getVisibleActiveIndex(idx);
      const items = els.tocList.querySelectorAll('.toc-item');
      items.forEach((item, i) => {
        const active = i === visibleIdx;
        if (item.classList.contains('active') !== active) {
          item.classList.toggle('active', active);
        }
        if (active && !item.classList.contains('hidden')) {
          item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
      });
    }

    function computeActiveTocIndex() {
      if (!currentBook || !els.readerContent) return -1;
      if (tocMetadata.length !== currentToc.length) buildTocMetadata();
      if (currentBook.format === 'pdf') {
        const pages = Array.from(document.querySelectorAll('.pdf-page'));
        if (!pages.length) return -1;
        const rc = els.readerContent;
        const targetTop = rc.scrollTop + 80;
        let activePage = Number(pages[0]?.dataset.pageNum) || 1;
        let found = false;
        for (const page of pages) {
          const top = page.offsetTop;
          const height = page.offsetHeight || 0;
          const bottom = top + height;
          if (bottom >= targetTop) {
            const pn = Number(page.dataset.pageNum);
            if (Number.isFinite(pn)) activePage = pn;
            found = true;
            break;
          }
        }
        if (!found && pages.some(p => (p.offsetHeight || 0) > 0)) {
          const lastPn = Number(pages[pages.length - 1]?.dataset.pageNum);
          if (Number.isFinite(lastPn)) activePage = lastPn;
        }
        return findTocIndexForPage(activePage);
      }

      const chapters = Array.from(document.querySelectorAll('.chapter'));
      if (!chapters.length) return -1;
      const rc = els.readerContent;
      const targetTop = rc.scrollTop + 80;
      let chapterIndex = chapters.length - 1;
      for (let i = 0; i < chapters.length; i++) {
        const el = chapters[i];
        const top = el.offsetTop;
        const height = el.offsetHeight || 0;
        const bottom = top + height;
        if (bottom >= targetTop) {
          chapterIndex = i;
          break;
        }
      }
      return findTocIndexForEpubPosition(chapterIndex, targetTop);
    }

    function updateActiveTocFromScroll() {
      if (tocClickLock) return;
      const idx = computeActiveTocIndex();
      if (idx !== currentTocActiveIndex) setActiveTocIndex(idx);
    }

    function scheduleTocHighlightUpdate() {
      if (scheduleTocHighlightUpdate._raf) return;
      scheduleTocHighlightUpdate._raf = requestAnimationFrame(() => {
        scheduleTocHighlightUpdate._raf = null;
        updateActiveTocFromScroll();
      });
    }

    function buildFallbackToc() {
      if (currentBook?.format === 'pdf') {
        const pages = pdfDoc?.numPages || 0;
        if (!pages) return [];
        const step = Math.max(1, Math.floor(pages / 24));
        const toc = [];
        for (let p = 1; p <= pages; p += step) {
          toc.push({ title: `Page ${p}`, href: `#pdf-page-${p}`, pageNum: p });
        }
        if (pages > 0 && !toc.some(t => t.pageNum === pages)) toc.push({ title: `Page ${pages}`, href: `#pdf-page-${pages}`, pageNum: pages });
        return toc;
      }
      const chCount = chapterIds.length || document.querySelectorAll('.chapter').length;
      if (chCount) {
        return Array.from({ length: chCount }).map((_, i) => ({
          title: `Chapter ${i + 1}`,
          href: chapterIds[i] || '',
          chapterIndex: i
        }));
      }
      return [];
    }

    function handleReaderArrowNav(e) {
      if (!currentBook || e.defaultPrevented) return;
      const target = e.target;
      const tag = target?.tagName;
      const isEditable = target?.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
      if (isEditable) return;
      if (document.querySelector('.modal:not(.hidden)')) return;
      if (e.altKey || e.metaKey || e.ctrlKey) return;
      const rc = els.readerContent;
      if (!rc) return;
      const base = Math.max(140, Math.floor(rc.clientHeight * 0.82));
      if (e.key === 'ArrowDown' || e.key === 'PageDown') {
        e.preventDefault();
        smoothScrollReader(base);
      } else if (e.key === 'ArrowUp' || e.key === 'PageUp') {
        e.preventDefault();
        smoothScrollReader(-base);
      } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        smoothScrollReader(Math.round(base * 0.65));
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        smoothScrollReader(Math.round(-base * 0.65));
      }
    }

    function buildTocMetadata() {
      tocMetadata = currentToc.map((item, i) => ({
        parentIndex: -1,
        hasChildren: false,
        chapterIndexResolved: -1,
        anchorId: ''
      }));

      // Build parent/child relationships based on level
      const stack = []; // Stack of {index, level}
      for (let i = 0; i < currentToc.length; i++) {
        const level = Number(currentToc[i].level || 0);

        // Pop items from stack that are at same or higher level
        while (stack.length > 0 && stack[stack.length - 1].level >= level) {
          stack.pop();
        }

        // If stack has items, the top is our parent
        if (stack.length > 0) {
          tocMetadata[i].parentIndex = stack[stack.length - 1].index;
          tocMetadata[stack[stack.length - 1].index].hasChildren = true;
        }

        const chapterIndexResolved = resolveTocChapterIndex(currentToc[i]);
        if (chapterIndexResolved >= 0) {
          tocMetadata[i].chapterIndexResolved = chapterIndexResolved;
        }
        const { anchor } = splitBookHref(currentToc[i]?.href || '');
        tocMetadata[i].anchorId = anchor;

        stack.push({ index: i, level });
      }
    }

    function isItemHidden(index) {
      // Check if any ancestor is collapsed
      let parentIdx = tocMetadata[index]?.parentIndex ?? -1;
      while (parentIdx >= 0) {
        if (tocCollapseState.get(parentIdx)) return true;
        parentIdx = tocMetadata[parentIdx]?.parentIndex ?? -1;
      }
      return false;
    }

    function toggleTocCollapse(index, e) {
      if (e) e.stopPropagation();
      clearTimeout(tocHideTimer);
      const isCollapsed = tocCollapseState.get(index) || false;
      tocCollapseState.set(index, !isCollapsed);
      renderToc();
      // Re-apply active state
      setActiveTocIndex(currentTocActiveIndex);
    }

    function getVisibleActiveIndex(actualIndex) {
      // If the actual active item is hidden, find its visible ancestor
      if (actualIndex < 0) return -1;
      if (!isItemHidden(actualIndex)) return actualIndex;

      let parentIdx = tocMetadata[actualIndex]?.parentIndex ?? -1;
      while (parentIdx >= 0) {
        if (!isItemHidden(parentIdx)) return parentIdx;
        parentIdx = tocMetadata[parentIdx]?.parentIndex ?? -1;
      }
      return -1;
    }

    function renderToc() {
	      const list = document.getElementById('toc-list');
      const tocData = currentToc.length ? currentToc : buildFallbackToc();
      if (!currentToc.length && tocData.length) currentToc = tocData;

      // Build metadata if needed
      if (tocMetadata.length !== tocData.length) {
        buildTocMetadata();
      }

	      if (tocData.length === 0) {
	        list.innerHTML = `<div style="padding:16px;color:var(--text-secondary);">${escapeHtml(t('noToc'))}</div>`;
	        setActiveTocIndex(-1);
	        return;
	      }

      const visibleActiveIdx = getVisibleActiveIndex(currentTocActiveIndex);
	      list.innerHTML = tocData.map((item, i) => {
	        const level = Math.max(0, Math.min(6, Number(item.level || 0)));
	        const padding = 18 + level * 14;
	        const active = i === visibleActiveIdx ? ' active' : '';
	        const hidden = isItemHidden(i) ? ' hidden' : '';
	        const meta = tocMetadata[i] || {};
	        const hasChildren = meta.hasChildren;
	        const isCollapsed = tocCollapseState.get(i) || false;
	        const chapterVal = Number(item.chapterIndex);
	        const pageVal = Number(item.pageNum);
	        const chapterIdx = Number.isFinite(chapterVal) ? ` data-chapter-index="${chapterVal}"` : '';
	        const pageNum = Number.isFinite(pageVal) ? ` data-page-num="${pageVal}"` : '';
	        const toggleBtn = hasChildren
	          ? `<span class="toc-toggle" onclick="toggleTocCollapse(${i}, event)">${isCollapsed ? '▶' : '▼'}</span>`
	          : '<span class="toc-toggle-spacer"></span>';
	        return `<div class="toc-item${active}${hidden}" data-toc-index="${i}"${chapterIdx}${pageNum} style="padding-left:${padding}px" onclick="scrollToTocItem(${i})" onauxclick="if(event.button===1){event.preventDefault();toggleTocCollapse(${i},event)}">${toggleBtn}${escapeHtml(item.title || item.href || `Chapter ${i + 1}`)}</div>`;
	      }).join('');
	    }

    function scrollToTocItem(index) {
      const tocItem = currentToc[index];
      if (!tocItem) return;

      tocClickLock = true;
      setTimeout(() => { tocClickLock = false; }, 300);

      // Record current position before navigating
      recordReaderPosition();
      setActiveTocIndex(index);

      // Handle PDF TOC items - use pdfDest for precise navigation
      if (currentBook?.format === 'pdf') {
        if (tocItem.pdfDest) {
          navigateToPdfDest(tocItem.pdfDest);
        } else if (tocItem.pageNum) {
          // Fallback to page-only navigation
          const pageEl = document.getElementById(`pdf-page-${tocItem.pageNum}`);
          if (pageEl) {
            if (!pdfRenderedPages.has(tocItem.pageNum)) {
              pdfRenderedPages.set(tocItem.pageNum, true);
              renderPdfPage(tocItem.pageNum, pageEl).then(() => {
                pageEl.scrollIntoView({ behavior: 'instant', block: 'start' });
              });
            } else {
              pageEl.scrollIntoView({ behavior: 'instant', block: 'start' });
            }
          }
        }
        return;
      }

      // Handle EPUB TOC items
      const chapterIndex = (typeof tocItem.chapterIndex === 'number' && tocItem.chapterIndex >= 0) ? tocItem.chapterIndex : -1;
      const href = tocItem.href || '';
      const anchor = href.includes('#') ? href.split('#')[1] : '';
      if (chapterIndex >= 0) {
        const el = document.getElementById('chapter-' + chapterIndex);
        if (el) {
          el.scrollIntoView({ behavior: 'instant' });
            if (anchor) {
              setTimeout(() => {
                const anchorEl = el.querySelector('#' + cssEscape(anchor))
                  || el.querySelector('[id="' + cssEscape(anchor) + '"]')
                  || el.querySelector('[name="' + cssEscape(anchor) + '"]');
                if (anchorEl) anchorEl.scrollIntoView({ behavior: 'instant', block: 'center' });
              }, 50);
            }
          return;
        }
      }
      if (href) navigateToHref(href);
    }

    function toggleToc() {
      document.getElementById('toc-sidebar').classList.toggle('hidden');
    }

	    function backToLibrary(opts = { pushNav: true }) {
	      stopReadingSession();
	      hideSelectionPopup();
	      hideContextMenu();
      document.getElementById('reader-view').style.display = 'none';
      document.getElementById('library-view').style.display = 'flex';
      currentBook = null;
      currentTocActiveIndex = -1;
      clearTimeout(readerUiHideTimer);
      clearTimeout(tocHideTimer);
      els.readerView?.classList?.remove('reader-ui-hidden');
      els.readerView?.classList?.remove('reader-toc-hidden');
      if (opts.pushNav) pushNav({ view: 'library' });
      refreshState().then(() => {
        renderLibraries();
        renderStats();
        renderBooks();
      });
    }

    function showSettings() { document.getElementById('settings-modal').classList.remove('hidden'); }
    function hideSettings() { document.getElementById('settings-modal').classList.add('hidden'); }

	    function applySettings(opts = {}) {
      const revealReaderUi = opts.revealReaderUi !== false;
	      const rc = document.getElementById('reader-content');
	      const systemStack = "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
	      const mode = settings.fontMode || 'book';
      if (mode === 'book') rc.style.removeProperty('font-family');
      else if (mode === 'system') rc.style.setProperty('font-family', systemStack, 'important');
      else rc.style.setProperty('font-family', (settings.fontFamily || systemStack), 'important');
      rc.style.fontSize = settings.fontSize + 'px';
      rc.style.lineHeight = settings.lineHeight;
      rc.style.padding = settings.margin + 'px';
      rc.style.setProperty('background-color', settings.bgColor, 'important');
      rc.style.setProperty('color', settings.textColor, 'important');
      if (currentBook && revealReaderUi) showReaderUiTemporarily();

      const fontModeEl = document.getElementById('font-mode');
      const fontCustomEl = document.getElementById('font-custom');
      const fontFamilyEl = document.getElementById('font-family-input');
      if (fontModeEl) fontModeEl.value = mode;
      if (fontCustomEl) fontCustomEl.classList.toggle('hidden', mode !== 'custom');
      if (fontFamilyEl) fontFamilyEl.value = settings.fontFamily || '';

      document.getElementById('font-size').value = settings.fontSize;
      document.getElementById('font-size-val').textContent = settings.fontSize;
      document.getElementById('line-height').value = settings.lineHeight;
      document.getElementById('line-height-val').textContent = settings.lineHeight.toFixed(1);
      document.getElementById('margin').value = settings.margin;
      document.getElementById('margin-val').textContent = settings.margin;
      const bgEl = document.getElementById('bg-color');
      const textEl = document.getElementById('text-color');
      if (bgEl) bgEl.value = settings.bgColor || '#fdfcfa';
      if (textEl) textEl.value = settings.textColor || '#37352f';
      const pdfZoom = document.getElementById('pdf-zoom');
      const pdfZoomVal = document.getElementById('pdf-zoom-val');
      if (pdfZoom) pdfZoom.value = String(settings.pdfZoom || 120);
      if (pdfZoomVal) pdfZoomVal.textContent = String(settings.pdfZoom || 120);
		      const readerWidth = document.getElementById('reader-width');
		      const readerWidthVal = document.getElementById('reader-width-val');
			      if (readerWidth) readerWidth.value = String(settings.readerMaxWidth || 1600);
			      if (readerWidthVal) readerWidthVal.textContent = String(settings.readerMaxWidth || 1600);
			      document.documentElement.style.setProperty('--reader-max-width', `${settings.readerMaxWidth || 1600}px`);

		      const readerMargin = document.getElementById('reader-margin');
		      const readerMarginVal = document.getElementById('reader-margin-val');
		      if (readerMargin) readerMargin.value = String(settings.readerMargin || 48);
		      if (readerMarginVal) readerMarginVal.textContent = String(settings.readerMargin || 48);
		      document.documentElement.style.setProperty('--reader-margin', `${settings.readerMargin || 48}px`);

		      const tocWidth = document.getElementById('toc-width');
		      const tocWidthVal = document.getElementById('toc-width-val');
		      if (tocWidth) tocWidth.value = String(settings.tocWidth || 300);
		      if (tocWidthVal) tocWidthVal.textContent = String(settings.tocWidth || 300);
		      document.documentElement.style.setProperty('--toc-width', `${settings.tocWidth || 300}px`);

		      const localeSelect = document.getElementById('locale-select');
		      if (localeSelect) localeSelect.value = String(settings.locale || 'system');

		      const fitToggle = document.getElementById('fit-reader-width-toggle');
		      if (fitToggle) fitToggle.checked = settings.fitReaderWidth === true;
		      const topbarToggle = document.getElementById('reader-topbar-toggle');
		      if (topbarToggle) topbarToggle.checked = settings.readerTopBarVisible !== false;

		      els.readerView?.classList?.toggle('fit-reader-width', settings.fitReaderWidth === true);
		      els.readerView?.classList?.toggle('reader-topbar-hidden', settings.readerTopBarVisible === false);
		      document.querySelectorAll('#reader-view header .icon-btn[data-toggle]').forEach(btn => btn.classList.remove('active'));
		      const fitBtn = document.querySelector('#reader-view header .icon-btn[data-toggle="fit"]');
		      if (fitBtn) fitBtn.classList.toggle('active', settings.fitReaderWidth === true);
	      const selectionToggle = document.getElementById('selection-popup-toggle');
	      if (selectionToggle) selectionToggle.checked = settings.selectionPopupEnabled !== false;
	      const tocDelaySlider = document.getElementById('toc-hide-delay');
	      const tocDelayVal = document.getElementById('toc-hide-delay-val');
	      if (tocDelaySlider) tocDelaySlider.value = settings.tocHideDelay || 500;
	      if (tocDelayVal) tocDelayVal.textContent = settings.tocHideDelay || 500;
	      const heroToggle = document.getElementById('hero-cover-toggle');
	      if (heroToggle) heroToggle.checked = settings.showHeroCover !== false;
	      const showFirstCompletionToggle = document.getElementById('show-first-completion-hall-toggle');
	      if (showFirstCompletionToggle) showFirstCompletionToggle.checked = settings.showFirstCompletionInHall !== false;
	      const cardDensitySelect = document.getElementById('card-density');
	      const cardDensity = settings.cardDensity === 'dense' ? 'dense' : 'comfortable';
	      if (cardDensitySelect) cardDensitySelect.value = cardDensity;
	      document.body.dataset.cardDensity = cardDensity;
	      const mainHallTileSize = cardDensity === 'dense' ? '212px' : '228px';
	      document.documentElement.style.setProperty('--main-hall-tile-size', mainHallTileSize);
	      const sidebarCollapseToggle = document.getElementById('sidebar-collapsed-toggle');
	      if (sidebarCollapseToggle) sidebarCollapseToggle.checked = settings.sidebarCollapsed === true;
	      els.libraryView?.classList?.toggle('sidebar-collapsed', settings.sidebarCollapsed === true);
	      document.querySelectorAll('.theme-buttons button[data-theme]').forEach((btn) => {
	        btn.classList.toggle('active', btn.dataset.theme === settings.theme);
	      });

      if (currentBook?.format === 'pdf') {
        // Re-render PDF pages with new theme colors
        rerenderPdfPages();
        resumeReaderAtRecordedPosition();
      }
    }

		    function updateSetting(key, val) {
		      settings[key] = val;
		      ipcRenderer.invoke('update-settings', settings);
		      applySettings();
		      applyAppTheme();
		      applyI18n();
		    }

	    function toggleSidebarCollapsed() {
	      updateSetting('sidebarCollapsed', !(settings.sidebarCollapsed === true));
	    }

	    function fitReaderWidth() {
	      updateSetting('fitReaderWidth', !(settings.fitReaderWidth === true));
	    }

	    function toggleReaderTopBar(forceVisible) {
	      const next = (typeof forceVisible === 'boolean')
	        ? forceVisible
	        : !(settings.readerTopBarVisible !== false);
	      updateSetting('readerTopBarVisible', next);
	    }

    function bumpSetting(key, delta, min, max) {
      const next = Math.max(min, Math.min(max, (Number(settings[key] || 0) + delta)));
      settings[key] = next;
      applySettings();
      applyAppTheme();
      clearTimeout(bumpSetting._t);
      bumpSetting._t = setTimeout(() => ipcRenderer.invoke('update-settings', settings), 250);
    }

    function pushNav(entry) {
      navigation.stack = navigation.stack.slice(0, navigation.index + 1);
      navigation.stack.push(entry);
      navigation.index = navigation.stack.length - 1;
    }

    function canGoBack() { return navigation.index > 0; }
    function canGoForward() { return navigation.index < navigation.stack.length - 1; }

    async function goBackNav() {
      if (!canGoBack()) return;
      navigation.index -= 1;
      const entry = navigation.stack[navigation.index];
      if (entry.view === 'reader' && entry.bookId) await openBook(entry.bookId, { pushNav: false });
      else backToLibrary({ pushNav: false });
    }

    async function goForwardNav() {
      if (!canGoForward()) {
        if (!currentBook && lastOpenedBookId) await openBook(lastOpenedBookId);
        return;
      }
      navigation.index += 1;
      const entry = navigation.stack[navigation.index];
      if (entry.view === 'reader' && entry.bookId) await openBook(entry.bookId, { pushNav: false });
      else backToLibrary({ pushNav: false });
    }

    async function chooseAppBackgroundImage() {
      try {
        const files = await ipcRenderer.invoke('show-open-dialog', {
          title: 'Choose background image',
          properties: ['openFile'],
          filters: [{ name: 'Images', extensions: ['png', 'jpg', 'jpeg', 'webp', 'gif'] }]
        });
        const filePath = files?.[0];
        if (!filePath) return;
        settings.appBgImageUrl = pathToFileURL(filePath).toString();
        ipcRenderer.invoke('update-settings', settings);
        applyAppTheme();
      } catch (e) {
        showToast(e?.message || 'Failed to set background image', 'error');
      }
    }

    function clearAppBackgroundImage() {
      settings.appBgImageUrl = '';
      ipcRenderer.invoke('update-settings', settings);
      applyAppTheme();
    }

    function updateFontMode(mode) {
      settings.fontMode = mode;
      if (mode === 'system') settings.fontFamily = '';
      ipcRenderer.invoke('update-settings', settings);
      applySettings();
    }

    function updateCustomFont(fontFamily) {
      settings.fontMode = 'custom';
      settings.fontFamily = fontFamily;
      ipcRenderer.invoke('update-settings', settings);
      applySettings();
    }

    async function reloadSystemFonts() {
      try {
        const fonts = await ipcRenderer.invoke('list-system-fonts');
        const dl = document.getElementById('system-fonts');
        if (!dl) return;
        dl.innerHTML = (fonts || []).slice(0, 5000).map(f => `<option value="${escapeHtml(f)}"></option>`).join('');
        showToast(`Loaded ${Math.min((fonts || []).length, 5000)} fonts`, 'success');
      } catch (e) {
        showToast(e?.message || 'Failed to load fonts', 'error');
      }
    }

    function setTheme(theme, bg, text) {
      settings.theme = theme;
      settings.bgColor = bg;
      settings.textColor = text;
      ipcRenderer.invoke('update-settings', settings);
      applySettings();
      applyAppTheme();
    }

    function setReaderTheme(bg, text) {
      settings.bgColor = bg;
      settings.textColor = text;
      ipcRenderer.invoke('update-settings', settings);
      applySettings();
    }

    async function removeFromRecent(bookId) {
      await ipcRenderer.invoke('update-book', bookId, { lastRead: 0 });
      await refreshState();
      renderRecent();
    }

    async function exportAppData() {
      try {
        const filePath = await ipcRenderer.invoke('show-save-dialog', {
          title: 'Export RoseReader data',
          defaultPath: 'rosereader-data.json',
          filters: [{ name: 'JSON', extensions: ['json'] }]
        });
        if (!filePath) return;
        const result = await ipcRenderer.invoke('export-data', filePath);
        if (result?.success) showToast('Exported data', 'success');
        else showToast(result?.error || 'Export failed', 'error');
      } catch (e) {
        showToast(e?.message || 'Export failed', 'error');
      }
    }

    async function importAppData() {
      try {
        const files = await ipcRenderer.invoke('show-open-dialog', {
          title: 'Import RoseReader data',
          properties: ['openFile'],
          filters: [{ name: 'JSON', extensions: ['json'] }]
        });
        const filePath = files?.[0];
        if (!filePath) return;
        const result = await ipcRenderer.invoke('import-data', filePath);
        if (!result?.success) {
          showToast(result?.error || 'Import failed', 'error');
          return;
        }
        await refreshState();
        renderLibraries();
        renderStats();
        renderBooks();
        applySettings();
        showToast('Imported data', 'success');
      } catch (e) {
        showToast(e?.message || 'Import failed', 'error');
      }
    }

    async function mergeMovedBookStateNow() {
      try {
        const result = await ipcRenderer.invoke('merge-moved-book-state');
        const mergedCount = Math.max(0, Number(result?.mergedCount || 0));
        if (mergedCount > 0) {
          await refreshState();
          renderLibraries();
          renderStats();
          renderBooks();
          showToast(t('mergeMovedBooksDone').replace('{n}', String(mergedCount)), 'success', 3200);
          return;
        }
        showToast(t('mergeMovedBooksNone'), 'info');
      } catch (e) {
        showToast(e?.message || t('mergeMovedBooksFailed'), 'error');
      }
    }

	    function beginReaderResumeRun() {
	      if (!readerResumeState) {
	        readerResumeState = { nextRunId: 0, activeRunId: 0, applying: false, releaseTimer: null };
	      }

	      if (readerResumeState.releaseTimer) {
	        clearTimeout(readerResumeState.releaseTimer);
	        readerResumeState.releaseTimer = null;
	      }

	      readerResumeState.nextRunId += 1;
	      const runId = readerResumeState.nextRunId;
	      readerResumeState.activeRunId = runId;
	      readerResumeState.applying = true;
	      return runId;
	    }

	    function endReaderResumeRun(runId, holdMs = 320) {
	      if (!readerResumeState) return;
	      if (runId !== readerResumeState.activeRunId) return;

	      if (readerResumeState.releaseTimer) {
	        clearTimeout(readerResumeState.releaseTimer);
	      }

	      const delay = Math.max(0, Number(holdMs) || 0);
	      readerResumeState.releaseTimer = setTimeout(() => {
	        if (readerResumeState.activeRunId !== runId) return;
	        readerResumeState.applying = false;
	        readerResumeState.releaseTimer = null;
	      }, delay);
	    }

	    function cancelReaderResumeRun() {
	      if (!readerResumeState) return;
	      if (readerResumeState.releaseTimer) {
	        clearTimeout(readerResumeState.releaseTimer);
	        readerResumeState.releaseTimer = null;
	      }
	      readerResumeState.nextRunId += 1;
	      readerResumeState.activeRunId = readerResumeState.nextRunId;
	      readerResumeState.applying = false;
	    }

	    function isReaderResumeRunActive(runId) {
	      return !!(readerResumeState && runId === readerResumeState.activeRunId);
	    }

	    function getChapterHeight(chapterEl) {
	      if (!chapterEl) return 1;
	      return Math.max(
	        1,
	        chapterEl.scrollHeight,
	        chapterEl.offsetHeight,
	        chapterEl.getBoundingClientRect().height || 0
	      );
	    }

	    function getProgressRatio() {
	      if (!currentBook) return 0;
	      return Math.max(0, Math.min(1, Number(currentBook.progress || 0)));
	    }

	    function normalizeHrefForCompare(value) {
	      return decodeURIComponentSafe(String(value || '')).split('#')[0].split('?')[0];
	    }

	    function pickBestChapterAnchor(chapterEl, progressOffset = 0) {
	      if (!chapterEl) return '';

	      const targetOffset = Math.max(0, Number(progressOffset || 0));
	      const chapterRect = chapterEl.getBoundingClientRect();
	      const candidates = chapterEl.querySelectorAll('[id], [name]');
	      if (!candidates.length) return '';

	      let bestBefore = null;
	      let bestNear = null;
	      for (const node of candidates) {
	        const anchorId = (node.id || node.getAttribute('name') || '').trim();
	        if (!anchorId) continue;

	        const rect = node.getBoundingClientRect();
	        const offsetTop = rect.top - chapterRect.top;
	        if (!Number.isFinite(offsetTop)) continue;

	        const distance = targetOffset - offsetTop;
	        const absDistance = Math.abs(distance);

	        if (!bestNear || absDistance < bestNear.absDistance) {
	          bestNear = { anchorId, absDistance };
	        }

	        if (offsetTop <= targetOffset + 24) {
	          if (!bestBefore || offsetTop > bestBefore.offsetTop) {
	            bestBefore = { anchorId, offsetTop };
	          }
	        }
	      }

	      if (bestBefore && (targetOffset - bestBefore.offsetTop) <= 420) {
	        return bestBefore.anchorId;
	      }
	      if (bestNear && bestNear.absDistance <= 120) {
	        return bestNear.anchorId;
	      }

	      return '';
	    }

	    function temporarilyForceChapterVisible(chapterEl, holdMs = 1200) {
	      if (!chapterEl) return;
	      const previous = chapterEl.style.contentVisibility;
	      chapterEl.style.contentVisibility = 'visible';
	      void chapterEl.offsetHeight;

	      const timers = temporarilyForceChapterVisible._timers || (temporarilyForceChapterVisible._timers = new WeakMap());
	      const pending = timers.get(chapterEl);
	      if (pending) clearTimeout(pending);

	      const release = () => {
	        if (previous) {
	          chapterEl.style.contentVisibility = previous;
	        } else {
	          chapterEl.style.removeProperty('content-visibility');
	        }
	        timers.delete(chapterEl);
	      };

	      const timer = setTimeout(release, Math.max(200, Number(holdMs) || 1200));
	      timers.set(chapterEl, timer);
	    }

	    function findChapterAnchorElement(chapterEl, anchorId) {
	      if (!chapterEl) return null;
	      const normalized = decodeURIComponentSafe(String(anchorId || '').trim());
	      if (!normalized) return null;
	      return chapterEl.querySelector('#' + cssEscape(normalized))
	        || chapterEl.querySelector('[id="' + cssEscape(normalized) + '"]')
	        || chapterEl.querySelector('[name="' + cssEscape(normalized) + '"]');
	    }

	    function getElementOffsetInChapter(chapterEl, element) {
	      if (!chapterEl || !element) return null;
	      const chapterRect = chapterEl.getBoundingClientRect();
	      const elementRect = element.getBoundingClientRect();
	      const offset = elementRect.top - chapterRect.top;
	      return Number.isFinite(offset) ? offset : null;
	    }

	    function deriveLegacyEpubSnapshot() {
	      if (!currentBook || currentBook.format !== 'epub') return null;
	      if (!Array.isArray(chapterIds) || chapterIds.length === 0) return null;

	      const chapterIndex = Math.max(0, Number(currentBook.progressChapter || 0));
	      const href = String(chapterIds[chapterIndex] || '').trim();
	      if (!href) return null;

	      const chapterEl = els.readerContent?.querySelector?.(`#chapter-${chapterIndex}`);
	      const offset = Math.max(0, Number(currentBook.progressOffset || 0));
	      const ratio = chapterEl
	        ? Math.max(0, Math.min(1, offset / getChapterHeight(chapterEl)))
	        : 0;
	      let anchor = chapterEl ? pickBestChapterAnchor(chapterEl, offset) : '';
	      let anchorDelta = null;
	      if (chapterEl && anchor) {
	        const anchorEl = findChapterAnchorElement(chapterEl, anchor);
	        const anchorOffset = getElementOffsetInChapter(chapterEl, anchorEl);
	        if (Number.isFinite(anchorOffset)) {
	          anchorDelta = Math.max(-4000, Math.min(4000, offset - anchorOffset));
	          if (Math.abs(anchorDelta) > 1400) {
	            anchor = '';
	            anchorDelta = null;
	          }
	        }
	      }

	      return {
	        href,
	        ratio,
	        anchor,
	        anchorDelta,
	        fromLegacy: true
	      };
	    }

	    function findEpubResumeTarget(epubSnapshot) {
	      if (!epubSnapshot || typeof epubSnapshot !== 'object') return null;
	      const hrefRaw = String(epubSnapshot.href || '').trim();
	      if (!hrefRaw) return null;

	      const href = normalizeHrefForCompare(hrefRaw);
	      const hrefBase = href.split('/').pop();
	      const chapters = els.readerContent?.querySelectorAll?.('.chapter') || [];
	
	      for (const chapter of chapters) {
	        const chapterHref = normalizeHrefForCompare(chapter?.dataset?.href || '');
	        const chapterBase = chapterHref.split('/').pop();
	        const isMatch = (hrefBase && chapterBase === hrefBase)
	          || (href && chapterHref.endsWith(href))
	          || (href && chapterHref === href);
	        if (!isMatch) continue;

	        const anchor = decodeURIComponentSafe(String(epubSnapshot.anchor || '').trim());
	        const anchorEl = findChapterAnchorElement(chapter, anchor);
	        const ratio = Math.max(0, Math.min(1, Number(epubSnapshot.ratio || 0)));
	        const rawAnchorDelta = Number(epubSnapshot.anchorDelta);
	        let anchorDelta = Number.isFinite(rawAnchorDelta)
	          ? Math.max(-4000, Math.min(4000, rawAnchorDelta))
	          : null;

	        if (anchorEl && !Number.isFinite(anchorDelta)) {
	          const anchorOffset = getElementOffsetInChapter(chapter, anchorEl);
	          if (Number.isFinite(anchorOffset)) {
	            anchorDelta = Math.max(-4000, Math.min(4000, (getChapterHeight(chapter) * ratio) - anchorOffset));
	          }
	        }

	        if (Number.isFinite(anchorDelta) && Math.abs(anchorDelta) > 1800) {
	          anchorDelta = null;
	        }

	        return {
	          chapter,
	          anchorEl,
	          ratio,
	          anchorDelta
	        };
	      }

	      return null;
	    }

	    function computeTopFromRatio(chapterEl, ratio) {
	      if (!els.readerContent || !chapterEl) return null;

	      const container = els.readerContent;
	      const chapterRect = chapterEl.getBoundingClientRect();
	      const containerRect = container.getBoundingClientRect();
	      const chapterTop = container.scrollTop + (chapterRect.top - containerRect.top);
	      const desired = chapterTop + (getChapterHeight(chapterEl) * ratio);
	      const maxTop = Math.max(0, container.scrollHeight - container.clientHeight);
	      return Math.max(0, Math.min(maxTop, desired));
	    }

	    function applyReaderResumeRatio(chapterEl, ratio, runId) {
	      if (!isReaderResumeRunActive(runId) || !els.readerContent || !chapterEl?.isConnected) return false;
	      temporarilyForceChapterVisible(chapterEl, 1150);

	      const top = computeTopFromRatio(chapterEl, ratio);
	      if (top === null) return false;
	      els.readerContent.scrollTo({ top, behavior: 'auto' });

	      [260, 900].forEach((delay) => {
	        setTimeout(() => {
	          if (!isReaderResumeRunActive(runId) || !els.readerContent || !chapterEl?.isConnected) return;
	          const settledTop = computeTopFromRatio(chapterEl, ratio);
	          if (settledTop === null) return;
	          if (Math.abs(els.readerContent.scrollTop - settledTop) > 72) {
	            els.readerContent.scrollTo({ top: settledTop, behavior: 'auto' });
	          }
	        }, delay);
	      });

	      return true;
	    }

	    function applyRatioResume(runId, ratio = getProgressRatio()) {
	      if (!isReaderResumeRunActive(runId) || !els.readerContent) return false;

	      const maxTop = Math.max(0, els.readerContent.scrollHeight - els.readerContent.clientHeight);
	      if (maxTop <= 0) return false;

	      els.readerContent.scrollTo({ top: maxTop * ratio, behavior: 'auto' });
	      return true;
	    }

	    function applyLegacyChapterResume(runId) {
	      if (!isReaderResumeRunActive(runId) || !els.readerContent) return false;
	
	      const chapterIndex = Math.max(0, Number(currentBook?.progressChapter || 0));
	      const chapter = document.getElementById(`chapter-${chapterIndex}`);
	      if (!chapter) return false;

	      chapter.scrollIntoView({ behavior: 'instant', block: 'start' });
	      const offset = Math.max(0, Number(currentBook?.progressOffset || 0));
	      if (offset > 0) {
	        const maxTop = Math.max(0, els.readerContent.scrollHeight - els.readerContent.clientHeight);
	        els.readerContent.scrollTop = Math.min(maxTop, Math.max(0, els.readerContent.scrollTop + offset));
	      }
	      return true;
	    }

	    function applyEpubSnapshotResume(runId, epubSnapshot) {
	      if (!isReaderResumeRunActive(runId) || !els.readerContent) return false;
	
	      const target = findEpubResumeTarget(epubSnapshot);
	      if (!target) return false;
	      temporarilyForceChapterVisible(target.chapter, 1250);

	      if (target.anchorEl && Number.isFinite(target.anchorDelta)) {
	        const computeDesiredFromAnchor = () => {
	          const anchorTop = computeScrollTopForElementInContainer(els.readerContent, target.anchorEl, 'start');
	          if (anchorTop === null) return null;
	          const maxTop = Math.max(0, els.readerContent.scrollHeight - els.readerContent.clientHeight);
	          return Math.max(0, Math.min(maxTop, anchorTop + target.anchorDelta));
	        };

	        const desired = computeDesiredFromAnchor();
	        if (desired !== null) {
	          els.readerContent.scrollTo({ top: desired, behavior: 'auto' });

	          [260, 900].forEach((delay) => {
	            setTimeout(() => {
	              if (!isReaderResumeRunActive(runId) || !els.readerContent || !target.anchorEl?.isConnected) return;
	              const settledDesired = computeDesiredFromAnchor();
	              if (settledDesired === null) return;
	              if (Math.abs(els.readerContent.scrollTop - settledDesired) > 72) {
	                els.readerContent.scrollTo({ top: settledDesired, behavior: 'auto' });
	              }
	            }, delay);
	          });
	          return true;
	        }
	      }

	      if (applyReaderResumeRatio(target.chapter, target.ratio, runId)) {
	        return true;
	      }

	      const chapterTop = computeScrollTopForElementInContainer(els.readerContent, target.chapter, 'start');
	      if (chapterTop !== null) {
	        els.readerContent.scrollTo({ top: chapterTop, behavior: 'auto' });
	        return true;
	      }
	
	      return false;
	    }

	    function buildResumeCheckpoint() {
	      if (!currentBook) return null;
	
	      const progress = getProgressRatio();
	      const snapshot = {
	        progress,
	        chapter: Math.max(0, Number(currentBook.progressChapter || 0)),
	        offset: Math.max(0, Number(currentBook.progressOffset || 0)),
	        epubLocation: null,
	        hasProgress: progress > 0,
	        hasLegacy: Number(currentBook.progressOffset || 0) > 0 || Number(currentBook.progressChapter || 0) > 0
	      };
	
	      if (currentBook.format === 'epub') {
	        const stored = (currentBook.epubLocation && typeof currentBook.epubLocation === 'object')
	          ? currentBook.epubLocation
	          : null;
	        snapshot.epubLocation = stored || deriveLegacyEpubSnapshot();
	      }
	
	      return snapshot;
	    }

	    function persistDerivedEpubSnapshot(snapshot) {
	      if (!snapshot?.epubLocation?.fromLegacy) return;
	      const derived = {
	        href: String(snapshot.epubLocation.href || ''),
	        ratio: Math.max(0, Math.min(1, Number(snapshot.epubLocation.ratio || 0))),
	        anchor: String(snapshot.epubLocation.anchor || ''),
	        anchorDelta: Number.isFinite(Number(snapshot.epubLocation.anchorDelta))
	          ? Math.max(-4000, Math.min(4000, Number(snapshot.epubLocation.anchorDelta)))
	          : null
	      };
	      if (!derived.href) return;

	      pendingEpubLocation = derived;
	      lastEpubLocationSentAt = 0;
	      clearTimeout(persistDerivedEpubSnapshot._timer);
	      persistDerivedEpubSnapshot._timer = setTimeout(() => {
	        if (!currentBook || currentBook.format !== 'epub') return;
	        flushProgressAndTime(false).catch(() => {});
	      }, 1250);
	    }

	    function resumeReaderAtRecordedPosition() {
	      if (!currentBook || !els.readerContent) return;
	
	      const checkpoint = buildResumeCheckpoint();
	      if (!checkpoint) return;
	
	      const runId = beginReaderResumeRun();
	      let applied = false;

	      if (currentBook.format === 'epub') {
	        if (checkpoint.epubLocation) {
	          applied = applyEpubSnapshotResume(runId, checkpoint.epubLocation);
	        }
	        if (!applied && checkpoint.hasLegacy) {
	          applied = applyLegacyChapterResume(runId);
	        }
	      } else {
	        if (checkpoint.hasLegacy) {
	          applied = applyLegacyChapterResume(runId);
	        }
	      }

	      if (!applied && checkpoint.hasProgress) {
	        applied = applyRatioResume(runId, checkpoint.progress);
	      }

	      if (checkpoint.epubLocation?.fromLegacy) {
	        persistDerivedEpubSnapshot(checkpoint);
	      }

	      endReaderResumeRun(runId, applied ? (currentBook.format === 'epub' ? 1000 : 180) : 0);
	      if (applied) {
	        scheduleTocHighlightUpdate();
	      }
	    }

    function smoothScrollReader(delta) {
      const rc = els.readerContent;
      if (!rc) return;
      rc.scrollBy({ top: delta, behavior: 'smooth' });
    }

	    function getReaderProgress() {
	      const rc = els.readerContent;
	      const maxScroll = Math.max(1, rc.scrollHeight - rc.clientHeight);
	      const progress = Math.max(0, Math.min(1, rc.scrollTop / maxScroll));

      // Find chapter at top of viewport
      let progressChapter = 0;
      let progressOffset = 0;
      const chapters = rc.querySelectorAll('.chapter');
      const rcRect = rc.getBoundingClientRect();
      for (let i = 0; i < chapters.length; i++) {
        const rect = chapters[i].getBoundingClientRect();
        if (rect.bottom > rcRect.top) {
          progressChapter = i;
          progressOffset = rcRect.top - rect.top;
          break;
        }
      }

	      return { progress, progressChapter, progressOffset };
	    }

	    function computeEpubLocationFromScroll() {
	      if (!currentBook || currentBook.format !== 'epub') return null;
	      const rc = els.readerContent;
	      if (!rc) return null;
	      const chapters = rc.querySelectorAll('.chapter');
	      if (!chapters.length) return null;

	      const { progressChapter, progressOffset } = getReaderProgress();
	      const chapterIndex = Math.max(0, Math.min(chapters.length - 1, Number(progressChapter || 0)));
	      const chapterEl = chapters[chapterIndex];
	      if (!chapterEl) return null;
	
	      const href = chapterEl.dataset?.href ? String(chapterEl.dataset.href) : '';
	      if (!href) return null;

	      // Convert the saved pixel offset into a stable-ish ratio within the chapter.
	      // Using a ratio avoids absolute pixel drift across font/width changes.
	      const chapterHeight = Math.max(
	        1,
	        chapterEl.scrollHeight,
	        chapterEl.offsetHeight,
	        chapterEl.getBoundingClientRect().height || 0
	      );
	      const ratio = Math.max(0, Math.min(1, Number(progressOffset || 0) / chapterHeight));
	      let anchor = pickBestChapterAnchor(chapterEl, progressOffset);
	      let anchorDelta = null;
	      if (anchor) {
	        const anchorEl = findChapterAnchorElement(chapterEl, anchor);
	        const anchorOffset = getElementOffsetInChapter(chapterEl, anchorEl);
	        if (Number.isFinite(anchorOffset)) {
	          anchorDelta = Math.max(-4000, Math.min(4000, Number(progressOffset || 0) - anchorOffset));
	          if (Math.abs(anchorDelta) > 1400) {
	            anchor = '';
	            anchorDelta = null;
	          }
	        }
	      }

	      return { href, ratio, anchor, anchorDelta };
	    }

	    function decodeURIComponentSafe(s) {
	      const raw = String(s || '');
	      try { return decodeURIComponent(raw); } catch (e) { return raw; }
	    }

    function startReadingSession() {
      stopReadingSession();
      readSessionStartedAt = Date.now();
      readSessionLastSentAt = Date.now();

      const onScroll = () => {
        if (readerResumeState?.applying) {
          return;
        }
        scheduleProgressSave();
        updateReaderProgressUi();
        scheduleTocHighlightUpdate();
      };
      els.readerContent.addEventListener('scroll', onScroll);
      startReadingSession._onScroll = onScroll;

      readSessionInterval = setInterval(() => flushProgressAndTime(false), 30000);
	    }

    function stopReadingSession() {
      if (readSessionInterval) clearInterval(readSessionInterval);
      readSessionInterval = null;

      if (startReadingSession._onScroll) {
        els.readerContent.removeEventListener('scroll', startReadingSession._onScroll);
        startReadingSession._onScroll = null;
      }

      cancelReaderResumeRun();
      clearTimeout(persistDerivedEpubSnapshot._timer);

      flushProgressAndTime(true).catch(() => {});
      readSessionStartedAt = null;
      readSessionLastSentAt = null;
    }

    function scheduleProgressSave() {
      clearTimeout(scheduleProgressSave._t);
      scheduleProgressSave._t = setTimeout(() => flushProgressAndTime(false), 600);
    }

    function showReaderUi() {
      if (!els.readerView || settings.readerTopBarVisible === false) return;
      els.readerView.classList.remove('reader-ui-hidden');
      clearTimeout(readerUiHideTimer);
    }

    function scheduleReaderUiHide(delay = 800) {
      clearTimeout(readerUiHideTimer);
      if (settings.readerTopBarVisible === false) return;
      readerUiHideTimer = setTimeout(() => {
        if (settings.readerTopBarVisible === false) return;
        els.readerView?.classList?.add('reader-ui-hidden');
      }, delay);
    }

    function showReaderUiTemporarily() {
      showReaderUi();
      scheduleReaderUiHide();
    }

    function showTocPanel() {
      els.readerView?.classList?.remove('reader-toc-hidden');
      clearTimeout(tocHideTimer);
    }

    function scheduleTocHide(delay) {
      clearTimeout(tocHideTimer);
      tocHideTimer = setTimeout(() => {
        els.readerView?.classList?.add('reader-toc-hidden');
      }, delay ?? settings.tocHideDelay ?? 500);
    }

    function hideReaderMenusImmediately() {
      clearTimeout(readerUiHideTimer);
      clearTimeout(tocHideTimer);
      els.readerView?.classList?.add('reader-ui-hidden');
      els.readerView?.classList?.add('reader-toc-hidden');
    }

    function showReaderMenusTemporarily() {
      showReaderUi();
      scheduleReaderUiHide(1200);
      showTocPanel();
      scheduleTocHide((settings.tocHideDelay || 500) * 2);
    }

    function toggleReaderMenusByMiddleClick() {
      if (!currentBook || !els.readerView) return;
      const topbarShown = (settings.readerTopBarVisible !== false)
        && !els.readerView.classList.contains('reader-ui-hidden');
      const tocShown = !els.readerView.classList.contains('reader-toc-hidden');
      if (topbarShown || tocShown) {
        hideReaderMenusImmediately();
      } else {
        showReaderMenusTemporarily();
      }
    }

	    async function flushProgressAndTime(force) {
	      if (!currentBook) return;
	      if (readerResumeState?.applying) return;
	      const { progress, progressChapter, progressOffset } = getReaderProgress();

	      if (currentBook.format === 'epub') {
	        pendingEpubLocation = computeEpubLocationFromScroll();
	      }

	      const now = Date.now();
	      const timeDeltaSec = readSessionLastSentAt ? Math.max(0, Math.floor((now - readSessionLastSentAt) / 1000)) : 0;
	      const shouldSendEpubLocation = currentBook.format === 'epub'
	        && pendingEpubLocation
	        && (force || (now - lastEpubLocationSentAt) > 4000);

	      const epubLocArg = shouldSendEpubLocation ? pendingEpubLocation : null;
	      if (!force && timeDeltaSec < 2) {
	        await ipcRenderer.invoke('update-progress', currentBook.id, progress, 0, progressChapter, progressOffset, epubLocArg);
	      } else {
	        await ipcRenderer.invoke('update-progress', currentBook.id, progress, timeDeltaSec, progressChapter, progressOffset, epubLocArg);
	        readSessionLastSentAt = now;
	      }
	      if (shouldSendEpubLocation) {
	        lastEpubLocationSentAt = now;
	      }

      state.booksById[currentBook.id].progress = progress;
      state.booksById[currentBook.id].progressChapter = progressChapter;
      state.booksById[currentBook.id].progressOffset = progressOffset;
      state.booksById[currentBook.id].lastRead = now;
    }

	    function clearHighlights() {
	        // Clear EPUB search highlights
		      els.readerContent.querySelectorAll('.search-highlight').forEach(span => {
		        const text = document.createTextNode(span.textContent);
		        span.replaceWith(text);
		      });
		      // Keep text nodes stable across repeated searches.
		      els.readerContent.normalize();

	        // Clear PDF search highlights
	        els.readerContent.querySelectorAll('.search-highlight-span').forEach(span => {
	          span.classList.remove('search-highlight-span');
	          span.classList.remove('current');
	          // Only clear background if not a user highlight
	          if (!span.classList.contains('highlight')) {
	            span.style.background = '';
	            span.style.borderRadius = '';
	          }
	        });
	        els.readerContent.querySelectorAll('.pdf-search-layer').forEach(layer => layer.innerHTML = '');
		    }

		    function applyPdfSearchHighlightsOnPage(pageEl, query, currentIndex = bookSearchState?.currentIndex) {
		      const q = String(query || '').trim().toLowerCase();
		      if (!q || !pageEl) return;
		      const pageContainer = pageEl.querySelector('.pdf-page-container');
		      const textLayer = pageContainer?.querySelector?.('.textLayer');
		      if (!pageContainer || !textLayer) return;

		      const pageNum = Number(pageEl.dataset.pageNum) || 1;
		      const matches = [];
		      (bookSearchState.matches || []).forEach((m, idx) => {
		        if (m?.pageNum === pageNum) matches.push({ m, idx });
		      });
		      if (!matches.length) {
		        const existingLayer = pageContainer.querySelector('.pdf-search-layer');
		        if (existingLayer) existingLayer.innerHTML = '';
		        return;
		      }

		      let searchLayer = pageContainer.querySelector('.pdf-search-layer');
		      if (!searchLayer) {
		        searchLayer = document.createElement('div');
		        searchLayer.className = 'pdf-search-layer';
		        pageContainer.appendChild(searchLayer);
		      }
		      searchLayer.innerHTML = '';

		      const pageRect = pageContainer.getBoundingClientRect();
		      const spans = textLayer.querySelectorAll('span');

		      const colorBgs = {
		        yellow: 'rgba(255, 235, 59, 0.55)',
		        green: 'rgba(0, 230, 118, 0.5)',
		        blue: 'rgba(33, 150, 243, 0.5)',
		        pink: 'rgba(255, 64, 129, 0.45)',
		        purple: 'rgba(224, 64, 251, 0.45)',
		        orange: 'rgba(255, 145, 0, 0.5)'
		      };

		      const pageHighlights = (currentHighlights || []).filter(h => h.pageNum === pageNum && Array.isArray(h.rects) && h.rects.length);
		      const pageItems = pdfPageTextItems.get(pageNum) || [];
		      const viewport = pdfPageViewports.get(pageNum);

		      const findColorForRect = (left, top, right, bottom) => {
		        if (!pageHighlights.length) return null;
		        const cx = (left + right) / 2;
		        const cy = (top + bottom) / 2;
		        for (const h of pageHighlights) {
		          for (const r of (h.rects || [])) {
		            const x0 = r.x * pageRect.width;
		            const y0 = r.y * pageRect.height;
		            const x1 = (r.x + r.w) * pageRect.width;
		            const y1 = (r.y + r.h) * pageRect.height;
		            if (cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1) return h.color || null;
		          }
		        }
		        return null;
		      };

		      for (const { m, idx } of matches) {
		        const span = spans[m.itemIndex];
		        const item = pageItems[m.itemIndex];
		        const str = item?.str || span?.textContent || '';
		        if (!span || !span.firstChild || !str) continue;

		        const charStart = Math.max(0, Math.min(str.length, m.charIndex || 0));
		        const charEnd = Math.max(charStart + 1, Math.min(str.length, (m.charIndex || 0) + (m.charLength || q.length)));

		        const addMark = (rect) => {
		          if (!rect || !rect.width || !rect.height) return;
		          const left = rect.left - pageRect.left;
		          const top = rect.top - pageRect.top;
		          const right = rect.right - pageRect.left;
		          const bottom = rect.bottom - pageRect.top;
		          if (right <= 0 || bottom <= 0 || left >= pageRect.width || top >= pageRect.height) return;

		          const mark = document.createElement('div');
		          mark.className = 'pdf-search-mark';
		          mark.dataset.matchIndex = idx;
		          if (idx === currentIndex) mark.classList.add('current');

		          const colorName = findColorForRect(left, top, right, bottom);
		          const bg = colorBgs[colorName] || 'color-mix(in srgb, var(--accent, #b8860b) 55%, transparent)';
		          mark.style.background = bg;
		          mark.style.left = `${(left / pageRect.width) * 100}%`;
		          mark.style.top = `${(top / pageRect.height) * 100}%`;
		          mark.style.width = `${((right - left) / pageRect.width) * 100}%`;
		          mark.style.height = `${((bottom - top) / pageRect.height) * 100}%`;

		          searchLayer.appendChild(mark);
		        };

		        if (viewport && item) {
		          try {
		            const tx = pdfjsLib.Util.transform(viewport.transform, item.transform);
		            const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
		            const totalWidth = (item.width || 0) * (settings.pdfZoom || 120) / 100 || (str.length * fontHeight * 0.5);
		            const denom = str.length || 1;
		            const startX = totalWidth * (charStart / denom);
		            const endX = totalWidth * (charEnd / denom);
		            const left = tx[4] + startX;
		            const right = tx[4] + endX;
		            const top = tx[5] - fontHeight;
		            const bottom = top + fontHeight;
		            addMark({
		              left: pageRect.left + left,
		              right: pageRect.left + right,
		              top: pageRect.top + top,
		              bottom: pageRect.top + bottom,
		              width: right - left,
		              height: bottom - top
		            });
		            continue;
		          } catch (e) {}
		        }

		        // Fallback to DOM range measurement
		        const textNode = span.firstChild;
		        const range = document.createRange();
		        try {
		          range.setStart(textNode, charStart);
		          range.setEnd(textNode, charEnd);
		          const rects = Array.from(range.getClientRects ? range.getClientRects() : []);
		          if (rects.length) rects.forEach(addMark);
		          else addMark(range.getBoundingClientRect());
		        } catch (e) {}
		      }
		    }

		    async function gotoPdfSearchMatch(match, { token, index } = {}) {
		      if (!currentBook || currentBook.format !== 'pdf') return;
		      const pageNum = Number(match?.pageNum) || 1;
		      const pageEl = document.getElementById(`pdf-page-${pageNum}`);
		      if (!pageEl) return;

		      // Ensure the page is rendered, but don't render every page for search.
		      if (!pdfRenderedPages.has(pageNum)) {
		        pdfRenderedPages.set(pageNum, true);
		        await renderPdfPage(pageNum, pageEl);
		      }
		      if (token && gotoSearchIndex._pdfToken !== token) return;

		      applyPdfSearchHighlightsOnPage(pageEl, bookSearchState.query, index);

		      const mark = pageEl.querySelector(`.pdf-search-mark[data-match-index="${index}"]`);
		      const target = mark || pageEl;

		      const scrollToken = `pdf-${pageNum}-${index}-${Date.now()}`;
		      scrollContainerToElementStable._token = scrollToken;
		      scrollContainerToElementStable(els.readerContent, target, { behavior: 'smooth', block: 'center', token: scrollToken });
		    }

		    function isBookSearchResultsVisible() {
		      return !!(els.searchResultsPanel && !els.searchResultsPanel.classList.contains('hidden'));
		    }

		    function hideBookSearchResults() {
		      els.searchResultsPanel?.classList.add('hidden');
		    }

		    function showBookSearchResults() {
		      els.searchResultsPanel?.classList.remove('hidden');
		    }

		    // Get snippet centered around the keyword
		    function getSnippetAroundMatch(text, keyword, contextChars = 30) {
		      const clean = String(text || '').trim().replace(/\s+/g, ' ');
		      const lower = clean.toLowerCase();
		      const kw = String(keyword || '').toLowerCase();
		      const idx = lower.indexOf(kw);
		      if (idx === -1) {
		        // Keyword not found in context, return text with keyword appended
		        const short = clean.slice(0, contextChars);
		        return short + (short.length < clean.length ? '…' : '');
		      }
		      // Use shorter context for scripts that tend to have long "wordless" runs (CJK/Thai/etc),
		      // otherwise the keyword can be pushed off the visible 2-line clamp in the results panel.
		      const hasCJK = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af]/.test(clean);
		      const hasThai = /[\u0e00-\u0e7f]/.test(clean);
		      const hasArabic = /[\u0600-\u06ff]/.test(clean);
		      const spaceCount = (clean.match(/ /g) || []).length;
		      const isDenseNoSpace = clean.length >= 60 && spaceCount <= 1;
		      const shouldTighten = hasCJK || hasThai || hasArabic || isDenseNoSpace;
		      const ctx = shouldTighten ? Math.min(contextChars, 15) : contextChars;
		      const start = Math.max(0, idx - ctx);
		      const end = Math.min(clean.length, idx + kw.length + ctx);
		      let snippet = clean.slice(start, end);
		      if (start > 0) snippet = '…' + snippet;
		      if (end < clean.length) snippet = snippet + '…';
		      return snippet;
		    }


		    function updateBookSearchUiState() {
		      const q = String(els.bookSearch?.value || '').trim();
		      const hasQuery = !!q;
		      const root = document.getElementById('reader-search');
		      if (root) root.classList.toggle('has-query', hasQuery);
		      const btn = document.getElementById('search-filter-hl');
		      if (btn) btn.classList.toggle('active', bookSearchState.highlightsOnly === true);
		    }

	    let searchAbortController = null;

	    function scheduleBookSearch() {
	      updateBookSearchUiState();
	      clearTimeout(scheduleBookSearch._t);
	      // Cancel any pending search
	      if (searchAbortController) searchAbortController.abort();
	      scheduleBookSearch._t = setTimeout(() => searchInBook(), 300);
	    }

	    function onBookSearchKeydown(e) {
	      if (!e) return;
		      if (e.key === 'Escape') {
		        if (isBookSearchResultsVisible()) {
		          hideBookSearchResults();
		        } else {
		          clearBookSearch();
		        }
	        e.preventDefault();
	        return;
	      }
	      if (e.key === 'Enter') {
	        if (e.shiftKey) {
	          prevSearchResult();
	        } else {
	          // If we already have results, Enter cycles to next; otherwise run search.
	          if (bookSearchState.matches.length) nextSearchResult();
	          else searchInBook();
	        }
	        e.preventDefault();
	        return;
	      }
	      if (e.key === 'ArrowDown') {
	        nextSearchResult();
	        e.preventDefault();
	        return;
	      }
	      if (e.key === 'ArrowUp') {
	        prevSearchResult();
	        e.preventDefault();
	        return;
	      }
	    }

    function getAdjacentText(node, charsBefore, charsAfter) {
      let before = '', after = '';
      const chapter = node.parentNode?.closest?.('.chapter');

      // Gather text before
      let cur = node;
      while (before.length < charsBefore && cur) {
        let prev = cur.previousSibling;
        if (!prev && cur.parentNode && cur.parentNode !== chapter) {
          cur = cur.parentNode;
          prev = cur.previousSibling;
        }
        if (!prev) break;
        cur = prev;
        while (cur.lastChild) cur = cur.lastChild;
        const t = cur.textContent || '';
        before = t.slice(-(charsBefore - before.length)) + before;
      }

      // Gather text after
      cur = node;
      while (after.length < charsAfter && cur) {
        let next = cur.nextSibling;
        if (!next && cur.parentNode && cur.parentNode !== chapter) {
          cur = cur.parentNode;
          next = cur.nextSibling;
        }
        if (!next) break;
        cur = next;
        while (cur.firstChild) cur = cur.firstChild;
        const t = cur.textContent || '';
        after = after + t.slice(0, charsAfter - after.length);
      }

      return { before, after };
    }

	    async function highlightMatches(query, signal) {
	      const q = query.toLowerCase();
	      const maxMatches = 5000;
	      const matches = [];

	      // Handle PDF search
	      if (currentBook?.format === 'pdf') {
	        if (!pdfDoc || !pdfjsLib) return [];
	        const totalPages = pdfDoc.numPages || 1;

	        const getPdfItemsContext = (items, i, charsBefore = 60, charsAfter = 60) => {
	          const center = String(items?.[i]?.str || '');
	          let before = '';
	          let after = '';
	          for (let j = i - 1; j >= 0 && before.length < charsBefore; j--) {
	            before = String(items?.[j]?.str || '') + before;
	          }
	          for (let j = i + 1; j < (items?.length || 0) && after.length < charsAfter; j++) {
	            after += String(items?.[j]?.str || '');
	          }
	          return before.slice(-charsBefore) + center + after.slice(0, charsAfter);
	        };

	        let yieldCounter = 0;
	        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
	          if (signal?.aborted) return [];
	          if (++yieldCounter % 2 === 0) {
	            await new Promise(r => setTimeout(r, 0));
	            if (signal?.aborted) return [];
	          }

	          const pageHighlights = (currentHighlights || []).filter(h => h.pageNum === pageNum && Array.isArray(h.rects) && h.rects.length);
	          if (bookSearchState.highlightsOnly && !pageHighlights.length) continue;

	          const pageData = await getPdfPageData(pageNum);
	          if (!pageData) continue;
	          const { items, viewport } = pageData;
	          if (!items || !viewport) continue;

	          const findHlColorForRange = (startX, endX, top, height) => {
	            const cx = (startX + endX) / 2;
	            const cy = top + (height / 2);
	            for (const h of pageHighlights) {
	              for (const r of (h.rects || [])) {
	                const x0 = r.x * viewport.width;
	                const y0 = r.y * viewport.height;
	                const x1 = (r.x + r.w) * viewport.width;
	                const y1 = (r.y + r.h) * viewport.height;
	                if (cx >= x0 && cx <= x1 && cy >= y0 && cy <= y1) return h.color || null;
	              }
	            }
	            return null;
	          };
	          for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
	            const s = String(items[itemIndex]?.str || '');
	            if (!s) continue;
	            const lower = s.toLowerCase();
	            let idx = 0;
	            while ((idx = lower.indexOf(q, idx)) !== -1) {
	              const ctx = getPdfItemsContext(items, itemIndex, 60, 60);
	              const snippet = getSnippetAroundMatch(ctx, query, 30);

	              let posInPage = 0.5;
	              try {
	                const tx = pdfjsLib.Util.transform(viewport.transform, items[itemIndex].transform);
	                const fontHeight = Math.sqrt((tx[2] * tx[2]) + (tx[3] * tx[3]));
	                const topPx = (tx[5] - fontHeight);
	                if (viewport.height) posInPage = topPx / viewport.height;
	              } catch (e) {}
	              posInPage = Math.max(0, Math.min(1, posInPage));
	              const pos = ((pageNum - 1) + posInPage) / totalPages;

	              const hlColor = findHlColorForRange(startX, endX, topPx, fontHeight);
	              const isHighlight = !!hlColor;

	              matches.push({
	                pageNum,
	                itemIndex,
	                charIndex: idx,
	                charLength: query.length,
	                snippet,
	                pos,
	                hlColor,
	                isHighlight
	              });
	              if (bookSearchState.highlightsOnly && !isHighlight) { idx += q.length; continue; }
	              if (matches.length >= maxMatches) break;
	              idx += q.length;
	            }
	            if (matches.length >= maxMatches) break;
	          }

	          if (matches.length >= maxMatches) break;
	        }

	        return matches;
	      }

	      // Handle EPUB search (existing code)
	      const chapters = [...els.readerContent.querySelectorAll('.chapter')];
	      let yieldCounter = 0;

      for (let chapterIndex = 0; chapterIndex < chapters.length; chapterIndex++) {
        if (signal?.aborted) { clearHighlights(); return []; }

	        const root = chapters[chapterIndex];
	        const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
	          acceptNode(node) {
	            if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
	            if (node.parentNode?.classList?.contains('search-highlight')) return NodeFilter.FILTER_REJECT;
	            return NodeFilter.FILTER_ACCEPT;
          }
        });

        const textNodes = [];
        let n;
        while ((n = walker.nextNode())) textNodes.push(n);

        for (const originalNode of textNodes) {
          if (++yieldCounter % 100 === 0) {
            await new Promise(r => setTimeout(r, 0));
            if (signal?.aborted) { clearHighlights(); return []; }
          }

          let node = originalNode;
          while (matches.length < maxMatches) {
            const text = node.nodeValue || '';
            const idx = text.toLowerCase().indexOf(q);
            if (idx === -1) break;

            const matchText = text.slice(idx, idx + query.length);

            // Get context - first from current node, then adjacent nodes if needed
            let beforeText = text.slice(Math.max(0, idx - 50), idx);
            let afterText = text.slice(idx + query.length, idx + query.length + 50);

            if (beforeText.length < 30 || afterText.length < 30) {
              const adj = getAdjacentText(node, 50 - beforeText.length, 50 - afterText.length);
              beforeText = adj.before + beforeText;
              afterText = afterText + adj.after;
            }

	            const rawContext = (beforeText || '') + matchText + (afterText || '');
	            const snippet = getSnippetAroundMatch(rawContext, query, 30);

	            const before = text.slice(0, idx);
	            const hit = text.slice(idx, idx + query.length);
	            const after = text.slice(idx + query.length);

            const beforeNode = before ? document.createTextNode(before) : null;
            const hitSpan = document.createElement('span');
            hitSpan.className = 'search-highlight';

            const userHl = node.parentNode?.closest?.('mark.hl[data-color]');
            const hlColor = userHl?.dataset?.color || null;
            if (hlColor) hitSpan.dataset.hlColor = hlColor;

            hitSpan.textContent = hit;
            const afterNode = after ? document.createTextNode(after) : null;

            const parent = node.parentNode;
            if (!parent) break;
            if (beforeNode) parent.insertBefore(beforeNode, node);
            parent.insertBefore(hitSpan, node);
            if (afterNode) parent.insertBefore(afterNode, node);
            parent.removeChild(node);

	            const isHighlight = !!hlColor;
	            if (bookSearchState.highlightsOnly && !isHighlight) { if (!afterNode) break; node = afterNode; continue; }

	            matches.push({ chapterIndex, el: hitSpan, snippet, hlColor, isHighlight });

            if (!afterNode) break;
            node = afterNode;
          }

          if (matches.length >= maxMatches) break;
        }
        if (matches.length >= maxMatches) break;
      }

	      return matches;
	    }

	    function computeScrollTopForElementInContainer(container, el, block = 'center') {
	      if (!container || !el) return null;
	      const containerRect = container.getBoundingClientRect();
	      const elRect = el.getBoundingClientRect();
	      if (!containerRect.height) return null;

	      const currentTop = container.scrollTop;
	      const elTopInContainer = currentTop + (elRect.top - containerRect.top);
	      const elBottomInContainer = elTopInContainer + elRect.height;

	      let targetTop = elTopInContainer;
	      if (block === 'center') {
	        targetTop = elTopInContainer - (container.clientHeight / 2) + (elRect.height / 2);
	      } else if (block === 'end') {
	        targetTop = elBottomInContainer - container.clientHeight;
	      }

	      const maxTop = Math.max(0, container.scrollHeight - container.clientHeight);
	      return Math.max(0, Math.min(maxTop, targetTop));
	    }

	    function scrollContainerToElement(container, el, { behavior = 'smooth', block = 'center' } = {}) {
	      const targetTop = computeScrollTopForElementInContainer(container, el, block);
	      if (targetTop === null) return null;
	      container.scrollTo({ top: targetTop, behavior });
	      return targetTop;
	    }

		    function scrollContainerToElementStable(container, el, { behavior = 'smooth', block = 'center', token } = {}) {
	      const targetTop = scrollContainerToElement(container, el, { behavior, block });
	      if (targetTop === null) return null;

	      // content-visibility/contain-intrinsic-size can cause scrollTop to shift after the jump.
	      // Re-check position a few times and snap back if needed.
	      const checks = [120, 260, 520, 900];
	      checks.forEach((ms) => {
	        setTimeout(() => {
	          if (token && scrollContainerToElementStable._token !== token) return;
	          if (!container || !el || !el.isConnected) return;
	          const desired = computeScrollTopForElementInContainer(container, el, block);
	          if (desired === null) return;
	          if (Math.abs(container.scrollTop - desired) > 60) {
	            container.scrollTo({ top: desired, behavior: 'auto' });
	          }
	        }, ms);
	      });

	      return targetTop;
	    }

		    function gotoSearchIndex(index) {
		      if (!bookSearchState.matches.length) return;
		      const nextIndex = (index + bookSearchState.matches.length) % bookSearchState.matches.length;
		      bookSearchState.currentIndex = nextIndex;
		      bookSearchState.matches.forEach((m, i) => {
		        const el = m?.el || m?.element;
		        if (!el) return;
		        el.classList.toggle('current', i === nextIndex);
		      });
		      const match = bookSearchState.matches[nextIndex];
		      const matchEl = match?.el || match?.element;

		      if (currentBook?.format === 'pdf') {
		        const token = (gotoSearchIndex._pdfToken || 0) + 1;
		        gotoSearchIndex._pdfToken = token;
		        gotoPdfSearchMatch(match, { token, index: nextIndex }).catch(() => {});
		        els.searchPosition.textContent = `${nextIndex + 1}/${bookSearchState.matches.length}`;
		        updateCodemapLocation();
		        return;
		      }

		      if (matchEl && matchEl.isConnected) {
		        const chapter = matchEl.closest('.chapter');
		        if (chapter) {
		          chapter.style.contentVisibility = 'visible';
		          void chapter.offsetHeight;
		        }
		        const token = (scrollContainerToElementStable._token || 0) + 1;
		        scrollContainerToElementStable._token = token;
		        scrollContainerToElementStable(els.readerContent, matchEl, { behavior: 'smooth', block: 'center', token });

		        if (chapter) setTimeout(() => { if (scrollContainerToElementStable._token === token) chapter.style.contentVisibility = ''; }, 1200);
		      }

		      els.searchPosition.textContent = `${nextIndex + 1}/${bookSearchState.matches.length}`;
		      updateCodemapLocation();
		    }

		    function computeSearchMatchPositions() {
		      const container = els.readerContent;
		      if (!container) return;

		      // PDF: distribute markers by page and y-position within page.
		      if (currentBook?.format === 'pdf') {
		        const pages = [...container.querySelectorAll('.pdf-page')];
		        const totalPages = (pdfDoc?.numPages || pages.length || 1);
		        for (const m of (bookSearchState.matches || [])) {
		          if (typeof m?.pos === 'number') continue;
		          const el = m?.el || m?.element;
		          if (!el || !el.isConnected) continue;

		          const pageNum = (typeof m.pageNum === 'number' && m.pageNum > 0)
		            ? m.pageNum
		            : parseInt(el.closest?.('.pdf-page')?.dataset?.pageNum || '1');

		          const pageStart = (Math.max(1, pageNum) - 1) / totalPages;
		          let posInPage = 0.5;

		          const pageContainer = el.closest?.('.pdf-page')?.querySelector?.('.pdf-page-container');
		          const pageRect = (pageContainer || el.closest?.('.pdf-page'))?.getBoundingClientRect?.();
		          const elRect = el.getBoundingClientRect?.();
		          if (pageRect && pageRect.height && elRect) {
		            const cy = elRect.top + (elRect.height / 2);
		            posInPage = (cy - pageRect.top) / pageRect.height;
		          }

		          posInPage = Math.max(0, Math.min(1, posInPage));
		          m.pos = pageStart + (posInPage / totalPages);
		        }
		        return;
		      }

		      const chapters = [...container.querySelectorAll('.chapter')];
		      const totalChapters = chapters.length || 1;

		      for (const m of (bookSearchState.matches || [])) {
		        const el = m?.el;
	        if (!el || !el.isConnected) continue;

	        const chapterIndex = m.chapterIndex ?? 0;
	        const chapter = el.closest('.chapter');

	        // Base position from chapter index
	        const chapterStart = chapterIndex / totalChapters;
	        const chapterEnd = (chapterIndex + 1) / totalChapters;

	        // Estimate position within chapter by highlight order
	        let posInChapter = 0.5;
	        if (chapter) {
	          const highlights = chapter.querySelectorAll('.search-highlight');
	          const idx = [...highlights].indexOf(el);
	          if (highlights.length > 0 && idx >= 0) {
	            posInChapter = (idx + 0.5) / highlights.length;
	          }
	        }

	        m.pos = chapterStart + (chapterEnd - chapterStart) * posInChapter;
	      }
	    }

		    function renderSearchCodemap() {
		      const track = document.getElementById('codemap-track');
		      if (!track) return;
		      const matches = bookSearchState.matches || [];
		      if (!matches.length) {
		        track.innerHTML = '';
		        return;
		      }
		      const hlColors = { yellow: '#ffc107', green: '#388e3c', blue: '#1976d2', pink: '#e91e63', purple: '#9c27b0', orange: '#ff5722' };
		      const markers = matches.map((m, i) => {
		        const pos = typeof m.pos === 'number' ? m.pos : ((i + 1) / matches.length);
		        const colorStyle = m.hlColor && hlColors[m.hlColor] ? `background:${hlColors[m.hlColor]};` : '';
		        return `<button type="button" class="codemap-marker${i === bookSearchState.currentIndex ? ' current' : ''}" data-index="${i}" style="top:${(pos * 100).toFixed(2)}%;${colorStyle}"></button>`;
		      }).join('');
		      track.innerHTML = markers;
		      updateCodemapLocation();
		    }

	    function updateCodemapLocation() {
	      const track = document.getElementById('codemap-track');
	      if (!track) return;
	      const markers = track.querySelectorAll('.codemap-marker');
	      const activeIndex = bookSearchState.currentIndex >= 0 ? bookSearchState.currentIndex : 0;
	      markers.forEach((btn, i) => btn.classList.toggle('current', i === activeIndex));
	    }

	    function formatMatchLocation(match, idx, total) {
	      const chapterLabel = (typeof match.chapterIndex === 'number')
	        ? `Chapter ${match.chapterIndex + 1}`
	        : `Match ${idx + 1}`;
	      const pct = (typeof match.pos === 'number')
	        ? `${Math.round(match.pos * 100)}%`
	        : `${idx + 1}/${total}`;
	      return `${chapterLabel} • ${pct}`;
	    }

		    async function searchInBook(opts = {}) {
		      if (!currentBook) return;
		      const query = (els.bookSearch.value || '').trim();
		      if (!query) return clearBookSearch();

	      // Create abort controller for this search
	      if (searchAbortController) searchAbortController.abort();
	      searchAbortController = new AbortController();
	      const signal = searchAbortController.signal;

		      updateBookSearchUiState();
		      clearHighlights();

		      showBookSearchResults();
		      els.searchResultsPanel.innerHTML = `
		        <div class="search-results-header">
		          <span>Searching…</span>
		          <span class="search-meta">Esc to clear</span>
		        </div>
		        <div style="padding:12px 16px;color:var(--text-secondary);">Scanning for matches…</div>
		      `;
		      const codemapEl = document.getElementById('search-codemap');
		      if (codemapEl) codemapEl.classList.add('visible');
		      els.searchNav.style.display = 'flex';
		      els.searchPosition.textContent = '…';

		      // Yield to UI before heavy work
		      await new Promise(r => setTimeout(r, 0));
		      if (signal.aborted) return;

		      bookSearchState.query = query;
		      bookSearchState.matches = await highlightMatches(query, signal);
		      bookSearchState.currentIndex = -1;

	      if (signal.aborted || !bookSearchState.matches.length && signal.aborted) return;

      const total = bookSearchState.matches.length;
	      els.searchNav.style.display = total ? 'flex' : 'none';
      if (!total) {
        showBookSearchResults();
        els.searchResultsPanel.innerHTML = `
	          <div class="search-results-header">
	            <span>No results</span>
	            <span style="opacity:0.85;">Esc to clear</span>
	          </div>
	          <div style="padding:12px 16px;color:var(--text-secondary);">Try a different word or shorter query.</div>
	        `;
	        els.searchPosition.textContent = '0/0';
	        return;
	      }

	      function snippetHtml(snippet, q) {
	        const raw = String(snippet || '').trim().replace(/\s+/g, ' ').slice(0, 180);
	        if (!raw) return '';
	        const qRaw = String(q || '');
	        if (!qRaw) return escapeHtml(raw);
	        const rawLower = raw.toLowerCase();
	        const qLower = qRaw.toLowerCase();
	        let out = '';
	        let i = 0;
	        while (i < raw.length) {
	          const j = rawLower.indexOf(qLower, i);
	          if (j === -1) {
	            out += escapeHtml(raw.slice(i));
	            break;
	          }
	          out += escapeHtml(raw.slice(i, j));
	          out += `<mark>${escapeHtml(raw.slice(j, j + qRaw.length))}</mark>`;
	          i = j + qRaw.length;
	        }
	        return out;
	      }

		      showBookSearchResults();
		      const shown = total;
		      const hlColors = { yellow: '#ffc107', green: '#388e3c', blue: '#1976d2', pink: '#e91e63', purple: '#9c27b0', orange: '#ff5722' };
		      const listHtml = bookSearchState.matches.map((m, i) => {
		        const s = snippetHtml(m.snippet || `Match ${i + 1}`, query);
		        const chapterLabel = (currentBook?.format === 'pdf')
		          ? `Page ${Number(m.pageNum) || 1}`
		          : `Chapter ${Number(m.chapterIndex) + 1}`;
		        const colorDot = m.hlColor && hlColors[m.hlColor] ? `<span style="width:8px;height:8px;border-radius:50%;background:${hlColors[m.hlColor]};flex-shrink:0;margin-left:auto;"></span>` : '';
		        const meta = m.isHighlight ? `<span style="padding:2px 6px;border-radius:12px;background:color-mix(in srgb, ${hlColors[m.hlColor] || 'var(--primary)'} 20%, transparent);color:var(--text-secondary);font-size:0.72rem;">Highlight</span>` : '';
		        return `
		          <button type="button" class="search-result-item" onclick="gotoSearchIndex(${i})">
		            <div class="result-chapter" style="display:flex;align-items:center;gap:6px;">${escapeHtml(chapterLabel)}${colorDot}${meta}</div>
		            <div class="result-text">${s}</div>
		          </button>
		        `;
		      }).join('');

		      els.searchResultsPanel.innerHTML = `
		        <div class="search-results-header">
		          <span>${shown} matches</span>
		          <span class="search-meta">↑↓ to jump</span>
		        </div>
		        <div class="search-results-body">${listHtml}</div>
		      `;

      // Show codemap on right side
      const codemap = document.getElementById('search-codemap');
      if (codemap) codemap.classList.add('visible');

	      computeSearchMatchPositions();
	      if (currentBook?.format === 'pdf') {
	        // Apply search highlights to rendered pages only (lazy render).
	        const renderedPages = [...els.readerContent.querySelectorAll('.pdf-page')].filter(p => pdfRenderedPages.has(Number(p.dataset.pageNum)));
	        renderedPages.forEach(p => applyPdfSearchHighlightsOnPage(p, query, bookSearchState.currentIndex));
	      }

      // Sort matches by position and re-render list
      const sortedIndices = bookSearchState.matches.map((m, i) => ({ m, i, pos: m.pos ?? i }))
        .sort((a, b) => a.pos - b.pos)
        .map(x => x.i);

	      const sortedListHtml = sortedIndices.map(origIdx => {
	        const m = bookSearchState.matches[origIdx];
	        const s = snippetHtml(m.snippet || `Match ${origIdx + 1}`, query);
	        const chapterLabel = (currentBook?.format === 'pdf')
	          ? `Page ${Number(m.pageNum) || 1}`
	          : `Chapter ${Number(m.chapterIndex) + 1}`;
	        const colorDot = m.hlColor && hlColors[m.hlColor] ? `<span style="width:8px;height:8px;border-radius:50%;background:${hlColors[m.hlColor]};flex-shrink:0;margin-left:auto;"></span>` : '';
	        const meta = m.isHighlight ? `<span style="padding:2px 6px;border-radius:12px;background:color-mix(in srgb, ${hlColors[m.hlColor] || 'var(--primary)'} 20%, transparent);color:var(--text-secondary);font-size:0.72rem;">Highlight</span>` : '';
	        return `
	          <button type="button" class="search-result-item" onclick="gotoSearchIndex(${origIdx})">
	            <div class="result-chapter" style="display:flex;align-items:center;gap:6px;">${escapeHtml(chapterLabel)}${colorDot}${meta}</div>
	            <div class="result-text">${s}</div>
	          </button>
	        `;
	      }).join('');

      els.searchResultsPanel.querySelector('.search-results-body').innerHTML = sortedListHtml;

      renderSearchCodemap();

      // Don't auto-jump - wait for user to click an item
      bookSearchState.currentIndex = -1;
      els.searchPosition.textContent = `0/${total}`;
	    }

	    function nextSearchResult() {
	      if (!bookSearchState.matches.length) return searchInBook({ initialIndex: 0 });
	      gotoSearchIndex(bookSearchState.currentIndex + 1);
	    }
	    function prevSearchResult() {
	      if (!bookSearchState.matches.length) return searchInBook({ initialIndex: -1 });
	      gotoSearchIndex(bookSearchState.currentIndex - 1);
	    }

	    function clearBookSearch() {
	      if (els.bookSearch) els.bookSearch.value = '';
	      els.searchNav.style.display = 'none';
	      hideBookSearchResults();
	      const codemap = document.getElementById('search-codemap');
	      if (codemap) codemap.classList.remove('visible');
	      bookSearchState = { query: '', matches: [], currentIndex: -1 };
	      clearHighlights();
	      updateBookSearchUiState();
	    }

	    async function refreshBookmarksAndHighlights() {
	      if (!currentBook) return;
	      const [bookmarks, highlights, notes] = await Promise.all([
	        ipcRenderer.invoke('get-bookmarks', currentBook.id),
	        ipcRenderer.invoke('get-highlights', currentBook.id),
	        ipcRenderer.invoke('get-notes', currentBook.id)
	      ]);
	      currentHighlights = highlights || [];
	      currentNotes = notes || [];

	      // Re-apply annotations to DOM after updating
	      applyAnnotationsToDom();

      const items = [];
      let renderedCount = 0;
      items.push(`<button class="close-btn" style="margin:16px;" onclick="addBookmark()">Add Bookmark</button>`);

      const query = annotationQuery || '';
      const matchesQuery = (text) => {
        if (!query) return true;
        return String(text || '').toLowerCase().includes(query);
      };

	      if (highlights?.length) {
	        // Group highlights by color
	        const colorNames = { yellow: 'Yellow', green: 'Green', blue: 'Blue', pink: 'Pink', purple: 'Purple', orange: 'Orange' };
	        const colorBgs = { yellow: '#FFEB3B', green: '#4CAF50', blue: '#2196F3', pink: '#E91E63', purple: '#9C27B0', orange: '#FF9800' };
	        const byColor = {};
	        for (const h of highlights) {
	          const c = h.color || 'yellow';
	          if (!byColor[c]) byColor[c] = [];
	          byColor[c].push(h);
	        }

	        // Show "All Highlights" section first
	        items.push(`<div style="padding:0 16px 10px;color:var(--text-secondary);font-size:0.85rem;display:flex;align-items:center;gap:6px;">
	          <span>All Highlights (${highlights.length})</span>
	        </div>`);

	        // Then show by color groups
	        for (const [color, list] of Object.entries(byColor)) {
	          const colorDot = `<span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${colorBgs[color] || '#FFEB3B'};margin-right:6px;"></span>`;
	          items.push(`<div style="padding:4px 16px 8px;color:var(--text-secondary);font-size:0.8rem;display:flex;align-items:center;">${colorDot}${colorNames[color] || color} (${list.length})</div>`);
	          for (const h of list.slice().sort((a,b)=>b.timestamp-a.timestamp)) {
              if (query && !matchesQuery(h.text) && !matchesQuery(h.color) && !matchesQuery(h.note)) continue;
              const excerpt = (h.text || '').slice(0, 120) || 'Highlight';
	            const canLocate = (typeof h.chapterIndex === 'number' && typeof h.startChar === 'number') || (typeof h.pageNum === 'number');
	            const colorIndicator = `<span class="hl-color-btn" data-hl-id="${escapeHtml(h.id)}" style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${colorBgs[h.color] || '#FFEB3B'};margin-right:10px;flex-shrink:0;cursor:pointer;border:2px solid rgba(255,255,255,0.3);" onclick="event.stopPropagation();showHighlightColorPicker('${escapeHtml(h.id)}', this)" title="Change color"></span>`;
            items.push(`
	              <div class="toc-item" style="display:flex;align-items:center;" onclick="${canLocate ? `scrollToHighlight('${escapeHtml(h.id)}')` : `jumpToProgress(${h.progress || 0})`}">
	                ${colorIndicator}
	                <span style="flex:1;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(excerpt)}</span>
	                <span style="color:var(--text-secondary);cursor:pointer;margin-left:8px;" onclick="event.stopPropagation();removeHighlights(['${escapeHtml(h.id)}'])">×</span>
	              </div>
	            `);
              renderedCount++;
	          }
	        }
	      }

	      if (notes?.length) {
	        items.push(`<div style="padding:0 16px 10px;color:var(--text-secondary);font-size:0.85rem;">Notes</div>`);
	        for (const n of notes.slice().sort((a,b)=>b.timestamp-a.timestamp)) {
            if (query && !matchesQuery(n.note) && !matchesQuery(n.title)) continue;
	          const label = (n.note || '').trim().slice(0, 80) || 'Note';
	          const canLocate = (typeof n.chapterIndex === 'number' && typeof n.startChar === 'number');
          items.push(`
	            <div class="toc-item" onclick="${canLocate ? `scrollToNote('${escapeHtml(n.id)}')` : `jumpToProgress(${n.progress || 0})`}">
	              ${escapeHtml(label)}
	              <span style="float:right;color:var(--text-secondary);cursor:pointer;" onclick="event.stopPropagation();openNoteEditor('${escapeHtml(n.id)}')">✎</span>
	            </div>
	          `);
          renderedCount++;
	        }
	      }

	      if (bookmarks?.length) {
	        items.push(`<div style="padding:0 16px 10px;color:var(--text-secondary);font-size:0.85rem;">Bookmarks</div>`);
	        for (const b of bookmarks.slice().sort((a,b)=>b.timestamp-a.timestamp)) {
            if (query && !matchesQuery(b.label)) continue;
	          items.push(`
	            <div class="toc-item" onclick="jumpToProgress(${b.progress || 0})">
	              ${escapeHtml(b.label || 'Bookmark')} • ${Math.round((b.progress || 0) * 100)}%
	              <span style="float:right;color:#999;cursor:pointer;" onclick="event.stopPropagation();deleteBookmark('${escapeHtml(b.id)}')">×</span>
	            </div>
	          `);
          renderedCount++;
	        }
	      }

      if (renderedCount === 0) {
        const msg = query ? 'No annotations match your search' : t('noBookmarks');
        items.push(`<div style="padding:16px;color:var(--text-secondary);">${escapeHtml(msg)}</div>`);
		      }

	      els.bookmarksList.innerHTML = items.join('');
	    }

	    function scrollToHighlight(id) {
        // Record current position before navigating
        recordReaderPosition();

        // Handle PDF highlights
        if (currentBook?.format === 'pdf') {
          const h = (currentHighlights || []).find(x => x.id === id);
          if (h && h.pageNum) {
            scrollToPdfHighlight(h);
          }
          return;
        }

	      const el = els.readerContent?.querySelector?.(`mark.hl[data-hl-id="${cssEscape(id)}"]`);
	      if (el) {
	        el.scrollIntoView({ behavior: 'smooth', block: 'center' });

	        // Add flash animation to the highlight
	        el.classList.remove('highlight-flash');
	        void el.offsetWidth; // Force reflow to restart animation
	        el.classList.add('highlight-flash');

	        // Add locator arrow above the highlight
	        document.querySelectorAll('.highlight-locator').forEach(l => l.remove());
	        const locator = document.createElement('div');
	        locator.className = 'highlight-locator';

	        // Set arrow color based on highlight color
	        const hlColor = el.dataset.color || 'yellow';
	        const colorMap = {
	          yellow: '#ffd600', green: '#00e676', blue: '#2196f3',
	          pink: '#ff4081', purple: '#e040fb', orange: '#ff9100'
	        };
	        locator.style.setProperty('--hl-arrow', colorMap[hlColor] || '#ffc107');
	        document.body.appendChild(locator);

	        // Position the locator after scroll completes
	        setTimeout(() => {
	          const rect = el.getBoundingClientRect();
	          locator.style.top = `${rect.top - 40}px`;
	          locator.style.left = `${rect.left + rect.width / 2}px`;
	        }, 300);

	        // Clean up
	        setTimeout(() => {
	          el.classList.remove('highlight-flash');
	          locator.remove();
	        }, 1500);
	        return;
	      }
	      const h = (currentHighlights || []).find(x => x.id === id);
	      if (h) jumpToProgress(h.progress || 0);
	    }

    function scrollToNote(id) {
        // Record current position before navigating
        recordReaderPosition();

	      const el = els.readerContent?.querySelector?.(`.note-anchor[data-note-id="${cssEscape(id)}"]`);
	      if (el) {
	        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
	        return;
	      }
	      const n = (currentNotes || []).find(x => x.id === id);
      if (n) jumpToProgress(n.progress || 0);
    }

    function onAnnotationSearch(query, fromInput = false) {
      annotationQuery = (query || '').trim().toLowerCase();
      if (!fromInput) {
        const input = document.getElementById('annotation-search');
        if (input && input.value !== query) input.value = query;
      }
      refreshBookmarksAndHighlights().catch(() => {});
    }

	    function showHighlightColorPicker(hlId, anchorEl) {
	      // Remove any existing color picker
	      document.querySelectorAll('.hl-color-picker-popup').forEach(p => p.remove());

	      const colors = [
	        { name: 'yellow', bg: '#FFEB3B' },
	        { name: 'green', bg: '#4CAF50' },
	        { name: 'blue', bg: '#2196F3' },
	        { name: 'pink', bg: '#E91E63' },
	        { name: 'purple', bg: '#9C27B0' },
	        { name: 'orange', bg: '#FF9800' }
	      ];

	      const popup = document.createElement('div');
	      popup.className = 'hl-color-picker-popup';
	      popup.style.cssText = 'position:fixed;background:var(--bg-card);border:1px solid var(--border);border-radius:8px;padding:8px;display:flex;gap:6px;z-index:10000;box-shadow:0 4px 16px rgba(0,0,0,0.3);';

	      colors.forEach(c => {
	        const btn = document.createElement('button');
	        btn.style.cssText = `width:24px;height:24px;border-radius:50%;border:2px solid rgba(255,255,255,0.3);background:${c.bg};padding:0;min-width:0;cursor:pointer;transition:transform 0.1s;`;
	        btn.title = c.name;
	        btn.addEventListener('mouseenter', () => btn.style.transform = 'scale(1.15)');
	        btn.addEventListener('mouseleave', () => btn.style.transform = 'scale(1)');
	        btn.addEventListener('click', async (e) => {
	          e.preventDefault();
	          e.stopPropagation();
	          await changeHighlightColor(hlId, c.name);
	          popup.remove();
	        });
	        popup.appendChild(btn);
	      });

	      document.body.appendChild(popup);

	      // Position the popup near the anchor
	      const rect = anchorEl.getBoundingClientRect();
	      popup.style.left = `${Math.min(rect.left, window.innerWidth - popup.offsetWidth - 10)}px`;
	      popup.style.top = `${rect.bottom + 5}px`;

	      // Close on click outside
	      const closeHandler = (e) => {
	        if (!popup.contains(e.target) && e.target !== anchorEl) {
	          popup.remove();
	          document.removeEventListener('click', closeHandler);
	        }
	      };
	      setTimeout(() => document.addEventListener('click', closeHandler), 10);
	    }

	    async function changeHighlightColor(hlId, newColor) {
	      if (!currentBook) return;
	      const result = await ipcRenderer.invoke('update-highlight-color', currentBook.id, hlId, newColor);
	      if (result) {
	        // Update local state
	        const idx = currentHighlights.findIndex(h => h.id === hlId);
	        if (idx >= 0) {
	          currentHighlights[idx].color = newColor;
	        }
	        // Re-apply highlights to DOM and refresh sidebar
	        applyAnnotationsToDom();
	        await refreshBookmarksAndHighlights();
	        showToast('Color changed', 'success');
	      }
	    }

    async function addBookmark() {
      if (!currentBook) return;
      const progress = getReaderProgress().progress;
      const label = `Bookmark at ${Math.round(progress * 100)}%`;
      await ipcRenderer.invoke('add-bookmark', currentBook.id, { label, progress });
      await refreshBookmarksAndHighlights();
      showToast('Added bookmark', 'success');
    }

    async function deleteBookmark(bookmarkId) {
      if (!currentBook) return;
      await ipcRenderer.invoke('delete-bookmark', currentBook.id, bookmarkId);
      await refreshBookmarksAndHighlights();
    }

	    function jumpToProgress(progress) {
	      // Record current position before navigating
	      recordReaderPosition();

	      const rc = els.readerContent;
	      if (!rc) return;
	      const maxScroll = Math.max(0, rc.scrollHeight - rc.clientHeight);
	      rc.scrollTop = maxScroll * Math.max(0, Math.min(1, progress || 0));

	      if (currentBook?.format === 'epub') {
	        // Ensure the new chapter+ratio location is persisted, so resume works reliably.
	        setTimeout(() => flushProgressAndTime(true).catch(() => {}), 250);
	      }
	    }

    function toggleBookmarks() {
      els.bookmarksSidebar.classList.toggle('hidden');
      els.tocSidebar.classList.toggle('hidden', !els.bookmarksSidebar.classList.contains('hidden'));
    }

	    function hideSelectionPopup() {
	      const popup = document.getElementById('search-popup');
	      if (!popup) return;
	      popup.classList.add('hidden');
	      popup.innerHTML = '';
	    }

	    function showSelectionPopup(text, anchorRect, fallbackPoint) {
	      const popup = document.getElementById('search-popup');
	      if (!popup) return;
	      showSelectionPopup._shownAt = Date.now();
	      popup.innerHTML = '';

	      const mkBtn = (label, fn, style = '') => {
	        const btn = document.createElement('button');
	        btn.textContent = label;
	        if (style) btn.style.cssText = style;
	        btn.addEventListener('click', async (e) => {
	          e.preventDefault();
	          e.stopPropagation();
	          try { await fn(); } finally { hideSelectionPopup(); }
	        });
	        return btn;
	      };

	      popup.appendChild(mkBtn('Search Google', () => searchGoogle(text)));
	      popup.appendChild(mkBtn('Search Google AI', () => searchGoogleAI(text)));

	      // Highlight color picker
	      const hlRow = document.createElement('div');
	      hlRow.style.cssText = 'display:flex;align-items:center;gap:6px;padding:8px 14px;border-top:1px solid var(--border);';
	      const hlLabel = document.createElement('span');
	      hlLabel.textContent = 'Highlight:';
	      hlLabel.style.cssText = 'font-size:0.85rem;color:var(--text-secondary);margin-right:4px;';
	      hlRow.appendChild(hlLabel);

	      const colors = [
	        { name: 'yellow', bg: '#FFEB3B' },
	        { name: 'green', bg: '#4CAF50' },
	        { name: 'blue', bg: '#2196F3' },
	        { name: 'pink', bg: '#E91E63' },
	        { name: 'purple', bg: '#9C27B0' },
	        { name: 'orange', bg: '#FF9800' }
	      ];
	      colors.forEach(c => {
	        const colorBtn = document.createElement('button');
	        colorBtn.style.cssText = `width:22px;height:22px;border-radius:50%;border:2px solid rgba(0,0,0,0.15);background:${c.bg};padding:0;min-width:0;cursor:pointer;transition:transform 0.1s;`;
	        colorBtn.title = c.name;
	        colorBtn.addEventListener('mouseenter', () => colorBtn.style.transform = 'scale(1.15)');
	        colorBtn.addEventListener('mouseleave', () => colorBtn.style.transform = 'scale(1)');
	        colorBtn.addEventListener('click', async (e) => {
	          e.preventDefault();
	          e.stopPropagation();
	          try { await addHighlightFromSelection(c.name); } finally { hideSelectionPopup(); }
	        });
	        hlRow.appendChild(colorBtn);
	      });
	      popup.appendChild(hlRow);

	      popup.appendChild(mkBtn('Note', () => addNoteFromSelection()));

	      const ids = getHighlightIdsInCurrentSelection();
	      if (ids.length) {
	        popup.appendChild(mkBtn('Remove highlight', () => removeHighlights(ids)));
	      }

	      const padding = 10;
	      const rect = anchorRect && (anchorRect.width || anchorRect.height) ? anchorRect : null;
	      const x0 = rect ? rect.left : (fallbackPoint?.x ?? (window.innerWidth / 2));
	      const y0 = rect ? rect.bottom : (fallbackPoint?.y ?? (window.innerHeight / 2));

	      popup.classList.remove('hidden');
	      popup.style.left = '-9999px';
	      popup.style.top = '-9999px';
	      const w = popup.offsetWidth || 220;
	      const h = popup.offsetHeight || 120;
	      const x = Math.min(window.innerWidth - w - padding, Math.max(padding, x0));
	      const y = Math.min(window.innerHeight - h - padding, Math.max(padding, y0 + 8));
	      popup.style.left = `${x}px`;
	      popup.style.top = `${y}px`;
	    }

	    function updateSelectionPopupFromSelection(fallbackPoint) {
	      const popup = document.getElementById('search-popup');
	      if (!popup) return;
	      if (settings.selectionPopupEnabled === false) {
	        hideSelectionPopup();
	        return;
	      }

	      const sel = window.getSelection();
	      const text = sel ? sel.toString().trim() : '';
	      if (!sel || sel.isCollapsed || !text) {
	        hideSelectionPopup();
	        return;
	      }

	      const anchorNode = sel.anchorNode;
	      const anchorEl = anchorNode && (anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement);
	      if (!anchorEl || !els.readerContent || !els.readerContent.contains(anchorEl)) {
	        hideSelectionPopup();
	        return;
	      }

	      let rect = null;
	      try {
	        if (sel.rangeCount > 0) rect = sel.getRangeAt(0).getBoundingClientRect();
	      } catch (e) {}
	      showSelectionPopup(text, rect, fallbackPoint);
	    }

		    let suppressSelectionChangeUntil = 0;
		    document.getElementById('reader-content').addEventListener('mouseup', (e) => {
		      // Some platforms collapse the selection right after mouseup; suppress selectionchange-driven hides briefly.
		      suppressSelectionChangeUntil = Date.now() + 240;
		      updateSelectionPopupFromSelection({ x: e.clientX, y: e.clientY });
		    });

		    let isPointerSelectingText = false;
		    document.getElementById('reader-content').addEventListener('mousedown', (e) => {
		      if (e.button !== 0) return;
		      isPointerSelectingText = true;
		    });
		    window.addEventListener('mouseup', () => { isPointerSelectingText = false; });

    const shouldHandleMiddleClickToggle = (target) => {
      if (!currentBook) return false;
      const el = target && (target.nodeType === 1 ? target : target.parentElement);
      if (!el || !els.readerView?.contains(el)) return false;
      const editableHost = el.closest('input, textarea, select, [contenteditable]');
      if (editableHost && (editableHost.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/.test(editableHost.tagName))) return false;
      if (el.closest('.toc-item')) return false;
      return true;
    };

    els.readerView?.addEventListener('mousedown', (e) => {
      if (e.button !== 1) return;
      if (!shouldHandleMiddleClickToggle(e.target)) return;
      e.preventDefault();
    });

    els.readerView?.addEventListener('auxclick', (e) => {
      if (e.button !== 1) return;
      if (!shouldHandleMiddleClickToggle(e.target)) return;
      e.preventDefault();
      toggleReaderMenusByMiddleClick();
    });

		    document.getElementById('reader-content').addEventListener('click', () => {
		      if (currentBook) {
		        clearTimeout(tocHideTimer);
		        els.readerView?.classList?.add('reader-toc-hidden');
		      }
		    });

		    document.addEventListener('selectionchange', () => {
		      if (Date.now() < suppressSelectionChangeUntil) return;
		      if (isPointerSelectingText) return;
		      clearTimeout(updateSelectionPopupFromSelection._t);
		      updateSelectionPopupFromSelection._t = setTimeout(() => updateSelectionPopupFromSelection(), 160);
		    });

	    function searchGoogle(text) {
	      ipcRenderer.invoke('open-external', `https://www.google.com/search?q=${encodeURIComponent(text)}`);
	      hideSelectionPopup();
	    }

	    function searchGoogleAI(text) {
	      ipcRenderer.invoke('open-external', `https://www.google.com/search?q=${encodeURIComponent(text)}&udm=50`);
	      hideSelectionPopup();
	    }

	    function getSelectionRangeInReader() {
	      if (!currentBook) return null;
	      const sel = window.getSelection();
	      if (!sel || sel.isCollapsed || sel.rangeCount === 0) return null;
	      const range = sel.getRangeAt(0);
	      const anchorNode = sel.anchorNode;
	      const anchorEl = anchorNode && (anchorNode.nodeType === 1 ? anchorNode : anchorNode.parentElement);
	      if (!anchorEl || !els.readerContent || !els.readerContent.contains(anchorEl)) return null;
	      return range;
	    }

	    function getChapterIndexForNode(node) {
	      const el = (node && node.nodeType === 1) ? node : node?.parentElement;
	      const chapter = el?.closest?.('.chapter');
	      if (!chapter) return -1;
	      const id = chapter.id || '';
	      const m = id.match(/^chapter-(\d+)$/);
	      return m ? Number(m[1]) : -1;
	    }

		    function charOffsetWithin(el, container, offset) {
		      if (!el || !container) return 0;
		      const r = document.createRange();
		      r.selectNodeContents(el);
		      try { r.setEnd(container, offset); } catch (e) { return 0; }

		      // Avoid Range#toString(): browsers may insert extra newlines between blocks,
		      // which skews character offsets and can cause highlights to target the wrong occurrence.
		      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
		        acceptNode(node) {
		          const p = node.parentElement;
		          if (!p) return NodeFilter.FILTER_REJECT;
		          if (p.closest('script,style,noscript')) return NodeFilter.FILTER_REJECT;
		          if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
		          return NodeFilter.FILTER_ACCEPT;
		        }
		      });

		      let total = 0;
		      let tn = walker.nextNode();
		      while (tn) {
		        const len = tn.nodeValue.length;
		        try {
		          // If this text node starts after the range end, we're done.
		          if (r.comparePoint(tn, 0) === 1) break;
		        } catch (e) {}

		        if (tn === container) {
		          const clamped = Math.max(0, Math.min(len, Number(offset || 0)));
		          return total + clamped;
		        }

		        total += len;
		        tn = walker.nextNode();
		      }

		      return total;
		    }

	    function findTextPositionAt(el, charOffset) {
	      const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
	        acceptNode(node) {
	          const p = node.parentElement;
	          if (!p) return NodeFilter.FILTER_REJECT;
	          if (p.closest('script,style,noscript')) return NodeFilter.FILTER_REJECT;
	          if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
	          return NodeFilter.FILTER_ACCEPT;
	        }
	      });
	      let remaining = Math.max(0, Number(charOffset || 0));
	      let node = walker.nextNode();
	      while (node) {
	        const len = node.nodeValue.length;
	        if (remaining <= len) return { node, offset: remaining };
	        remaining -= len;
	        node = walker.nextNode();
	      }
	      return null;
	    }

	    function wrapCharRange(el, startChar, endChar, wrapperFactory) {
	      const start = findTextPositionAt(el, startChar);
	      const end = findTextPositionAt(el, endChar);
	      if (!start || !end) return false;

	      const range = document.createRange();
	      range.setStart(start.node, start.offset);
	      range.setEnd(end.node, end.offset);

	      const textWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, {
	        acceptNode(node) {
	          const p = node.parentElement;
	          if (!p) return NodeFilter.FILTER_REJECT;
	          if (p.closest('script,style,noscript')) return NodeFilter.FILTER_REJECT;
	          if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
	          return NodeFilter.FILTER_ACCEPT;
	        }
	      });

	      const nodes = [];
	      let tn = textWalker.nextNode();
	      while (tn) {
	        try {
	          if (range.intersectsNode(tn)) nodes.push(tn);
	        } catch (e) {}
	        tn = textWalker.nextNode();
	      }

	      if (!nodes.length) return false;

	      for (let i = nodes.length - 1; i >= 0; i--) {
	        const node = nodes[i];
	        if (!node.nodeValue) continue;
	        const nodeRange = document.createRange();
	        nodeRange.selectNodeContents(node);

	        const segStart = (node === range.startContainer) ? range.startOffset : 0;
	        const segEnd = (node === range.endContainer) ? range.endOffset : node.nodeValue.length;
	        if (segEnd <= segStart) continue;

	        const before = node.nodeValue.slice(0, segStart);
	        const middle = node.nodeValue.slice(segStart, segEnd);
	        const after = node.nodeValue.slice(segEnd);

	        const frag = document.createDocumentFragment();
	        if (before) frag.appendChild(document.createTextNode(before));
	        const wrap = wrapperFactory();
	        wrap.appendChild(document.createTextNode(middle));
	        frag.appendChild(wrap);
	        if (after) frag.appendChild(document.createTextNode(after));
	        node.parentNode.replaceChild(frag, node);
	      }

	      return true;
	    }

		    function unwrapAnnotated(selector) {
		      const nodes = [...els.readerContent.querySelectorAll(selector)];
		      // Unwrap from deepest to shallowest to handle nested highlights safely.
		      nodes.reverse().forEach((el) => {
		        if (!el.parentNode) return;
		        const text = document.createTextNode(el.textContent || '');
		        el.parentNode.replaceChild(text, el);
		      });
		      // Normalize to merge adjacent text nodes (important for character offset calculations)
		      els.readerContent.normalize();
		    }

		    function applyAnnotationsToDom() {
		      if (!currentBook) return;
		      unwrapAnnotated('mark.hl, .note-anchor');
		      const chapters = [...els.readerContent.querySelectorAll('.chapter')];
		      if (!chapters.length) return;

	      const highlights = (currentHighlights || []).filter(h => typeof h.chapterIndex === 'number' && h.text);
	      const notes = (currentNotes || []).filter(n => typeof n.chapterIndex === 'number' && typeof n.startChar === 'number' && typeof n.endChar === 'number');

	      // Group by chapter
	      const perChapter = new Map();
	      for (const h of highlights) {
	        const key = h.chapterIndex;
	        if (!perChapter.has(key)) perChapter.set(key, []);
	        perChapter.get(key).push({ type: 'highlight', item: h });
	      }
	      for (const n of notes) {
	        const key = n.chapterIndex;
	        if (!perChapter.has(key)) perChapter.set(key, []);
	        perChapter.get(key).push({ type: 'note', item: n });
	      }

	      for (const [chapterIndex, items] of perChapter.entries()) {
	        let chEl = document.getElementById(`chapter-${chapterIndex}`);
	        if (!chEl) chEl = chapters[chapterIndex];
	        if (!chEl) continue;

	        // Sort: by startChar descending (apply from end first to preserve positions)
	        const sortedItems = items.slice().sort((a, b) => {
	          const aStart = a.item.startChar || 0;
	          const bStart = b.item.startChar || 0;
	          return bStart - aStart;
	        });

		        sortedItems.forEach(({ type, item }) => {
		          if (type === 'highlight' && item.text) {
		            const hasRange = (typeof item.startChar === 'number' && typeof item.endChar === 'number' && item.endChar > item.startChar);
		            if (hasRange) {
		              const ok = wrapCharRange(chEl, item.startChar, item.endChar, () => {
		                const mark = document.createElement('mark');
		                mark.className = 'hl';
		                mark.dataset.hlId = item.id;
		                if (item.color) mark.dataset.color = item.color;
		                return mark;
		              });
		              if (!ok) highlightTextInChapter(chEl, item.text.trim(), item.id, item.color, item.startChar);
		            } else {
		              highlightTextInChapter(chEl, item.text.trim(), item.id, item.color, item.startChar);
		            }
			          } else if (type === 'note') {
			            wrapCharRange(chEl, item.startChar, item.endChar, () => {
			              const s = document.createElement('span');
			              s.className = 'note-anchor';
			              s.dataset.noteId = item.id;
			              return s;
			            });
			          }
			        });
		      }
		    }

	    function highlightTextInChapter(chapterEl, searchText, hlId, color, hintStartChar) {
	      if (!chapterEl || !searchText) return false;

	      // Normalize the search text
	      const normalizedSearch = searchText.replace(/\s+/g, ' ').trim();
	      if (normalizedSearch.length < 2) return false;

	      // Get all text nodes
	      const walker = document.createTreeWalker(chapterEl, NodeFilter.SHOW_TEXT, {
	        acceptNode(node) {
	          if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
	          const p = node.parentElement;
	          if (!p || p.closest('script,style,noscript')) return NodeFilter.FILTER_REJECT;
	          return NodeFilter.FILTER_ACCEPT;
	        }
	      });

	      const textNodes = [];
	      let node;
	      while ((node = walker.nextNode())) {
	        textNodes.push(node);
	      }

	      if (!textNodes.length) return false;

	      // Build full text
	      let fullText = '';
	      const nodeOffsets = [];
	      for (const tn of textNodes) {
	        nodeOffsets.push({ node: tn, start: fullText.length });
	        fullText += tn.nodeValue;
	      }

	      // Normalize full text for comparison
	      const normalizedFull = fullText.replace(/\s+/g, ' ');

	      // Convert hintStartChar from original to normalized position
	      let normalizedHint = -1;
	      if (typeof hintStartChar === 'number' && hintStartChar >= 0) {
	        let normPos = 0;
	        for (let i = 0; i < fullText.length && i <= hintStartChar; i++) {
	          if (i === hintStartChar) {
	            normalizedHint = normPos;
	            break;
	          }
	          if (/\s/.test(fullText[i])) {
	            if (i === 0 || !/\s/.test(fullText[i - 1])) {
	              normPos++;
	            }
	          } else {
	            normPos++;
	          }
	        }
	        if (normalizedHint === -1) normalizedHint = normPos;
	      }

	      // Find all occurrences of the search text
	      const searchLower = normalizedSearch.toLowerCase();
	      const fullLower = normalizedFull.toLowerCase();
	      const occurrences = [];
	      let searchIdx = 0;
	      while ((searchIdx = fullLower.indexOf(searchLower, searchIdx)) !== -1) {
	        occurrences.push(searchIdx);
	        searchIdx += 1;
	      }
	      if (occurrences.length === 0) return false;

	      // Pick the occurrence closest to normalizedHint (if provided)
	      let idx;
	      if (normalizedHint >= 0 && occurrences.length > 1) {
	        idx = occurrences.reduce((best, curr) =>
	          Math.abs(curr - normalizedHint) < Math.abs(best - normalizedHint) ? curr : best
	        );
	      } else {
	        idx = occurrences[0];
	      }

	      const endIdx = idx + normalizedSearch.length;

	      // Map normalized positions back to original positions
	      let normPos = 0;
	      let startOrigIdx = -1, endOrigIdx = -1;

	      for (let i = 0; i < fullText.length; i++) {
	        if (normPos === idx && startOrigIdx === -1) {
	          startOrigIdx = i;
	        }
	        if (normPos === endIdx && endOrigIdx === -1) {
	          endOrigIdx = i;
	          break;
	        }

	        // Advance normPos based on whitespace collapsing
	        if (/\s/.test(fullText[i])) {
	          if (i === 0 || !/\s/.test(fullText[i - 1])) {
	            normPos++;
	          }
	        } else {
	          normPos++;
	        }
	      }

	      if (startOrigIdx === -1) startOrigIdx = idx;
	      if (endOrigIdx === -1) endOrigIdx = fullText.length;

	      // Find which nodes contain the range
	      let startNode = null, startOffset = 0, endNode = null, endOffset = 0;
	      for (const { node: tn, start } of nodeOffsets) {
	        const end = start + tn.nodeValue.length;
	        if (!startNode && startOrigIdx >= start && startOrigIdx < end) {
	          startNode = tn;
	          startOffset = startOrigIdx - start;
	        }
	        if (endOrigIdx > start && endOrigIdx <= end) {
	          endNode = tn;
	          endOffset = endOrigIdx - start;
	          break;
	        }
	      }

	      if (!startNode || !endNode) return false;

	      // Wrap the text
	      try {
	        if (startNode === endNode) {
	          const tn = startNode;
	          const before = tn.nodeValue.slice(0, startOffset);
	          const middle = tn.nodeValue.slice(startOffset, endOffset);
	          const after = tn.nodeValue.slice(endOffset);

	          const frag = document.createDocumentFragment();
	          if (before) frag.appendChild(document.createTextNode(before));
	          const mark = document.createElement('mark');
	          mark.className = 'hl';
	          mark.dataset.hlId = hlId;
	          if (color) mark.dataset.color = color;
	          mark.appendChild(document.createTextNode(middle));
	          frag.appendChild(mark);
	          if (after) frag.appendChild(document.createTextNode(after));
	          tn.parentNode.replaceChild(frag, tn);
	          return true;
	        } else {
	          // Multi-node range - wrap each segment
	          const nodesToWrap = [];
	          let inRange = false;
	          for (const { node: tn } of nodeOffsets) {
	            if (tn === startNode) inRange = true;
	            if (inRange) nodesToWrap.push(tn);
	            if (tn === endNode) break;
	          }

	          for (let i = nodesToWrap.length - 1; i >= 0; i--) {
	            const tn = nodesToWrap[i];
	            const segStart = (tn === startNode) ? startOffset : 0;
	            const segEnd = (tn === endNode) ? endOffset : tn.nodeValue.length;
	            if (segEnd <= segStart) continue;

	            const before = tn.nodeValue.slice(0, segStart);
	            const middle = tn.nodeValue.slice(segStart, segEnd);
	            const after = tn.nodeValue.slice(segEnd);

	            const frag = document.createDocumentFragment();
	            if (before) frag.appendChild(document.createTextNode(before));
	            const mark = document.createElement('mark');
	            mark.className = 'hl';
	            mark.dataset.hlId = hlId;
	            if (color) mark.dataset.color = color;
	            mark.appendChild(document.createTextNode(middle));
	            frag.appendChild(mark);
	            if (after) frag.appendChild(document.createTextNode(after));
	            tn.parentNode.replaceChild(frag, tn);
	          }
	          return true;
	        }
	      } catch (e) {
	        console.warn('highlightTextInChapter error:', e);
	        return false;
	      }
	    }

	    async function loadAnnotations() {
	      if (!currentBook) return;
	      try {
	        currentHighlights = await ipcRenderer.invoke('get-highlights', currentBook.id);
	      } catch (e) { currentHighlights = []; }
	      try {
	        currentNotes = await ipcRenderer.invoke('get-notes', currentBook.id);
	      } catch (e) { currentNotes = []; }
	      applyAnnotationsToDom();
	    }

	    function getHighlightIdsInCurrentSelection() {
	      const range = getSelectionRangeInReader();
	      if (!range) return [];
	      const container = range.commonAncestorContainer.nodeType === 1 ? range.commonAncestorContainer : range.commonAncestorContainer.parentElement;
	      const scope = container?.closest?.('.chapter') || els.readerContent;
	      const marks = [...scope.querySelectorAll('mark.hl')];

	      // Find all marks that intersect with the selection
	      const intersecting = [];
	      for (const m of marks) {
	        try {
	          if (range.intersectsNode(m)) {
	            intersecting.push(m);
	          }
	        } catch (e) {}
	      }

	      if (!intersecting.length) return [];

	      // For nested highlights, find the innermost one(s) that contain the selection
	      // A mark is "innermost" if no other intersecting mark is its descendant
	      const innermost = intersecting.filter(m => {
	        // Check if any other intersecting mark is a descendant of this one
	        return !intersecting.some(other => other !== m && m.contains(other));
	      });

	      // Return only the innermost highlight IDs
	      const ids = new Set(innermost.map(m => m.dataset.hlId));
	      return [...ids].filter(Boolean);
	    }

		    async function addHighlightFromSelection(color = 'yellow') {
		      if (!currentBook) return;
		      const range = getSelectionRangeInReader();
		      if (!range) return;

        // Handle PDF highlights
        if (currentBook.format === 'pdf') {
          await addPdfHighlightFromSelection(range, color);
          return;
        }

	      const chapterIndex = getChapterIndexForNode(range.startContainer);
	      const chapterIndexEnd = getChapterIndexForNode(range.endContainer);
	      if (chapterIndex < 0 || chapterIndexEnd !== chapterIndex) {
	        showToast('Highlight within a single chapter only (for now)', 'error');
	        return;
	      }
	      const chapterEl = document.getElementById(`chapter-${chapterIndex}`);
	      if (!chapterEl) return;

		      let startChar = charOffsetWithin(chapterEl, range.startContainer, range.startOffset);
		      let endChar = charOffsetWithin(chapterEl, range.endContainer, range.endOffset);
		      if (endChar < startChar) [startChar, endChar] = [endChar, startChar];
		      const text = String(range.toString() || '').trim().slice(0, 240);
		      if (!text) return;

	      // Check for exact match highlights (same text AND same position) - update color instead
	      const existingInChapter = (currentHighlights || []).filter(h =>
	        h.chapterIndex === chapterIndex && h.text
	      );

	      // Find highlights with exact same text AND position (update color for these)
	      const exactMatch = existingInChapter.find(h =>
	        h.text.trim() === text.trim() &&
	        Math.abs((h.startChar || 0) - startChar) < 5 &&
	        Math.abs((h.endChar || 0) - endChar) < 5
	      );

	      if (exactMatch) {
	        // Exact same text - just update color
	        await ipcRenderer.invoke('update-highlight-color', currentBook.id, exactMatch.id, color);
	        const idx = currentHighlights.findIndex(x => x.id === exactMatch.id);
	        if (idx >= 0) currentHighlights[idx].color = color;
	        applyAnnotationsToDom();
	        hideSelectionPopup();
	        window.getSelection()?.removeAllRanges();
	        await refreshBookmarksAndHighlights();
	        showToast('Color updated', 'success');
	        return;
	      }

	      // Otherwise, create a new highlight (supports nested highlights)
	      const progress = getReaderProgress().progress;
	      const highlight = await ipcRenderer.invoke('add-highlight', currentBook.id, { text, progress, chapterIndex, startChar, endChar, color });
	      currentHighlights = (currentHighlights || []).concat([highlight]);
	      applyAnnotationsToDom();
	      hideSelectionPopup();
	      window.getSelection()?.removeAllRanges();
	      await refreshBookmarksAndHighlights();
	      showToast('Highlighted', 'success');
	    }

      // Add highlight for PDF text selection
	      async function addPdfHighlightFromSelection(range, color) {
	        // Find which page the selection is in
	        let pageEl = range.startContainer.parentElement;
	        while (pageEl && !pageEl.classList.contains('pdf-page')) {
	          pageEl = pageEl.parentElement;
	        }
	        if (!pageEl) {
	          showToast('Could not determine PDF page', 'error');
	          return;
	        }

	        const pageNum = parseInt(pageEl.dataset.pageNum);
	        if (!pageNum) return;

	        // Range highlights are only supported within a single PDF page for now
	        let endPageEl = range.endContainer.parentElement;
	        while (endPageEl && !endPageEl.classList.contains('pdf-page')) {
	          endPageEl = endPageEl.parentElement;
	        }
	        if (endPageEl && endPageEl !== pageEl) {
	          showToast('Highlight within a single page only (for now)', 'error');
	          return;
	        }

	        const textLayer = pageEl.querySelector('.textLayer');
	        if (!textLayer) return;

	        const pageContainer = pageEl.querySelector('.pdf-page-container');
	        if (!pageContainer) return;

	        // Get the selected text directly from the range
	        const text = String(range.toString() || '').trim().slice(0, 240);
	        if (!text) return;

	        // Store selection rectangles (normalized to page container) for accurate highlights
	        const rects = clientRectsToNormalizedRects(pageContainer, range.getClientRects());
	        if (!rects.length) return;

	        // Also compute selected span indices for backwards-compat matching/fallback
	        const spans = Array.from(textLayer.querySelectorAll('span'));
	        const selectedSpanIndices = [];
	        const selectionRects = range.getClientRects();

	        for (let i = 0; i < spans.length; i++) {
          const span = spans[i];
          const spanRect = span.getBoundingClientRect();

          // Check if this span's rect overlaps with any selection rect
          let isSelected = false;
          for (const selRect of selectionRects) {
            // Check for meaningful overlap (not just touching)
            const overlapX = Math.min(spanRect.right, selRect.right) - Math.max(spanRect.left, selRect.left);
            const overlapY = Math.min(spanRect.bottom, selRect.bottom) - Math.max(spanRect.top, selRect.top);

            if (overlapX > 2 && overlapY > 2) {
              isSelected = true;
              break;
            }
          }

          if (isSelected) {
            selectedSpanIndices.push(i);
          }
        }

	        // Store the exact list of selected span indices, not just start/end
	        const spanIndices = [...selectedSpanIndices].sort((a, b) => a - b);

	        const rectsRoughlyEqual = (a, b) => {
	          if (!Array.isArray(a) || !Array.isArray(b) || a.length !== b.length) return false;
	          const sa = a.slice().sort((r1, r2) => (r1.y - r2.y) || (r1.x - r2.x));
	          const sb = b.slice().sort((r1, r2) => (r1.y - r2.y) || (r1.x - r2.x));
	          const tol = 0.004;
	          for (let i = 0; i < sa.length; i++) {
	            const r1 = sa[i];
	            const r2 = sb[i];
	            if (
	              Math.abs((r1.x || 0) - (r2.x || 0)) > tol ||
	              Math.abs((r1.y || 0) - (r2.y || 0)) > tol ||
	              Math.abs((r1.w || 0) - (r2.w || 0)) > tol ||
	              Math.abs((r1.h || 0) - (r2.h || 0)) > tol
	            ) return false;
	          }
	          return true;
	        };

	        // Check for existing highlight at same position
	        const existingOnPage = (currentHighlights || []).filter(h => h.pageNum === pageNum);
	        const exactMatch = existingOnPage.find(h => {
	          if (Array.isArray(h.rects) && rectsRoughlyEqual(h.rects, rects)) return true;
	          if (h.text?.trim() === text.trim()) {
	            if (Array.isArray(h.rects) && h.rects.length) return rectsRoughlyEqual(h.rects, rects);
	            // Fallback: check if span indices match (older highlights)
	            if (h.spanIndices && spanIndices.length && spanIndices.length === h.spanIndices.length) {
	              return spanIndices.every((idx, i) => idx === h.spanIndices[i]);
	            }
	            return true;
	          }
	          return false;
	        });

        if (exactMatch) {
          await ipcRenderer.invoke('update-highlight-color', currentBook.id, exactMatch.id, color);
          const idx = currentHighlights.findIndex(x => x.id === exactMatch.id);
          if (idx >= 0) currentHighlights[idx].color = color;
          updatePdfPageHighlights(pageNum);
          hideSelectionPopup();
          window.getSelection()?.removeAllRanges();
          await refreshBookmarksAndHighlights();
          showToast('Color updated', 'success');
          return;
        }

	        const progress = getReaderProgress().progress;
	        const highlight = await ipcRenderer.invoke('add-highlight', currentBook.id, {
	          text,
	          progress,
	          pageNum,
	          rects,
	          spanIndices: spanIndices.length ? spanIndices : undefined,
	          color
	        });
        currentHighlights = (currentHighlights || []).concat([highlight]);
        updatePdfPageHighlights(pageNum);
        hideSelectionPopup();
        window.getSelection()?.removeAllRanges();
        await refreshBookmarksAndHighlights();
        showToast('Highlighted', 'success');
      }

	    async function removeHighlights(ids) {
	      if (!currentBook) return;
	      const unique = [...new Set(ids)].filter(Boolean);

        // For PDF, track which pages need updating
        const pdfPagesToUpdate = new Set();
        if (currentBook.format === 'pdf') {
          for (const id of unique) {
            const h = currentHighlights.find(x => x.id === id);
            if (h?.pageNum) pdfPagesToUpdate.add(h.pageNum);
          }
        }

	      for (const id of unique) {
	        await ipcRenderer.invoke('delete-highlight', currentBook.id, id);
	      }
	      currentHighlights = (currentHighlights || []).filter(h => !unique.includes(h.id));

        // Update PDF pages or EPUB DOM
        if (currentBook.format === 'pdf') {
          pdfPagesToUpdate.forEach(pageNum => updatePdfPageHighlights(pageNum));
        } else {
          applyAnnotationsToDom();
        }
	      await refreshBookmarksAndHighlights();
	    }

	    async function addNoteFromSelection() {
	      if (!currentBook) return;
	      const range = getSelectionRangeInReader();
	      if (!range) return;
	      const chapterIndex = getChapterIndexForNode(range.startContainer);
	      const chapterIndexEnd = getChapterIndexForNode(range.endContainer);
	      if (chapterIndex < 0 || chapterIndexEnd !== chapterIndex) {
	        showToast('Note within a single chapter only (for now)', 'error');
	        return;
	      }
	      const chapterEl = document.getElementById(`chapter-${chapterIndex}`);
	      if (!chapterEl) return;

	      const startChar = charOffsetWithin(chapterEl, range.startContainer, range.startOffset);
	      const endChar = charOffsetWithin(chapterEl, range.endContainer, range.endOffset);
	      const quote = String(range.toString() || '').trim().slice(0, 240);
	      if (!quote) return;

	      pendingNoteDraft = { chapterIndex, startChar, endChar, quote, progress: getReaderProgress().progress };
	      showNoteModal({ mode: 'new' });
	      hideSelectionPopup();
	    }

	    function showNoteModal(opts = { mode: 'new' }) {
	      const modal = document.getElementById('note-modal');
	      const text = document.getElementById('note-text');
	      const delBtn = document.getElementById('note-delete-btn');
	      const title = document.getElementById('note-modal-title');
	      if (!modal || !text || !delBtn || !title) return;
	      if (opts.mode === 'edit' && pendingNoteDraft?.noteId) {
	        title.textContent = 'Edit Note';
	        delBtn.style.display = 'block';
	        const note = (currentNotes || []).find(n => n.id === pendingNoteDraft.noteId);
	        text.value = note?.note || '';
	      } else {
	        title.textContent = 'New Note';
	        delBtn.style.display = 'none';
	        text.value = '';
	      }
	      modal.classList.remove('hidden');
	      setTimeout(() => text.focus(), 30);
	    }

	    function hideNoteModal() {
	      const modal = document.getElementById('note-modal');
	      if (modal) modal.classList.add('hidden');
	      pendingNoteDraft = null;
	    }

	    async function saveNoteModal() {
	      if (!currentBook || !pendingNoteDraft) return;
	      const textEl = document.getElementById('note-text');
	      const noteText = String(textEl?.value || '').trim();
	      if (!noteText) {
	        showToast('Note is empty', 'error');
	        return;
	      }
	      if (pendingNoteDraft.mode === 'edit' && pendingNoteDraft.noteId) {
	        const updated = await ipcRenderer.invoke('update-note', currentBook.id, pendingNoteDraft.noteId, { note: noteText });
	        if (updated) {
	          currentNotes = (currentNotes || []).map(n => n.id === updated.id ? updated : n);
	        }
	      } else {
	        const created = await ipcRenderer.invoke('add-note', currentBook.id, {
	          note: noteText,
	          quote: pendingNoteDraft.quote,
	          progress: pendingNoteDraft.progress,
	          chapterIndex: pendingNoteDraft.chapterIndex,
	          startChar: pendingNoteDraft.startChar,
	          endChar: pendingNoteDraft.endChar
	        });
	        currentNotes = (currentNotes || []).concat([created]);
	      }
	      hideNoteModal();
	      applyAnnotationsToDom();
	      await refreshBookmarksAndHighlights();
	      showToast('Saved note', 'success');
	    }

	    async function deleteNoteModal() {
	      if (!currentBook || !pendingNoteDraft?.noteId) return;
	      await ipcRenderer.invoke('delete-note', currentBook.id, pendingNoteDraft.noteId);
	      currentNotes = (currentNotes || []).filter(n => n.id !== pendingNoteDraft.noteId);
	      hideNoteModal();
	      applyAnnotationsToDom();
	      await refreshBookmarksAndHighlights();
	      showToast('Deleted note', 'success');
	    }

	    function openNoteEditor(noteId) {
	      pendingNoteDraft = { mode: 'edit', noteId };
	      showNoteModal({ mode: 'edit' });
	    }

		    document.addEventListener('click', (e) => {
		      if ((Date.now() - (showSelectionPopup._shownAt || 0)) < 250) return;
		      if (!e.target.closest('.search-popup')) {
		        if (!e.target.closest('#reader-content')) hideSelectionPopup();
		      }
		      if (!e.target.closest('.context-menu')) {
		        hideContextMenu();
		      }
		    });

		    document.getElementById('reader-content')?.addEventListener?.('click', (e) => {
		      const noteEl = e.target.closest?.('.note-anchor[data-note-id]');
	      if (noteEl) {
	        e.preventDefault();
	        e.stopPropagation();
	        const id = noteEl.dataset.noteId;
	        if (id) {
	          scrollToNote(id);
	          openNoteEditor(id);
	        }
	        return;
	      }

	      // For highlights: only auto-select if user isn't making their own selection
	      const sel = window.getSelection();
	      const hasSelection = sel && !sel.isCollapsed && sel.toString().trim().length > 0;
	      if (hasSelection) return; // Don't override user's selection

	      // Find the innermost highlight at click position
	      const hlEl = e.target.closest?.('mark.hl[data-hl-id]');
	      if (hlEl) {
	        e.preventDefault();
	        e.stopPropagation();
	        const r = document.createRange();
	        r.selectNodeContents(hlEl);
	        sel.removeAllRanges();
	        sel.addRange(r);
		        updateSelectionPopupFromSelection({ x: e.clientX, y: e.clientY });
		      }
		    });

    window.addEventListener('beforeunload', () => {
      try { stopReadingSession(); } catch (e) {}
    });

    document.addEventListener('keydown', handleReaderArrowNav);
    const handleReaderPointerMove = (e) => {
      if (!currentBook) return;
      const headerHeight = (els.readerHeader?.getBoundingClientRect?.().height || 96) + 24;
      const y = e?.clientY ?? Infinity;
      const x = e?.clientX ?? Infinity;
      const inHeaderZone = settings.readerTopBarVisible !== false && y <= headerHeight;
      if (inHeaderZone) showReaderUi();
      else scheduleReaderUiHide(500);

      const tocRect = els.tocSidebar?.getBoundingClientRect?.();
      const inTocSidebar = tocRect && x >= tocRect.left && x <= tocRect.right && y >= tocRect.top && y <= tocRect.bottom;
      const tocZone = x <= 120 || inTocSidebar;
      if (tocZone) showTocPanel();
      else scheduleTocHide();
    };
    document.addEventListener('mousemove', handleReaderPointerMove, { passive: true });
    ['click', 'keydown', 'touchstart'].forEach(evt => {
      document.addEventListener(evt, (e) => {
        if (!currentBook) return;
        // Only show top bar temporarily on interaction, not TOC
        showReaderUiTemporarily();
        // Only show TOC if click/touch is in the left zone
        if (evt !== 'keydown') {
          const x = evt === 'touchstart' ? (e?.touches?.[0]?.clientX ?? Infinity) : (e?.clientX ?? Infinity);
          if (x <= 120) {
            showTocPanel();
            scheduleTocHide();
          }
        }
      }, { passive: true });
    });

		    document.addEventListener('keydown', (e) => {
		      if (e.defaultPrevented) return;
				      if (e.key === '/' && !e.metaKey && !e.ctrlKey && !e.altKey && !(e.getModifierState && e.getModifierState('AltGraph'))) {
				        const target = e.target;
				        const tag = target?.tagName;
				        const isEditable = target?.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
				        if (isEditable) return;
				        if (currentBook && els.bookSearch) {
				          e.preventDefault();
				          if (bookSearchState.matches.length) {
				            computeSearchMatchPositions();
				            renderSearchCodemap();
				          }
				          showBookSearchResults();
				          els.bookSearch.focus();
				          els.bookSearch.select();
				          return;
				        }
				        if (!currentBook && els.librarySearchInput) {
				          e.preventDefault();
				          openSearch();
				          return;
				        }
				        return;
				      }
			    });

    init();
  </script>
</body>
</html>
